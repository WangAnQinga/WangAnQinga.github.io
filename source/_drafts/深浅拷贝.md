---
title: 深浅拷贝
categories:
tags:
---

## 发生在谁

值不会存在深浅拷贝问题，只有对象才会出现深浅拷贝的问题，因为基本数据类型是值的赋值，对象是指针的引用

## 对象的赋值

对象的赋值，指针复制,两个共用一个指针，指向同一个堆内存，改变一个对象属性值，另一个随之改变

```javascript
const a = {
  b: {
    c: 1,
  },
  d: 10,
};

const cp = a;

cp.b.c = 15;
cp.d = 100;
console.log(a, cp);
```

## 浅拷贝

创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址 ，所以如果其中一个对象改变了这个地址，就会影响到另一个对象。

### Object.assign({},xx)

```javascript
const a = {
  a: 11,
  b: {
    c: 5,
    cc: {
      ccc: 100,
    },
  },
  d: undefined,
  e: function () {
    console.log("e");
  },
  f: [new Date(1536627600000), new Date(1540047600000)],
  g: new RegExp("\\w+"),
  h: NaN,
  i: Infinity,
  j: -Infinity,
};

const cp = Object.assign(a);
cp.b.c = 15;
cp.d = 100;
console.log(a, cp);

// 变量a中的c变成15了,d依旧是10
// 变量cp的其他对象都保留了
```

### JSON.parse(JSON.stringify(xx))

```javascript
const a = {
  a: 11,
  b: {
    c: 5,
    cc: {
      ccc: 100,
    },
  },
  d: undefined,
  e: function () {
    console.log("e");
  },
  f: [new Date(1536627600000), new Date(1540047600000)],
  g: new RegExp("\\w+"),
  h: NaN,
  i: Infinity,
  j: -Infinity,
};

const cp = Object.assign(a);
cp.b.c = 15;
cp.d = 100;
console.log(a, cp);
```

变量 a 中的 b.c 依旧是 5,d 依旧是 10，嵌套引用是成功了
但是，变量 cp 的其他对象 d,e,f,g,h,i,j 被改变了

### 区别

`Object.assign` 可以复制 NAN，date 对象，正则，Function,但是对与嵌套的引用不生效
`JSON` 可以处理嵌套引用，但是对于 NAN，date 对象，正则，Function 等之类的处理不了
只能处理纯 JSON 数据
有几种情况会发生错误
包含不能转成 JSON 格式的数据
循环引用
undefined,NaN, -Infinity, Infinity 都会被转化成 null
RegExp/函数不会拷贝
new Date()会被转成字符串

## 深拷贝

将一个对象从内存中完整的拷贝一份出来,从堆内存中开辟一个新的区域存放新对象,且修改新对象不会影响原对象

## 相关阅读

[https://juejin.cn/post/6844903929705136141](https://juejin.cn/post/6844903929705136141)
