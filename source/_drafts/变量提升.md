---
title: 变量提升

categories:
tags:
---

## 什么是变量提升（hoisting）

变量声明（以及其他声明）总是在任意代码执行之前处理的，所以在代码中的任意位置声明变量总是等效于在代码开头声明。这意味着变量可以在声明之前使用，这个行为叫做“hoisting”。
“hoisting”就像是把所有的变量声明移动到函数或者全局代码的开头位置。

## 变量提升（hoisting）发生在哪个阶段

预解析阶段，也叫做执行上下文阶段

“变量提升”意味着变量和函数的声明会在物理层面移动到代码的最前面，但这么说并不准确。实际上变量和函数声明在代码里的位置是不会动的，而是在编译阶段被放入内存中。

函数和变量相比，会被优先提升。这意味着函数会被提升到更靠前的位置。

## 哪些可以声明变量

var let const

1. var a = 1; // 声明变量
2. b = 2; // 未声明变量
3. let c = 3;
4. const d = 4;
5. const e = {name:'llsc'}

这里提一个变量的作用域：全局作用域，函数作用域，块级作用域（let,const）

## 变量声明的提升

### Demo1 var

预编译的时候进行变量声明的提升，并且赋值未 undefind，作用域限制在其声明位置的上下文中。

var 声明的变量会定义在 window 上，且不可以被删除

```javascript
console.log(x);
var x = 1;

// equal

var x;
console.log(x); // 此时x为undefined
x = 1;
console.log(x, widnow.x); // 输出1,1
delete x;
console.log(x); // 输出 1
```

### Demo2 未声明变量

预编译的时候不会识别出关键字，所以只会在执行赋值才做的时候才会被创建，并且作用域总是全局的

可以理解为，没有声明的关键字,完全不存在声明的说法，更不会出现声明的提升

也会定义在 widnow 上，且可以被删除

```javascript
console.log(1); //ReferenceError x is not defined;
x = 1;
console.log(x, window.x); // 输出 1,1
delete x;
console.log(x); // 此时x被删除了，所有会被报错。ReferenceError x is not defined;
```

### Demo3 let

let 语句声明一个块级作用域的本地变量，并且可选的将其初始化为一个值。
`块级作用域` ===> `{StatementList}`

let 声明的变量只在其声明的块或子块中可用

不会注册在 widnow 上

不能重复定义

存在暂时性死区 （temporal dead zone）,在这区间使用变量会报错 ReferenceError y is not defined,暂时性死区区间为，声明之前中不能使用变量

`let 声明的变量会不会提升`,目前有两种说法:

1. 会
   提升了，但是提升在暂时性死区里面，所以不能在之间进行赋值操作
2. 不会
   因为没有提升，所以不能在之间进行赋值操作

个人观点认为 1 是正确的。ecma 官方文档有提到 let hoisting

```javascript
console.log(x); // ReferenceError x is not defined
let x = 1;
if (true) {
  console.log(x); //  输出 1
  let y = 2; // y只会作用在当前的{},块级作用域里面
}
let x = 2; //  SyntaxError: Identifier 'x' has already been declared
console.log(y); // ReferenceError y is not defined;
console.log(window.x); // 输出 undefined,
```

## 函数声明提升

JavaScript 中的函数声明被提升到了函数定义。你可以在函数声明之前使用该函数:
函数表达式不会被提升，相当于变量的提升

函数可以被有条件来声明，这意味着，在一个 if 语句里，函数声明是可以嵌套的。有的浏览器会将这种有条件的声明看成是无条件的声明，无论这里的条件是 true 还是 false，浏览器都会创建函数。因此，它们不应该被使用。

```javascript
var hoisted = "foo" in this;
console.log(
  `'foo' name ${hoisted ? "is" : "is not"} hoisted. typeof foo is ${typeof foo}`
);
// 注意，即使把代码中的 if(false) 改为 if(true)，结果也是一样的
if (false) {
  function foo() {
    return 1;
  }
}

// 在Chrome里:
// 'foo' 变量名被提升，但是 typeof foo 为 undefined
//
// 在Firefox里:
// 'foo' 变量名被提升. 但是 typeof foo 为 undefined
//
// 在Edge里:
// 'foo' 变量名未被提升. 而且 typeof foo 为 undefined
//
// 在Safari里:
// 'foo' 变量名被提升. 而且 typeof foo 为 function
```

## 相关阅读

[https://juejin.cn/post/6844903951351939080#heading-1](https://juejin.cn/post/6844903951351939080#heading-1)
[TemporalDeadZone](https://stackoverflow.com/questions/33198849/what-is-the-temporal-dead-zone)
[变量提升](https://medium.com/javascript-in-plain-english/how-hoisting-works-with-let-and-const-in-javascript-725616df7085)
[mdn 函数声明的提升](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/function)
[let-const](https://www.ecma-international.org/ecma-262/6.0/#sec-let-and-const-declarations)
