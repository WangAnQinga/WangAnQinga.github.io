---
title: 执行上下文和执行栈
categories:
tags:
---

JavaScript 运行三部曲

- 语法分析
- 预编译
- 解释执行

EC : 执行上下文

ECS : 执行环境栈

VO ： 变量对象

AO ： 活动对象

scope chain ：作用域链

`var a` `let a` `const a` 变量声明
var 存在变量的提升， let const 不会

## 什么是执行上下文？

简而言之，执行上下文是评估和执行 JavaScript 代码的环境的抽象概念。每当 Javascript 代码在运行的时候，它都是在执行上下文中运行。

创建执行上下文时与之关联的会有一个变量对象，该上下文中的所有变量和函数全都保存在这个对象中。

## 执行上下文的类型

JavaScript 中有三种执行上下文类型。

1. **全局执行上下文** — 这是默认或者说基础的上下文，任何不在函数内部的代码都在全局上下文中。它会执行两件事：创建一个全局的 window 对象（浏览器的情况下），并且设置 this 的值等于这个全局对象。一个程序中只会有一个全局执行上下文。

2. **函数执行上下文**— 每当一个函数被调用时, 都会为该函数创建一个新的上下文。每个函数都有它自己的执行上下文，不过是在函数被调用时创建的。函数上下文可以有任意多个。每当一个新的执行上下文被创建，它会按定义的顺序（将在后文讨论）执行一系列步骤。

3. **Eval 函数执行上下文** — 执行在 eval 函数内部的代码也会有它属于自己的执行上下文，但由于 JavaScript 开发者并不经常使用 eval，所以在这里我不会讨论它。

执行上下文也可以抽象理解为一个对象，这个对象都有三个属性：
变量对象(variable object)、作用域链(scope chain)、this 指针(this value)。

不同执行上下文变量对象略有不同：
全局上下文中的变量对象就是全局对象，允许通过变量对象的属性名来间接访问。
函数上下文中用活动对象来表示变量对象，通过函数的 arguments 属性初始化。

执行上下文生命周期分为两个阶段：创建阶段和代码执行阶段：
创建阶段：创建变量对象，建立作用域链，确定 this 指向
代码执行阶段：变量赋值，函数引用，执行其他代码

## 执行栈

执行栈，也就是在其它编程语言中所说的“调用栈”，是一种拥有 LIFO（后进先出）数据结构的栈，被用来存储代码运行时创建的所有执行上下文。

当 JavaScript 引擎第一次遇到你的脚本时，它会创建一个全局的执行上下文并且压入当前执行栈。每当引擎遇到一个函数调用，它会为该函数创建一个新的执行上下文并压入栈的顶部。

引擎会执行那些执行上下文位于栈顶的函数。当该函数执行结束时，执行上下文从栈中弹出，控制流程到达当前栈中的下一个上下文。

## 事件轮询

事件轮询的工作是监听调用堆栈，并确定调用堆栈是否为空。如果调用堆栈是空的，它将检查消息队列，看看是否有任何挂起的回调等待执行。

**请记住 setTimeout 不是 JS 引擎的一部分，它是 Web Api 的一部分。 setTimeout、setInterval、Fetch、DOM Events**

**事件轮询、web api 和消息队列不是 JavaScript 引擎的一部分，而是浏览器的 JavaScript 运行时环境或 Nodejs JavaScript 运行时环境的一部分(对于 Nodejs)。在 Nodejs 中，web api 被 c/c++ api 所替代。**

1. JS 引擎线程会维护一个执行栈，同步代码会依次加入到执行栈中依次执行并出栈。
2. JS 引擎线程遇到异步函数，会将异步函数交给相应的 Webapi，而继续执行后面的任务。
3. Webapi 会在条件满足的时候，将`异步对应的回调`加入到消息队列中，等待执行。
4. 执行栈为空时，JS 引擎线程会去取消息队列中的回调函数（如果有的话），并加入到执行栈中执行。
5. 完成后出栈，执行栈再次为空，重复上面的操作，这就是事件循环(event loop)机制。

![](/images/eventLoop.webp)

## 任务队列 === 消息队列

也称为消息队列，是一个先进先出的队列，它里面存放着各种消息，即**异步操作的回调函数**，**异步操作会将相关回调添加到任务队列中**，而不同的异步操作添加到任务队列的时机也不同，如 onclick，setTimeout，ajax 处理的方式都不同，这些异步操作都是由浏览器内核的不同模块来执行的：

onclick 由浏览器内核的 DOM Binding 模块来处理，当事件触发的时候，回调函数会立即添加到任务队列中；
setTimeout 会由浏览器内核的 timer 模块来进行延时处理，当时间到达的时候，才会将回调函数添加到任务队列中；
ajax 会由浏览器内核的 network 模块来处理，在网络请求完成返回之后，才将回调添加到任务队列中;

## 异步执行的运行机制

1. 所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。
2. 主线程之外，还存在一个"任务队列"（task queue）。只要异步任务有了运行结果，就在"任务队列"之中放置一个事件。
3. 一旦"执行栈"中的所有同步任务执行完毕，系统就会读取"任务队列"，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。
4. 主线程不断重复上面的第三步。

## 宏任务与微任务

2 macro-task(宏任务)、micro-task(微任务)

除了广义的同步任务和异步任务，其实对异步任务还有更细致的划分

```
macro-task(宏任务)：setTimeout，setInterval
micro-task(微任务)：Promise，process.nextTick
```

macro-task(宏任务)和 microtask（微任务）属于对异步任务的分类，不同的 API 注册的异步任务会依次进入自身对应的队列中，然后等待 Event Loop 将它们依次压入执行栈中执行。

js 事件循环机制，决定了代码执行顺序。
第一步：js 解释器识别所有 js 代码，将同步的代码放到主线程执行；异步的代码放到 Event Table 执行。这也是第一次宏任务执行完毕！
第二步：接下来执行所有的微任务

Js 中，有两类任务队列：宏任务队列（macro tasks）和微任务队列（micro tasks）。宏任务队列可以有多个，微任务队列只有一个。那么什么任务，会分到哪个队列呢？

宏任务：script（全局任务）, setTimeout, setInterval, setImmediate, I/O, UI rendering.
微任务：process.nextTick, Promise, Object.observer, MutationObserver.

优先级：主代码块 > setImmediate > MessageChannel > setTimeout / setInterval

比如：setImmediate 指定的回调函数，总是排在 setTimeout 前面

优先级：process.nextTick > Promise > MutationObserver

异步任务之间并不是完全等同的，它们存在一个执行优先级。按照执行优先级，可区分为两类任务：微任务和宏任务，即：

微任务：promise、Object.observe、MutationObserver
宏任务：script、setTimeout、setInterval、I/O、UI rendering
在一次事件循环中，异步事件返回的结果会被放入到一个任务队列中，但是根据异步事件的类型，需要把事件放入到对应的微任务队列或宏任务队列中。
当主线程空闲时（执行栈为空），主线程会先查看微任务队列，执行清空后再查看宏任务队列，并执行清空，如此反复循环
总结而言，浏览器中事件循环就一句话：当前执行栈执行完成时，立即优先处理微任务，再去处理宏任务，同一次事件循环中，微任务先于宏任务执行，

[https://github.com/gauseen/blog/issues/6](https://github.com/gauseen/blog/issues/6)

[https://www.cnblogs.com/jiangyuzhen/p/11064408.html](https://www.cnblogs.com/jiangyuzhen/p/11064408.html)
[https://www.ruphi.cn/archives/350/](https://www.ruphi.cn/archives/350/)

## 异步一般是指：

网络请求
计时器
DOM 事件监听

## setTimeout

**setTimeout(fn,0)的含义是，指定某个任务在主线程最早可得的空闲时间执行，也就是说，尽可能早得执行。它在"任务队列"的尾部添加一个事件，因此要等到同步任务和"任务队列"现有的事件都处理完，才会得到执行。**

HTML5 标准规定了 setTimeout()的第二个参数的最小值（最短间隔），不得低于 4 毫秒，如果低于这个值，就会自动增加。在此之前，老版本的浏览器都将最短间隔设为 10 毫秒。另外，对于那些 DOM 的变动（尤其是涉及页面重新渲染的部分），通常不会立即执行，而是每 16 毫秒执行一次。这时使用 requestAnimationFrame()的效果要好于 setTimeout()。

需要注意的是，setTimeout()只是将事件插入了"任务队列"，必须等到当前代码（执行栈）执行完，主线程才会去执行它指定的回调函数。要是当前代码耗时很长，有可能要等很久，所以并没有办法保证，回调函数一定会在 setTimeout()指定的时间执行。

## await 做了什么

从字面意思上看 await 就是等待，await 等待的是一个表达式，这个表达式的返回值可以是一个 promise 对象也可以是其他值。

很多人以为 await 会一直等待之后的表达式执行完之后才会继续执行后面的代码，实际上 await 是一个让出线程的标志。await 后面的表达式会先执行一遍，将 await 后面的代码加入到 microtask 中，然后就会跳出整个 async 函数来执行后面的代码。

```
async function async1() {
	console.log('async1 start');
	await async2();
	console.log('async1 end');
}
```

```
async function async1() {
	console.log('async1 start');
	Promise.resolve(async2()).then(() => {
                console.log('async1 end');
        })
}
```

[https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/7](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/7)

## 相关阅读：

[执行上下文](https://juejin.im/post/5ba32171f265da0ab719a6d7)
[执行上下文](https://juejin.im/post/5a9e5b9ef265da239235dc9f)
[执行上下文](https://github.com/mqyqingfeng/Blog/issues/8)
[事件轮训](https://segmentfault.com/a/1190000020400736)
[http://www.ruanyifeng.com/blog/2014/10/event-loop.html](http://www.ruanyifeng.com/blog/2014/10/event-loop.html)
[event loop](https://www.jianshu.com/p/de7aba994523)
[预编译](https://segmentfault.com/a/1190000018001871)
