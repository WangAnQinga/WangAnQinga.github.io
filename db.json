{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/images/execution","path":"images/execution","modified":0,"renderable":0},{"_id":"source/images/execution.webp","path":"images/execution.webp","modified":0,"renderable":0},{"_id":"source/images/eventLoop.webp","path":"images/eventLoop.webp","modified":0,"renderable":0},{"_id":"source/images/HashTable.png","path":"images/HashTable.png","modified":0,"renderable":0},{"_id":"source/images/browser.png","path":"images/browser.png","modified":0,"renderable":0},{"_id":"source/images/gecko.jpg","path":"images/gecko.jpg","modified":0,"renderable":0},{"_id":"source/images/linkedList1.webp","path":"images/linkedList1.webp","modified":0,"renderable":0},{"_id":"source/images/linkedList.png","path":"images/linkedList.png","modified":0,"renderable":0},{"_id":"source/images/set.png","path":"images/set.png","modified":0,"renderable":0},{"_id":"source/images/render-flow.png","path":"images/render-flow.png","modified":0,"renderable":0},{"_id":"source/images/webkitflow.png","path":"images/webkitflow.png","modified":0,"renderable":0},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/cursor.js","path":"js/src/cursor.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/wobblewindow.js","path":"js/src/wobblewindow.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","path":"lib/canvas-ribbon/canvas-ribbon.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","path":"lib/needsharebutton/needsharebutton.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","path":"lib/pace/pace-theme-big-counter.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","path":"lib/pace/pace-theme-bounce.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","path":"lib/needsharebutton/needsharebutton.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","path":"lib/pace/pace-theme-barber-shop.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","path":"lib/needsharebutton/font-embedded.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","path":"lib/pace/pace-theme-center-circle.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","path":"lib/pace/pace-theme-center-simple.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","path":"lib/pace/pace-theme-center-atom.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","path":"lib/pace/pace-theme-center-radar.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","path":"lib/pace/pace-theme-corner-indicator.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","path":"lib/pace/pace-theme-fill-left.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","path":"lib/pace/pace-theme-flash.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","path":"lib/pace/pace-theme-mac-osx.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","path":"lib/pace/pace-theme-loading-bar.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","path":"lib/pace/pace-theme-minimal.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace.min.js","path":"lib/pace/pace.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","path":"lib/three/canvas_lines.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","path":"lib/three/canvas_sphere.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/three-waves.min.js","path":"lib/three/three-waves.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.css","path":"lib/Han/dist/han.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.css","path":"lib/Han/dist/han.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.js","path":"lib/Han/dist/han.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.js","path":"lib/Han/dist/han.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","path":"lib/Han/dist/font/han-space.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","path":"lib/Han/dist/font/han-space.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","path":"lib/Han/dist/font/han.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","path":"lib/Han/dist/font/han.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","path":"lib/Han/dist/font/han.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/three.min.js","path":"lib/three/three.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"source/images/webpack-bundle-analyzer.gif","path":"images/webpack-bundle-analyzer.gif","modified":0,"renderable":0},{"_id":"source/images/WeGameMiniLoader.std.2.03.03.2031.exe","path":"images/WeGameMiniLoader.std.2.03.03.2031.exe","modified":0,"renderable":0}],"Cache":[{"_id":"themes/next/.gitattributes","hash":"44bd4729c74ccb88110804f41746fec07bf487d4","modified":1565689145345},{"_id":"themes/next/.gitignore","hash":"0b5c2ffd41f66eb1849d6426ba8cf9649eeed329","modified":1565689145348},{"_id":"themes/next/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1565689145345},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1565689145345},{"_id":"themes/next/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1565689145348},{"_id":"themes/next/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1565689145348},{"_id":"themes/next/.javascript_ignore","hash":"8a224b381155f10e6eb132a4d815c5b52962a9d1","modified":1565689145348},{"_id":"themes/next/.stylintrc","hash":"b28e24704a5d8de08346c45286574c8e76cc109f","modified":1565689145348},{"_id":"themes/next/.travis.yml","hash":"d60d4a5375fea23d53b2156b764a99b2e56fa660","modified":1565689145348},{"_id":"themes/next/LICENSE","hash":"f293bcfcdc06c0b77ba13570bb8af55eb5c059fd","modified":1565689145348},{"_id":"themes/next/README.cn.md","hash":"263b74f1ac7c0f6f9424b8cced4b0b320ae61efc","modified":1565689145349},{"_id":"themes/next/README.md","hash":"287c7e6b7a6ddf75d815dda0df8bd228e3f285c5","modified":1565689145349},{"_id":"themes/next/gulpfile.coffee","hash":"031bffc483e417b20e90eceb6cf358e7596d2e69","modified":1565689145350},{"_id":"themes/next/bower.json","hash":"0674f11d3d514e087a176da0e1d85c2286aa5fba","modified":1565689145350},{"_id":"themes/next/_config.yml","hash":"2a067a0672b182020b7380199749c1cf13acef6a","modified":1591323653361},{"_id":"themes/next/package.json","hash":"036d3a1346203d2f1a3958024df7f74e7ac07bfe","modified":1565689145372},{"_id":"source/images/execution","hash":"f95e44c891b60d0f9a62440d319ac8b107468fa5","modified":1590129030023},{"_id":"source/images/execution.webp","hash":"f95e44c891b60d0f9a62440d319ac8b107468fa5","modified":1590129030024},{"_id":"source/images/eventLoop.webp","hash":"f5cd1bdef1c9e992a8a65ce1ab1fca5d26aa8e14","modified":1571018652093},{"_id":"source/images/HashTable.png","hash":"41acc916a03ef8765e915a4041ea8e2ea937598c","modified":1570694402150},{"_id":"source/images/browser.png","hash":"98513917c0ad015b380cd4595052a31e7b9604e4","modified":1573288335545},{"_id":"source/images/gecko.jpg","hash":"9ed33d023bfe296845ee70b1f5595aa7d37b19bb","modified":1573290350901},{"_id":"source/images/linkedList1.webp","hash":"207a8fb2dc518dccb04f4dcde8343f0efb91a9f7","modified":1570693602098},{"_id":"source/images/linkedList.png","hash":"207a8fb2dc518dccb04f4dcde8343f0efb91a9f7","modified":1570693633552},{"_id":"source/images/set.png","hash":"8157da6f85394c367442fa91b8e71de778f88dae","modified":1570693994254},{"_id":"source/images/render-flow.png","hash":"675c0ef1c3cd0de8e7dced027cd751b5013520dc","modified":1573288335597},{"_id":"source/images/webkitflow.png","hash":"2a140492f6dbdea1016a4d26e490fea961882687","modified":1573290350923},{"_id":"source/tags/index.md","hash":"ffb729dcab82378cadb6e827951ce7b4ed082906","modified":1590043327882},{"_id":"source/_drafts/ES6.md","hash":"1fdbdd77c021add6bf785fe5883d8963102d67f8","modified":1571798020294},{"_id":"source/_drafts/Promise.md","hash":"32e6e7139656b95b6da7856e3d452a28028b0468","modified":1590129030009},{"_id":"source/_drafts/Loader.md","hash":"84981e8be1129f65ca1ddef1f239484279201d07","modified":1572230219551},{"_id":"source/_drafts/Babel.md","hash":"3386870ec558744efe45795edb2d9c9308c1bab0","modified":1583206481294},{"_id":"source/_drafts/Math 对象.md","hash":"2e5ef60434852c0bdc62529dab4892a4716a9578","modified":1583222680970},{"_id":"source/_drafts/Rem.md","hash":"c781126ea4e035aebaf4223e38c690728f2cec14","modified":1579072149701},{"_id":"source/_drafts/Redux.md","hash":"f6b222e7e6db5c5453929fffabd98a6420121b7f","modified":1573625986378},{"_id":"source/_drafts/React.md","hash":"77b8048aafcb3a73a39c6b7e4cadee9655df39bb","modified":1578451051642},{"_id":"source/_drafts/Service-workers.md","hash":"cd910714beea08fd5aa489a44c1aa4147b8613ab","modified":1571797955971},{"_id":"source/_drafts/Yarn.md","hash":"837d41c455cc06ded8dcd521c1344d37653fc541","modified":1579590656255},{"_id":"source/_drafts/Vue-组件库.md","hash":"71bc59f62efe1bbf399ebb3190d878428618cd7d","modified":1578992092805},{"_id":"source/_drafts/async-await、Promise、setTimeout执行顺序.md","hash":"a542f53ddc5381dbfbb4bd36dc1e43d1d544df17","modified":1571044185892},{"_id":"source/_drafts/V8-引擎.md","hash":"49a1d87b10f28ba3da1b6890b967d0ade07197e7","modified":1590465566682},{"_id":"source/_drafts/eslint.md","hash":"b8691d95b27843b9dbae1f52a0c2042dc80543b9","modified":1590051827018},{"_id":"source/_drafts/git-commit-规范.md","hash":"af5af1770bcc975f4bd32dafbf47b7c38176cec6","modified":1590045093569},{"_id":"source/_drafts/docker.md","hash":"77ba33c905cd9a4a9396cdb4a97f45da3750a065","modified":1576812593276},{"_id":"source/_drafts/http-协议.md","hash":"cafb0da84100581c347ad1511f85e8245deac20c","modified":1590042560533},{"_id":"source/_drafts/javascript基础.md","hash":"8169bc562166ffaa3e396d9bff9d568e0cfe1d41","modified":1570805220727},{"_id":"source/_drafts/mvc和mvvm.md","hash":"85beae48ebc11fc18aae4a6e166468ff93ed38c7","modified":1571385491784},{"_id":"source/_drafts/taro.md","hash":"c10e652add1f5eff4fb6aaf8c8d9555ff70ce0a3","modified":1586760555050},{"_id":"source/_drafts/npm-typescript.md","hash":"bbf315027b80684c360623d3f54997afb7a00c2b","modified":1573721142915},{"_id":"source/_drafts/vuex.md","hash":"94eab98600709fa534511455ea17842cd9b94de3","modified":1570178023253},{"_id":"source/_drafts/vue3ts.md","hash":"49a5edadf45ccedaaa1b9e813c7680ea9f7d5a51","modified":1570085290984},{"_id":"source/_drafts/vue-打包优化.md","hash":"7df8d9e319dd9974e4cefdb67a51c31eccd772ac","modified":1571209860301},{"_id":"source/_drafts/vue知识点.md","hash":"a1b319411428669607929afd84675e0fc2cab8e1","modified":1571032534682},{"_id":"source/_drafts/Event-Loop.md","hash":"23f874c5a0442d5ef2d00298ac2df85350e6d6e0","modified":1591321312548},{"_id":"source/_drafts/前端debug.md","hash":"7469e9ee01996810198ea050b014f8e4daf5d81c","modified":1590044894709},{"_id":"source/_drafts/内存相关知识.md","hash":"40e2c380f45b4a3f9c7e17d05368dd1d4a033c4e","modified":1571482081943},{"_id":"source/_drafts/函数.md","hash":"2b4d11ef80a795df858daccfa129d3d4be86deb2","modified":1571817957876},{"_id":"source/_drafts/多变的this.md","hash":"da6c57eae97f11a7feb7c4abc6a4b74a3b6e48bb","modified":1589249511017},{"_id":"source/_drafts/前端安全.md","hash":"8e07d40b912febd8612b178ac86351b335649274","modified":1590044941674},{"_id":"source/_drafts/实用的函数.md","hash":"cd073d180808b302685f6546ca911585e36fea51","modified":1583217649922},{"_id":"source/_drafts/原型链.md","hash":"6fc647e61772f5f3b62d9316416d40dcfacfb995","modified":1590044964037},{"_id":"source/_drafts/富文本编辑器.md","hash":"a5b1f165c00727a957ff0c4e9d5c036eeff6c257","modified":1586225009905},{"_id":"source/_drafts/循环.md","hash":"98a2a853c38d35852b96eeb01f988a62052b40df","modified":1591341966606},{"_id":"source/_drafts/浏览器渲染过程.md","hash":"13a92798626525030edeb024f87b68e38420da34","modified":1591342499903},{"_id":"source/_drafts/对象.md","hash":"3f8e790a5fee4676e61abe0591c6c055cda86784","modified":1588563099224},{"_id":"source/_drafts/数组.md","hash":"ad39612f937e903c1caa5fac106db5fb823c090a","modified":1590045022760},{"_id":"source/_drafts/数据结构.md","hash":"6a133f117504504db6804852e202331538ac2eb1","modified":1590045016376},{"_id":"source/_drafts/移动端适配.md","hash":"5efaa4943034a4fbce1ed8605c6cfdefdfe978a0","modified":1570605257736},{"_id":"source/_drafts/移动端开发技巧.md","hash":"85be8b59975142a36b77f7fc3c6f78b621f86562","modified":1571022440081},{"_id":"source/_drafts/设计模式.md","hash":"82bbb71a78f807e777e3780e9d7d49a0d64bb1f3","modified":1590129030014},{"_id":"source/_drafts/缓存.md","hash":"32865ef302499de527edc0e1ff341d3dfc4316d3","modified":1571022669011},{"_id":"source/_drafts/闭包.md","hash":"f0636dff36b51539f271ce51f6fa89cc8dc9da49","modified":1590051781431},{"_id":"source/categories/index.md","hash":"744b508ca03b670c78a5605fae6099df3b9fb12c","modified":1590043320088},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"3b5eafd32abb718e56ccf8d1cee0607ad8ce611d","modified":1565689145346},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"50d48c47162817a3810a9d9ad51104e83947419a","modified":1565689145347},{"_id":"source/_drafts/算法.md","hash":"754df1d9ba134e6af14e75b6d8f92e88c969a898","modified":1583216892383},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"902f627155a65099e0a37842ff396a58d0dc306f","modified":1565689145347},{"_id":"themes/next/.github/browserstack_logo.png","hash":"a6c43887f64a7f48a2814e3714eaa1215e542037","modified":1565689145347},{"_id":"source/_drafts/防抖节流.md","hash":"40bddb9c83c68cacf1781149f94018f5d41c6904","modified":1573285232507},{"_id":"themes/next/languages/en.yml","hash":"7e680d9bb8f3a3a9d1ba1c9d312b3d257183dded","modified":1565689145350},{"_id":"themes/next/languages/fr-FR.yml","hash":"7e4eb7011b8feee641cfb11c6e73180b0ded1c0f","modified":1565689145350},{"_id":"themes/next/languages/it.yml","hash":"aa595f2bda029f73ef7bfa104b4c55c3f4e9fb4c","modified":1565689145351},{"_id":"themes/next/languages/ja.yml","hash":"3c76e16fd19b262864475faa6854b718bc08c4d8","modified":1565689145351},{"_id":"themes/next/languages/ko.yml","hash":"ea5b46056e73ebcee121d5551627af35cbffc900","modified":1565689145351},{"_id":"themes/next/languages/nl-NL.yml","hash":"edca4f3598857dbc3cbf19ed412213329b6edd47","modified":1565689145351},{"_id":"themes/next/languages/pt-BR.yml","hash":"b1694ae766ed90277bcc4daca4b1cfa19cdcb72b","modified":1565689145351},{"_id":"themes/next/languages/pt.yml","hash":"44b61f2d085b827b507909a0b8f8ce31c6ef5d04","modified":1565689145351},{"_id":"themes/next/languages/id.yml","hash":"d2d94bf022f666ccd42abab2383975bd5762e63e","modified":1591326654582},{"_id":"themes/next/languages/default.yml","hash":"925714fb88d9751e5ee7464c00fc35a816b5522a","modified":1591326643565},{"_id":"themes/next/languages/de.yml","hash":"fbd1ad35c9909802e74cd52da6be1df57ffe532a","modified":1591326635333},{"_id":"themes/next/languages/ru.yml","hash":"98ec6f0b7183282e11cffc7ff586ceb82400dd75","modified":1565689145352},{"_id":"themes/next/languages/zh-hk.yml","hash":"9396f41ae76e4fef99b257c93c7354e661f6e0fa","modified":1565689145352},{"_id":"themes/next/languages/vi.yml","hash":"fd08d3c8d2c62965a98ac420fdaf95e54c25d97c","modified":1565689145352},{"_id":"themes/next/languages/zh-tw.yml","hash":"50b71abb3ecc0686f9739e179e2f829cd074ecd9","modified":1565689145352},{"_id":"themes/next/languages/zh-Hans.yml","hash":"45fc1ba2eb0419149b21f4cd04ecb202b00b0860","modified":1591326661738},{"_id":"themes/next/layout/_layout.swig","hash":"f2f7b1fa74169e2be0d2b0329adc8b258ad3d42e","modified":1566465162668},{"_id":"themes/next/layout/archive.swig","hash":"f0a8225feafd971419837cdb4bcfec98a4a59b2f","modified":1565689145366},{"_id":"themes/next/layout/category.swig","hash":"4472255f4a3e3dd6d79201523a9526dcabdfbf18","modified":1565689145367},{"_id":"themes/next/layout/index.swig","hash":"783611349c941848a0e26ee2f1dc44dd14879bd1","modified":1565689145367},{"_id":"themes/next/layout/page.swig","hash":"969caaee05bdea725e99016eb63d810893a73e99","modified":1565689145367},{"_id":"themes/next/layout/post.swig","hash":"b3589a8e46288a10d20e41c7a5985d2493725aec","modified":1565689145367},{"_id":"themes/next/layout/schedule.swig","hash":"d86f8de4e118f8c4d778b285c140474084a271db","modified":1565689145367},{"_id":"themes/next/layout/tag.swig","hash":"7e0a7d7d832883eddb1297483ad22c184e4368de","modified":1565689145367},{"_id":"themes/next/scripts/merge-configs.js","hash":"81e86717ecfb775986b945d17f0a4ba27532ef07","modified":1565689145373},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1565689145450},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1565689145450},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1565689145450},{"_id":"themes/next/layout/_custom/header.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1566466024671},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1565689145393},{"_id":"themes/next/scripts/merge.js","hash":"9130dabe6a674c54b535f322b17d75fe6081472f","modified":1565689145373},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"31322a7f57936cf2dc62e824af5490da5354cf02","modified":1565689145354},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1565689145353},{"_id":"themes/next/layout/_macro/post-copyright.swig","hash":"665a928604f99d2ba7dc4a4a9150178229568cc6","modified":1565689145354},{"_id":"themes/next/layout/_macro/reward.swig","hash":"56e8d8556cf474c56ae1bef9cb7bbd26554adb07","modified":1565689145354},{"_id":"themes/next/layout/_macro/post.swig","hash":"3dfbc6bf7f8e9bf12f059941cf37913dbe66e8ea","modified":1590043113893},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"39852700e4084ecccffa6d4669168e5cc0514c9e","modified":1565689145355},{"_id":"themes/next/layout/_partials/comments.swig","hash":"4a6f5b1792b2e5262b7fdab9a716b3108e2f09c7","modified":1565689145355},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"6a54c3c85ff6b19d275827a327abbf4bd99b2ebf","modified":1565689145355},{"_id":"themes/next/layout/_partials/header.swig","hash":"ed042be6252848058c90109236ec988e392d91d4","modified":1565689145357},{"_id":"themes/next/layout/_partials/head.swig","hash":"6b94fe8f3279daea5623c49ef4bb35917ba57510","modified":1565689145356},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"1efd925d34a5d4ba2dc0838d9c86ba911e705fc9","modified":1565689145357},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1565689145357},{"_id":"themes/next/layout/_custom/custom.swig","hash":"7bcd25ba21f38e45d7b56745a3a5f85a98a92b98","modified":1566489225662},{"_id":"themes/next/layout/_partials/footer.swig","hash":"2c6892c4ceb497d5a20cdfe21acd4eca04ce2477","modified":1591323686829},{"_id":"themes/next/layout/_partials/search.swig","hash":"9dbd378e94abfcb3f864a5b8dbbf18d212ca2ee0","modified":1565689145357},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1565689145359},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1565689145359},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"a266f96ad06ee87bdeae6e105a4b53cd587bbd04","modified":1565689145360},{"_id":"themes/next/layout/_third-party/needsharebutton.swig","hash":"5fe0447cc88a5a63b530cf0426f93c4634811876","modified":1565689145365},{"_id":"themes/next/layout/_third-party/exturl.swig","hash":"7c04a42319d728be356746363aff8ea247791d24","modified":1565689145364},{"_id":"themes/next/layout/_third-party/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1565689145364},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"fc93b1a7e6aed0dddb1f3910142b48d8ab61174e","modified":1565689145365},{"_id":"themes/next/layout/_third-party/scroll-cookie.swig","hash":"1ddb2336a1a19b47af3017047012c01ec5f54529","modified":1565689145365},{"_id":"themes/next/layout/_third-party/mathjax.swig","hash":"6d25596d6a7c57700d37b607f8d9a62d89708683","modified":1565689145365},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1565689145365},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1565689145374},{"_id":"themes/next/scripts/tags/button.js","hash":"d023f10a00077f47082b0517e2ad666e6e994f60","modified":1565689145374},{"_id":"themes/next/scripts/tags/exturl.js","hash":"8d7e60f60779bde050d20fd76f6fdc36fc85e06d","modified":1565689145374},{"_id":"themes/next/scripts/tags/full-image.js","hash":"8eeb3fb89540299bdbb799edfdfdac3743b50596","modified":1565689145374},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1565689145374},{"_id":"themes/next/scripts/tags/label.js","hash":"2f8f41a7316372f0d1ed6b51190dc4acd3e16fff","modified":1565689145374},{"_id":"themes/next/scripts/tags/lazy-image.js","hash":"eeeabede68cf263de9e6593ecf682f620da16f0a","modified":1565689145375},{"_id":"themes/next/scripts/tags/note.js","hash":"64de4e9d01cf3b491ffc7d53afdf148ee5ad9779","modified":1565689145375},{"_id":"themes/next/scripts/tags/tabs.js","hash":"5786545d51c38e8ca38d1bfc7dd9e946fc70a316","modified":1565689145375},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1565689145393},{"_id":"themes/next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1565689145393},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1565689145394},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1565689145394},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1565689145394},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1565689145394},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1565689145394},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1565689145395},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1565689145395},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1565689145395},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1565689145395},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1565689145395},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1565689145396},{"_id":"themes/next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1565689145396},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1565689145396},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1565689145396},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1565689145396},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1565689145396},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1565689145396},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1565689145360},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1565689145360},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1565689145388},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1565689145388},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1565689145388},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1565689145392},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1565689145393},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1565689145356},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1565689145357},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1565689145358},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"957701729b85fb0c5bfcf2fb99c19d54582f91ed","modified":1565689145357},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1565689145358},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1565689145358},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"048fd5e98149469f8c28c21ba3561a7a67952c9b","modified":1565689145358},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1565689145358},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1565689145358},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1565689145359},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1565689145359},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1565689145361},{"_id":"themes/next/layout/_third-party/analytics/analytics-with-widget.swig","hash":"98df9d72e37dd071e882f2d5623c9d817815b139","modified":1565689145361},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1565689145360},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"18e7bef8923d83ea42df6c97405e515a876cede4","modified":1565689145362},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1565689145362},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"deda6a814ed48debc694c4e0c466f06c127163d0","modified":1565689145362},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"a234c5cd1f75ca5731e814d0dbb92fdcf9240d1b","modified":1565689145362},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"5e9bb24c750b49513d9a65799e832f07410002ac","modified":1565689145362},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"fc65b9c98a0a8ab43a5e7aabff6c5f03838e09c8","modified":1565689145363},{"_id":"themes/next/layout/_third-party/analytics/firestore.swig","hash":"1cd01c6e92ab1913d48e556a92bb4f28b6dc4996","modified":1565689145362},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"5d9943d74cc2e0a91badcf4f755c6de77eab193a","modified":1565689145362},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1565689145363},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"0ddc94ed4ba0c19627765fdf1abc4d8efbe53d5a","modified":1565689145363},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"c3971fd154d781088e1cc665035f8561a4098f4c","modified":1565689145363},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"0e3378f7c39b2b0f69638290873ede6b6b6825c0","modified":1565689145363},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"c316758546dc9ba6c60cb4d852c17ca6bb6d6724","modified":1565689145363},{"_id":"themes/next/layout/_third-party/comments/gitment.swig","hash":"10160daceaa6f1ecf632323d422ebe2caae49ddf","modified":1565689145364},{"_id":"themes/next/layout/_third-party/comments/duoshuo.swig","hash":"a356b2185d40914447fde817eb3d358ab6b3e4c3","modified":1565689145363},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"aa0629277d751c55c6d973e7691bf84af9b17a60","modified":1565689145364},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"8a2e393d2e49f7bf560766d8a07cd461bf3fce4f","modified":1565689145364},{"_id":"themes/next/layout/_third-party/comments/hypercomments.swig","hash":"3e8dc5c6c912628a37e3b5f886bec7b2e5ed14ea","modified":1565689145364},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"fcabbb241f894c9a6309c44e126cf3e8fea81fd4","modified":1565689145364},{"_id":"themes/next/layout/_third-party/comments/youyan.swig","hash":"8b6650f77fe0a824c8075b2659e0403e0c78a705","modified":1565689145364},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"c747fb5c6b1f500e8f0c583e44195878b66e4e29","modified":1565689145366},{"_id":"themes/next/layout/_third-party/search/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1565689145366},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"385c066af96bee30be2459dbec8aae1f15d382f5","modified":1565689145366},{"_id":"themes/next/layout/_third-party/seo/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1565689145366},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"a40270694e23ad02a2b0f6a191eb7e442bd10fbd","modified":1566466965760},{"_id":"themes/next/source/css/_mixins/Gemini.styl","hash":"2aa5b7166a85a8aa34b17792ae4f58a5a96df6cc","modified":1565689145388},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"9ab65361ba0a12a986edd103e56492644c2db0b8","modified":1565689145388},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"82f9055955920ed88a2ab6a20ab02169abb2c634","modified":1565689145388},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"be087dcc060e8179f7e7f60ab4feb65817bd3d9f","modified":1565689145392},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"f29165e36489a87ba32d17dddfd2720d84e3f3ec","modified":1565689145392},{"_id":"themes/next/source/css/_variables/base.styl","hash":"29c261fa6b4046322559074d75239c6b272fb8a3","modified":1565689145393},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"99fbb4686ea9a3e03a4726ed7cf4d8f529034452","modified":1565689145392},{"_id":"themes/next/source/js/src/cursor.js","hash":"e4e19ac3bf738598aee3fd47769d319fa218a297","modified":1566484885114},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1565689145397},{"_id":"themes/next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1565689145397},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"034bc8113e0966fe2096ba5b56061bbf10ef0512","modified":1565689145397},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1565689145397},{"_id":"themes/next/source/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1565689145397},{"_id":"themes/next/source/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1565689145398},{"_id":"themes/next/source/js/src/post-details.js","hash":"a13f45f7aa8291cf7244ec5ba93907d119c5dbdd","modified":1565689145398},{"_id":"themes/next/source/js/src/motion.js","hash":"4002561ae03903a015d51c9fe1f2bf65fcc4dda2","modified":1566467040762},{"_id":"themes/next/source/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1565689145399},{"_id":"themes/next/source/js/src/utils.js","hash":"9b1325801d27213083d1487a12b1a62b539ab6f8","modified":1565689145399},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1565689145399},{"_id":"themes/next/source/js/src/wobblewindow.js","hash":"709801602c2a84bd8eb4e552bf6abfbbd3819fe5","modified":1566465162355},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1565689145404},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","hash":"ff5915eb2596e890a2fc6697c864f861a1995ec0","modified":1565689145407},{"_id":"themes/next/source/lib/fancybox/.bower.json","hash":"cc40a9b11e52348e554c84e4a5c058056f6b7aeb","modified":1565689145408},{"_id":"themes/next/source/lib/fancybox/.gitattributes","hash":"2db21acfbd457452462f71cc4048a943ee61b8e0","modified":1565689145408},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1565689145407},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1565689145415},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1565689145416},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1565689145416},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1565689145418},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1565689145415},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1565689145418},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1565689145418},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"a2aaaf12378db56bd10596ba3daae30950eac051","modified":1565689145417},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1565689145419},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1565689145434},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1565689145436},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1565689145437},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1565689145436},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1565689145437},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1565689145437},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1565689145438},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","hash":"3ef0020a1815ca6151ea4886cd0d37421ae3695c","modified":1565689145439},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1565689145440},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1565689145440},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","hash":"9885fd9bea5e7ebafc5b1de9d17be5e106248d96","modified":1565689145439},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1565689145440},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","hash":"c39d37278c1e178838732af21bd26cd0baeddfe0","modified":1565689145439},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1565689145440},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1565689145441},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1565689145440},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1565689145441},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1565689145441},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1565689145441},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1565689145441},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1565689145442},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1565689145442},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1565689145442},{"_id":"themes/next/source/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1565689145442},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1565689145443},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1565689145443},{"_id":"themes/next/source/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1565689145443},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1565689145447},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1565689145447},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1565689145450},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1565689145449},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1565689145450},{"_id":"themes/next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1565689145435},{"_id":"source/_posts/2020/06/05/执行上下文.md","hash":"59bd259b172b217b92fce59583b5f59955c2f774","modified":1591342474102},{"_id":"source/_posts/2020/06/05/浏览器.md","hash":"26b32ceb3ba0b55d7588725b06d6177aea56b6d8","modified":1591342413795},{"_id":"source/_posts/2020/05/21/markdown.md","hash":"6384365de3ae616fd914822c3bcfaf73d7803b46","modified":1590042856305},{"_id":"source/_posts/2020/05/21/hls技术和m3u8格式视频播放.md","hash":"e4ed5f7ffbd0a7c638fd7734a78af12bb9271a8d","modified":1590051895296},{"_id":"themes/next/layout/_third-party/search/algolia-search/assets.swig","hash":"28ff4ed6714c59124569ffcbd10f1173d53ca923","modified":1565689145365},{"_id":"themes/next/layout/_third-party/search/algolia-search/dom.swig","hash":"ba698f49dd3a868c95b240d802f5b1b24ff287e4","modified":1565689145365},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"4719ce717962663c5c33ef97b1119a0b3a4ecdc3","modified":1565689145375},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"31050fc7a25784805b4843550151c93bfa55c9c8","modified":1565689145375},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1565689145386},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"7e509c7c28c59f905b847304dd3d14d94b6f3b8e","modified":1565689145375},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"a6bb5256be6195e76addbda12f4ed7c662d65e7a","modified":1565689145376},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1565689145376},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"c5d48863f332ff8ce7c88dec2c893f709d7331d3","modified":1565689145379},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"f7c44b0ee46cf2cf82a4c9455ba8d8b55299976f","modified":1565689145387},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"9c25c75311e1bd4d68df031d3f2ae6d141a90766","modified":1565689145387},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1565689145383},{"_id":"themes/next/source/css/_common/scaffolding/mobile.styl","hash":"47a46583a1f3731157a3f53f80ed1ed5e2753e8e","modified":1565689145387},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1565689145387},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"a280a583b7615e939aaddbf778f5c108ef8a2a6c","modified":1565689145387},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1565689145387},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"18c3336ee3d09bd2da6a876e1336539f03d5a973","modified":1565689145389},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1565689145389},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1565689145389},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1565689145389},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1565689145389},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"3b25edfa187d1bbbd0d38b50dd013cef54758abf","modified":1565689145390},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1565689145390},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1565689145390},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1565689145390},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1565689145390},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"4aac01962520d60b03b23022ab601ad4bd19c08c","modified":1565689145391},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1565689145391},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1565689145391},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"c4ed249798296f60bda02351fe6404fb3ef2126f","modified":1565689145391},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"5b93958239d3d2bf9aeaede44eced2434d784462","modified":1565689145391},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1565689145392},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"215de948be49bcf14f06d500cef9f7035e406a43","modified":1565689145391},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"9d16fa3c14ed76b71229f022b63a02fd0f580958","modified":1565689145392},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"69ecd6c97e7cdfd822ac8102b45ad0ede85050db","modified":1565689145392},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1565689145399},{"_id":"themes/next/source/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1565689145402},{"_id":"themes/next/source/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1565689145403},{"_id":"themes/next/source/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1565689145404},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1565689145408},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1565689145409},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1565689145408},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1565689145409},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1565689145409},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1565689145413},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1565689145410},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1565689145414},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1565689145413},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1565689145417},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1565689145417},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1565689145421},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1565689145420},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1565689145420},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1565689145447},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1565689145447},{"_id":"themes/next/source/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1565689145403},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1565689145434},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1565689145433},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1565689145449},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"7905a7f625702b45645d8be1268cb8af3f698c70","modified":1565689145376},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1565689145377},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"25dc25f61a232f03ca72472b7852f882448ec185","modified":1565689145377},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1565689145378},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1565689145376},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1565689145376},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"8a2421cb9005352905fae9d41a847ae56957247e","modified":1565689145376},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1565689145377},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1565689145377},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"f5aa2ba3bfffc15475e7e72a55b5c9d18609fdf5","modified":1565689145378},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1565689145378},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"2039590632bba3943c39319d80ef630af7928185","modified":1565689145378},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1565689145378},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"a82afbb72d83ee394aedc7b37ac0008a9823b4f4","modified":1565689145379},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"e72a89e0f421444453e149ba32c77a64bd8e44e8","modified":1565689145379},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"0f7f522cc6bfb3401d5afd62b0fcdf48bb2d604b","modified":1565689145379},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1565689145379},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"f54367c0feda6986c030cc4d15a0ca6ceea14bcb","modified":1565689145379},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"535b3b4f8cb1eec2558e094320e7dfb01f94c0e7","modified":1565689145380},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1565689145380},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"aea21141015ca8c409d8b33e3e34ec505f464e93","modified":1565689145380},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"a5d8617a24d7cb6c5ad91ea621183ca2c0917331","modified":1565689145380},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"36332c8a91f089f545f3c3e8ea90d08aa4d6e60c","modified":1565689145380},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"017074ef58166e2d69c53bb7590a0e7a8947a1ed","modified":1565689145380},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"d5a4e4fc17f1f7e7c3a61b52d8e2e9677e139de7","modified":1565689145381},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1565689145381},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1565689145381},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"e4055a0d2cd2b0ad9dc55928e2f3e7bd4e499da3","modified":1565689145381},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"920343e41c124221a17f050bbb989494d44f7a24","modified":1565689145382},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"0a6c0efffdf18bddbc1d1238feaed282b09cd0fe","modified":1565689145382},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"262debfd4442fa03d9919ceb88b948339df03fb0","modified":1565689145381},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"89dd4f8b1f1cce3ad46cf2256038472712387d02","modified":1565689145382},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"efa5e5022e205b52786ce495d4879f5e7b8f84b2","modified":1565689145382},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1565689145382},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1565689145382},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"12937cae17c96c74d5c58db6cb29de3b2dfa14a2","modified":1565689145382},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"f7784aba0c1cd20d824c918c120012d57a5eaa2a","modified":1565689145383},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"50305b6ad7d09d2ffa4854e39f41ec1f4fe984fd","modified":1565689145383},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1565689145383},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1565689145383},{"_id":"themes/next/source/css/_common/components/tags/exturl.styl","hash":"1b3cc9f4e5a7f6e05b4100e9990b37b20d4a2005","modified":1565689145384},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"37e951e734a252fe8a81f452b963df2ba90bfe90","modified":1565689145384},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1565689145384},{"_id":"themes/next/source/css/_common/components/tags/label.styl","hash":"4a457d265d62f287c63d48764ce45d9bcfc9ec5a","modified":1565689145384},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"32c9156bea5bac9e9ad0b4c08ffbca8b3d9aac4b","modified":1565689145384},{"_id":"themes/next/source/css/_common/components/tags/tabs.styl","hash":"4ab5deed8c3b0c338212380f678f8382672e1bcb","modified":1565689145384},{"_id":"themes/next/source/css/_common/components/tags/note-modern.styl","hash":"ee7528900578ef4753effe05b346381c40de5499","modified":1565689145384},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"ead0d0f2321dc71505788c7f689f92257cf14947","modified":1565689145385},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"fd42777b9125fd8969dc39d4f15473e2b91b4142","modified":1565689145385},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"d4e6d8d7b34dc69994593c208f875ae8f7e8a3ae","modified":1565689145385},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1565689145385},{"_id":"themes/next/source/css/_common/components/third-party/gitment.styl","hash":"34935b40237c074be5f5e8818c14ccfd802b7439","modified":1565689145385},{"_id":"themes/next/source/css/_common/components/third-party/han.styl","hash":"cce6772e2cdb4db85d35486ae4c6c59367fbdd40","modified":1565689145385},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1565689145385},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1565689145386},{"_id":"themes/next/source/css/_common/components/third-party/needsharebutton.styl","hash":"a5e3e6b4b4b814a9fe40b34d784fed67d6d977fa","modified":1565689145386},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"d89c4b562b528e4746696b2ad8935764d133bdae","modified":1565689145386},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"1ccfbd4d0f5754b2dc2719a91245c95f547a7652","modified":1565689145386},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1565689145390},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1565689145390},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1565689145391},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1565689145401},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1565689145400},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1565689145401},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1565689145402},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1565689145402},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1565689145411},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1565689145411},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1565689145411},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1565689145411},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1565689145412},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1565689145413},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1565689145423},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1565689145425},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1565689145431},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1565689145406},{"_id":"themes/next/source/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1565689145446},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1565689145430},{"_id":"source/images/webpack-bundle-analyzer.gif","hash":"24a3beb8c29c270557bf3dc9b53ee676497be043","modified":1568884169491},{"_id":"source/images/WeGameMiniLoader.std.2.03.03.2031.exe","hash":"492aed348104e8299656b83c508424391264cf0f","modified":1590129030022},{"_id":"public/tags/index.html","hash":"95ad0bc004bebb7c5d0089591e6bb2a0474ce1cd","modified":1591347345562},{"_id":"public/categories/index.html","hash":"24e46d379db383362d2dbb7e29165ef8b491e7bb","modified":1591347345562},{"_id":"public/categories/前端/index.html","hash":"d655ed39bf8cca7601ad45c5830e8c166d381419","modified":1591347345563},{"_id":"public/archives/index.html","hash":"06bae66c1e5e4e6ebf0b604470c070e87c6ba89c","modified":1591347345563},{"_id":"public/archives/2020/index.html","hash":"72e92460dbad627c19a5db0b4c2da98c096e3e8a","modified":1591347345563},{"_id":"public/archives/2020/05/index.html","hash":"5f019846c790e2e1c29bba5e2653953c4b2aa83d","modified":1591347345563},{"_id":"public/archives/2020/06/index.html","hash":"deafb964a4f3d839964aa884ff172533e8b7dd0c","modified":1591347345563},{"_id":"public/tags/浏览器/index.html","hash":"6e822b01fb5bebca26275764857aedd90e6d4c4c","modified":1591347345564},{"_id":"public/tags/Markdown/index.html","hash":"ac5dbbcb30116e856011bf61fa844d8bc0fcbb56","modified":1591347345564},{"_id":"public/tags/video/index.html","hash":"e3ed276433b304de485f60a1a62d0835cfd608ea","modified":1591347345564},{"_id":"public/2020/06/05/执行上下文/index.html","hash":"a513837b757cbd2c5a1c717866415e7d5824e500","modified":1591347345564},{"_id":"public/2020/05/21/hls技术和m3u8格式视频播放/index.html","hash":"fbab59758598f409b6da4da269b0edb849dc89d6","modified":1591347345564},{"_id":"public/2020/05/21/markdown/index.html","hash":"6ce8a0e5b13228d0888f9106b7ca4a5ec0cece06","modified":1591347345564},{"_id":"public/2020/06/05/浏览器/index.html","hash":"01efdfe4617a6db4952e6c6520c0fe6ecc5ff827","modified":1591347345564},{"_id":"public/index.html","hash":"8bc83a4d75fd225d05084e3db1acc4f0f41584a3","modified":1591347345564},{"_id":"public/images/execution","hash":"f95e44c891b60d0f9a62440d319ac8b107468fa5","modified":1591347345571},{"_id":"public/images/gecko.jpg","hash":"9ed33d023bfe296845ee70b1f5595aa7d37b19bb","modified":1591347345571},{"_id":"public/images/browser.png","hash":"98513917c0ad015b380cd4595052a31e7b9604e4","modified":1591347345571},{"_id":"public/images/eventLoop.webp","hash":"f5cd1bdef1c9e992a8a65ce1ab1fca5d26aa8e14","modified":1591347345571},{"_id":"public/images/HashTable.png","hash":"41acc916a03ef8765e915a4041ea8e2ea937598c","modified":1591347345571},{"_id":"public/images/linkedList.png","hash":"207a8fb2dc518dccb04f4dcde8343f0efb91a9f7","modified":1591347345571},{"_id":"public/images/linkedList1.webp","hash":"207a8fb2dc518dccb04f4dcde8343f0efb91a9f7","modified":1591347345571},{"_id":"public/images/set.png","hash":"8157da6f85394c367442fa91b8e71de778f88dae","modified":1591347345571},{"_id":"public/images/render-flow.png","hash":"675c0ef1c3cd0de8e7dced027cd751b5013520dc","modified":1591347345571},{"_id":"public/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1591347345571},{"_id":"public/images/webkitflow.png","hash":"2a140492f6dbdea1016a4d26e490fea961882687","modified":1591347345571},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1591347345571},{"_id":"public/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1591347345571},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1591347345571},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1591347345571},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1591347345572},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1591347345572},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1591347345572},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1591347345572},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1591347345572},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1591347345572},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1591347345572},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1591347345572},{"_id":"public/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1591347345572},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1591347345572},{"_id":"public/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1591347345572},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1591347345572},{"_id":"public/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1591347345572},{"_id":"public/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1591347345572},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1591347345572},{"_id":"public/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1591347345572},{"_id":"public/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1591347345572},{"_id":"public/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1591347345572},{"_id":"public/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1591347345572},{"_id":"public/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1591347345572},{"_id":"public/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1591347345572},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1591347345572},{"_id":"public/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1591347345572},{"_id":"public/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1591347345572},{"_id":"public/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1591347345572},{"_id":"public/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1591347345573},{"_id":"public/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1591347345573},{"_id":"public/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1591347345573},{"_id":"public/images/execution.webp","hash":"f95e44c891b60d0f9a62440d319ac8b107468fa5","modified":1591347346151},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1591347346153},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1591347346160},{"_id":"public/js/src/bootstrap.js","hash":"034bc8113e0966fe2096ba5b56061bbf10ef0512","modified":1591347346165},{"_id":"public/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1591347346165},{"_id":"public/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1591347346165},{"_id":"public/js/src/cursor.js","hash":"e4e19ac3bf738598aee3fd47769d319fa218a297","modified":1591347346165},{"_id":"public/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1591347346165},{"_id":"public/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1591347346165},{"_id":"public/js/src/post-details.js","hash":"a13f45f7aa8291cf7244ec5ba93907d119c5dbdd","modified":1591347346165},{"_id":"public/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1591347346165},{"_id":"public/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1591347346165},{"_id":"public/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1591347346165},{"_id":"public/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1591347346165},{"_id":"public/lib/canvas-ribbon/canvas-ribbon.js","hash":"ff5915eb2596e890a2fc6697c864f861a1995ec0","modified":1591347346165},{"_id":"public/js/src/utils.js","hash":"9b1325801d27213083d1487a12b1a62b539ab6f8","modified":1591347346165},{"_id":"public/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1591347346165},{"_id":"public/lib/fastclick/bower.json","hash":"4dcecf83afddba148464d5339c93f6d0aa9f42e9","modified":1591347346165},{"_id":"public/js/src/motion.js","hash":"4002561ae03903a015d51c9fe1f2bf65fcc4dda2","modified":1591347346165},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1591347346165},{"_id":"public/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1591347346165},{"_id":"public/lib/jquery_lazyload/bower.json","hash":"ae3c3b61e6e7f9e1d7e3585ad854380ecc04cf53","modified":1591347346165},{"_id":"public/lib/needsharebutton/needsharebutton.css","hash":"3ef0020a1815ca6151ea4886cd0d37421ae3695c","modified":1591347346165},{"_id":"public/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1591347346166},{"_id":"public/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1591347346166},{"_id":"public/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1591347346166},{"_id":"public/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1591347346166},{"_id":"public/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1591347346166},{"_id":"public/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1591347346166},{"_id":"public/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1591347346166},{"_id":"public/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1591347346166},{"_id":"public/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1591347346166},{"_id":"public/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1591347346166},{"_id":"public/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1591347346166},{"_id":"public/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1591347346166},{"_id":"public/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1591347346166},{"_id":"public/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1591347346166},{"_id":"public/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1591347346167},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1591347346167},{"_id":"public/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1591347346167},{"_id":"public/lib/velocity/bower.json","hash":"0ef14e7ccdfba5db6eb3f8fc6aa3b47282c36409","modified":1591347346167},{"_id":"public/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1591347346167},{"_id":"public/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1591347346167},{"_id":"public/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1591347346167},{"_id":"public/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1591347346167},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1591347346167},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1591347346167},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1591347346167},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1591347346167},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1591347346167},{"_id":"public/lib/fastclick/README.html","hash":"c5a4c05ca80132b7e343d5fd1d1d1a976b4ad151","modified":1591347346167},{"_id":"public/lib/jquery_lazyload/README.html","hash":"18a600ca1aafd3bf08af52b6a6fe5f056aeed9f4","modified":1591347346167},{"_id":"public/lib/jquery_lazyload/CONTRIBUTING.html","hash":"81057e5b518b8ab60474e1ad027e868b558f15b7","modified":1591347346167},{"_id":"public/css/main.css","hash":"9f704a8aad89b72171b54fefe32e55d8c729972c","modified":1591347346167},{"_id":"public/js/src/wobblewindow.js","hash":"709801602c2a84bd8eb4e552bf6abfbbd3819fe5","modified":1591347346167},{"_id":"public/lib/needsharebutton/needsharebutton.js","hash":"9885fd9bea5e7ebafc5b1de9d17be5e106248d96","modified":1591347346167},{"_id":"public/lib/needsharebutton/font-embedded.css","hash":"c39d37278c1e178838732af21bd26cd0baeddfe0","modified":1591347346167},{"_id":"public/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1591347346167},{"_id":"public/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1591347346168},{"_id":"public/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1591347346168},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1591347346168},{"_id":"public/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1591347346168},{"_id":"public/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1591347346168},{"_id":"public/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1591347346168},{"_id":"public/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1591347346168},{"_id":"public/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1591347346168},{"_id":"public/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1591347346168},{"_id":"public/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1591347346168},{"_id":"public/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1591347346168},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1591347346168},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1591347346168},{"_id":"public/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1591347346168},{"_id":"public/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1591347346168},{"_id":"public/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1591347346168},{"_id":"public/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1591347346169},{"_id":"public/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1591347346169},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1591347346169},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1591347346169},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1591347346190},{"_id":"public/images/webpack-bundle-analyzer.gif","hash":"24a3beb8c29c270557bf3dc9b53ee676497be043","modified":1591347346240},{"_id":"public/images/WeGameMiniLoader.std.2.03.03.2031.exe","hash":"492aed348104e8299656b83c508424391264cf0f","modified":1591347346251}],"Category":[{"name":"前端","_id":"ckb1z4dff000k9n94ff4gs7r3"}],"Data":[],"Page":[{"title":"标签","date":"2019-08-22T09:46:26.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ndate: 2019-08-22 17:46:26\ntype: \"tags\"\n---\n","updated":"2020-05-21T06:42:07.882Z","path":"tags/index.html","comments":1,"layout":"page","_id":"ckb1z4det00019n94ecau6tcm","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"分类","date":"2019-08-22T09:46:44.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: 分类\ndate: 2019-08-22 17:46:44\ntype: \"categories\"\n---\n","updated":"2020-05-21T06:42:00.088Z","path":"categories/index.html","comments":1,"layout":"page","_id":"ckb1z4dev00039n94uoky06yy","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"ES6","_content":"\n## var let const\n\n我们就从`声明过程`，`内存分配`，`变量提升`这三点来看这三者之间的区别。\n\n1. 声明过程\n\n- var：遇到有 var 的作用域，在任何语句执行前都已经完成了声明和初始化，也就是变量提升而且拿到 undefined 的原因由来 function： 声明、初始化、赋值一开始就全部完成，所以函数的变量提升优先级更高\n- let：解析器进入一个块级作用域，发现 let 关键字，变量只是先完成声明，并没有到初始化那一步。此时如果在此作用域提前访问，则报错 xx is not defined，这就是暂时性死区的由来。等到解析到有 let 那一行的时候，才会进入初始化阶段。如果 let 的那一行是赋值操作，则初始化和赋值同时进行\n- const、class 都是同 let 一样的道理 比如解析如下代码步骤：\n\n{ // 没用的第一行 // 没用的第二行 console.log(a) // 如果此时访问 a 报错 a is not defined let a = 1 } 步骤：\n\n发现作用域有 let a，先注册个 a，仅仅注册 没用的第一行 没用的第二行 a is not defined，暂时性死区的表现 假设前面那行不报错，a 初始化为 undefined a 赋值为 1 对比于 var，let、const 只是解耦了声明和初始化的过程，var 是在任何语句执行前都已经完成了声明和初始化，let、const 仅仅是在任何语句执行前只完成了声明。\n\n2. 内存分配\n\n- var，会直接在栈内存里预分配内存空间，然后等到实际语句执行的时候，再存储对应的变量，如果传的是引用类型，那么会在堆内存里开辟一个内存空间存储实际内容，栈内存会存储一个指向堆内存的指针\n\n- let，是不会在栈内存里预分配内存空间，而且在栈内存分配变量时，做一个检查，如果已经有相同变量名存在就会报错\n\n- const，也不会预分配内存空间，在栈内存分配变量时也会做同样的检查。不过 const 存储的变量是不可修改的，对于基本类型来说你无法修改定义的值，对于引用类型来说你无法修改栈内存里分配的指针，但是你可以修改指针指向的对象里面的属性\n\n3. 变量提升\n\nlet const 和 var 三者其实会存在变量提升\n\n- let 只是创建过程提升，初始化过程并没有提升，所以会产生暂时性死区,定义在使用之后报错。\n- var 的创建和初始化过程都提升了，所以在赋值前访问会得到 undefined function 的创建、初始化、赋值都被提升了\n","source":"_drafts/ES6.md","raw":"---\ntitle: ES6\ncategories:\ntags:\n---\n\n## var let const\n\n我们就从`声明过程`，`内存分配`，`变量提升`这三点来看这三者之间的区别。\n\n1. 声明过程\n\n- var：遇到有 var 的作用域，在任何语句执行前都已经完成了声明和初始化，也就是变量提升而且拿到 undefined 的原因由来 function： 声明、初始化、赋值一开始就全部完成，所以函数的变量提升优先级更高\n- let：解析器进入一个块级作用域，发现 let 关键字，变量只是先完成声明，并没有到初始化那一步。此时如果在此作用域提前访问，则报错 xx is not defined，这就是暂时性死区的由来。等到解析到有 let 那一行的时候，才会进入初始化阶段。如果 let 的那一行是赋值操作，则初始化和赋值同时进行\n- const、class 都是同 let 一样的道理 比如解析如下代码步骤：\n\n{ // 没用的第一行 // 没用的第二行 console.log(a) // 如果此时访问 a 报错 a is not defined let a = 1 } 步骤：\n\n发现作用域有 let a，先注册个 a，仅仅注册 没用的第一行 没用的第二行 a is not defined，暂时性死区的表现 假设前面那行不报错，a 初始化为 undefined a 赋值为 1 对比于 var，let、const 只是解耦了声明和初始化的过程，var 是在任何语句执行前都已经完成了声明和初始化，let、const 仅仅是在任何语句执行前只完成了声明。\n\n2. 内存分配\n\n- var，会直接在栈内存里预分配内存空间，然后等到实际语句执行的时候，再存储对应的变量，如果传的是引用类型，那么会在堆内存里开辟一个内存空间存储实际内容，栈内存会存储一个指向堆内存的指针\n\n- let，是不会在栈内存里预分配内存空间，而且在栈内存分配变量时，做一个检查，如果已经有相同变量名存在就会报错\n\n- const，也不会预分配内存空间，在栈内存分配变量时也会做同样的检查。不过 const 存储的变量是不可修改的，对于基本类型来说你无法修改定义的值，对于引用类型来说你无法修改栈内存里分配的指针，但是你可以修改指针指向的对象里面的属性\n\n3. 变量提升\n\nlet const 和 var 三者其实会存在变量提升\n\n- let 只是创建过程提升，初始化过程并没有提升，所以会产生暂时性死区,定义在使用之后报错。\n- var 的创建和初始化过程都提升了，所以在赋值前访问会得到 undefined function 的创建、初始化、赋值都被提升了\n","slug":"ES6","published":0,"date":"2019-10-21T14:55:14.100Z","updated":"2019-10-23T02:33:40.294Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckb1z4dep00009n94b1itm1ny","content":"<h2 id=\"var-let-const\"><a href=\"#var-let-const\" class=\"headerlink\" title=\"var let const\"></a>var let const</h2><p>我们就从<code>声明过程</code>，<code>内存分配</code>，<code>变量提升</code>这三点来看这三者之间的区别。</p>\n<ol>\n<li>声明过程</li>\n</ol>\n<ul>\n<li>var：遇到有 var 的作用域，在任何语句执行前都已经完成了声明和初始化，也就是变量提升而且拿到 undefined 的原因由来 function： 声明、初始化、赋值一开始就全部完成，所以函数的变量提升优先级更高</li>\n<li>let：解析器进入一个块级作用域，发现 let 关键字，变量只是先完成声明，并没有到初始化那一步。此时如果在此作用域提前访问，则报错 xx is not defined，这就是暂时性死区的由来。等到解析到有 let 那一行的时候，才会进入初始化阶段。如果 let 的那一行是赋值操作，则初始化和赋值同时进行</li>\n<li>const、class 都是同 let 一样的道理 比如解析如下代码步骤：</li>\n</ul>\n<p>{ // 没用的第一行 // 没用的第二行 console.log(a) // 如果此时访问 a 报错 a is not defined let a = 1 } 步骤：</p>\n<p>发现作用域有 let a，先注册个 a，仅仅注册 没用的第一行 没用的第二行 a is not defined，暂时性死区的表现 假设前面那行不报错，a 初始化为 undefined a 赋值为 1 对比于 var，let、const 只是解耦了声明和初始化的过程，var 是在任何语句执行前都已经完成了声明和初始化，let、const 仅仅是在任何语句执行前只完成了声明。</p>\n<ol start=\"2\">\n<li>内存分配</li>\n</ol>\n<ul>\n<li><p>var，会直接在栈内存里预分配内存空间，然后等到实际语句执行的时候，再存储对应的变量，如果传的是引用类型，那么会在堆内存里开辟一个内存空间存储实际内容，栈内存会存储一个指向堆内存的指针</p>\n</li>\n<li><p>let，是不会在栈内存里预分配内存空间，而且在栈内存分配变量时，做一个检查，如果已经有相同变量名存在就会报错</p>\n</li>\n<li><p>const，也不会预分配内存空间，在栈内存分配变量时也会做同样的检查。不过 const 存储的变量是不可修改的，对于基本类型来说你无法修改定义的值，对于引用类型来说你无法修改栈内存里分配的指针，但是你可以修改指针指向的对象里面的属性</p>\n</li>\n</ul>\n<ol start=\"3\">\n<li>变量提升</li>\n</ol>\n<p>let const 和 var 三者其实会存在变量提升</p>\n<ul>\n<li>let 只是创建过程提升，初始化过程并没有提升，所以会产生暂时性死区,定义在使用之后报错。</li>\n<li>var 的创建和初始化过程都提升了，所以在赋值前访问会得到 undefined function 的创建、初始化、赋值都被提升了</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"var-let-const\"><a href=\"#var-let-const\" class=\"headerlink\" title=\"var let const\"></a>var let const</h2><p>我们就从<code>声明过程</code>，<code>内存分配</code>，<code>变量提升</code>这三点来看这三者之间的区别。</p>\n<ol>\n<li>声明过程</li>\n</ol>\n<ul>\n<li>var：遇到有 var 的作用域，在任何语句执行前都已经完成了声明和初始化，也就是变量提升而且拿到 undefined 的原因由来 function： 声明、初始化、赋值一开始就全部完成，所以函数的变量提升优先级更高</li>\n<li>let：解析器进入一个块级作用域，发现 let 关键字，变量只是先完成声明，并没有到初始化那一步。此时如果在此作用域提前访问，则报错 xx is not defined，这就是暂时性死区的由来。等到解析到有 let 那一行的时候，才会进入初始化阶段。如果 let 的那一行是赋值操作，则初始化和赋值同时进行</li>\n<li>const、class 都是同 let 一样的道理 比如解析如下代码步骤：</li>\n</ul>\n<p>{ // 没用的第一行 // 没用的第二行 console.log(a) // 如果此时访问 a 报错 a is not defined let a = 1 } 步骤：</p>\n<p>发现作用域有 let a，先注册个 a，仅仅注册 没用的第一行 没用的第二行 a is not defined，暂时性死区的表现 假设前面那行不报错，a 初始化为 undefined a 赋值为 1 对比于 var，let、const 只是解耦了声明和初始化的过程，var 是在任何语句执行前都已经完成了声明和初始化，let、const 仅仅是在任何语句执行前只完成了声明。</p>\n<ol start=\"2\">\n<li>内存分配</li>\n</ol>\n<ul>\n<li><p>var，会直接在栈内存里预分配内存空间，然后等到实际语句执行的时候，再存储对应的变量，如果传的是引用类型，那么会在堆内存里开辟一个内存空间存储实际内容，栈内存会存储一个指向堆内存的指针</p>\n</li>\n<li><p>let，是不会在栈内存里预分配内存空间，而且在栈内存分配变量时，做一个检查，如果已经有相同变量名存在就会报错</p>\n</li>\n<li><p>const，也不会预分配内存空间，在栈内存分配变量时也会做同样的检查。不过 const 存储的变量是不可修改的，对于基本类型来说你无法修改定义的值，对于引用类型来说你无法修改栈内存里分配的指针，但是你可以修改指针指向的对象里面的属性</p>\n</li>\n</ul>\n<ol start=\"3\">\n<li>变量提升</li>\n</ol>\n<p>let const 和 var 三者其实会存在变量提升</p>\n<ul>\n<li>let 只是创建过程提升，初始化过程并没有提升，所以会产生暂时性死区,定义在使用之后报错。</li>\n<li>var 的创建和初始化过程都提升了，所以在赋值前访问会得到 undefined function 的创建、初始化、赋值都被提升了</li>\n</ul>\n"},{"title":"Loader","_content":"\n## css-loader\n\nThe css-loader interprets @import and url() like import/require() and will resolve them.\n(css-loader 会像 import / require（）一样解释@import 和 url（）并将解析它们。)\n\n处理@import 和 url()\n\n## style-loader\n\nAdds CSS to the DOM by injecting a <style> tag\n(通过注入<style>标签将 CSS 添加到 DOM)\n","source":"_drafts/Loader.md","raw":"---\ntitle: Loader\ncategories:\ntags:\n---\n\n## css-loader\n\nThe css-loader interprets @import and url() like import/require() and will resolve them.\n(css-loader 会像 import / require（）一样解释@import 和 url（）并将解析它们。)\n\n处理@import 和 url()\n\n## style-loader\n\nAdds CSS to the DOM by injecting a <style> tag\n(通过注入<style>标签将 CSS 添加到 DOM)\n","slug":"Loader","published":0,"date":"2019-10-28T01:40:54.021Z","updated":"2019-10-28T02:36:59.551Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckb1z4deu00029n946034k9fj","content":"<h2 id=\"css-loader\"><a href=\"#css-loader\" class=\"headerlink\" title=\"css-loader\"></a>css-loader</h2><p>The css-loader interprets @import and url() like import/require() and will resolve them.<br>(css-loader 会像 import / require（）一样解释@import 和 url（）并将解析它们。)</p>\n<p>处理@import 和 url()</p>\n<h2 id=\"style-loader\"><a href=\"#style-loader\" class=\"headerlink\" title=\"style-loader\"></a>style-loader</h2><p>Adds CSS to the DOM by injecting a <style> tag<br>(通过注入<style>标签将 CSS 添加到 DOM)</p>\n</style></p>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"css-loader\"><a href=\"#css-loader\" class=\"headerlink\" title=\"css-loader\"></a>css-loader</h2><p>The css-loader interprets @import and url() like import/require() and will resolve them.<br>(css-loader 会像 import / require（）一样解释@import 和 url（）并将解析它们。)</p>\n<p>处理@import 和 url()</p>\n<h2 id=\"style-loader\"><a href=\"#style-loader\" class=\"headerlink\" title=\"style-loader\"></a>style-loader</h2><p>Adds CSS to the DOM by injecting a <style> tag<br>(通过注入<style>标签将 CSS 添加到 DOM)</p>\n</style></p>"},{"title":"Promise 对象","_content":"\n## 描述\n\nPromise对象用于表示一个异步操作的最终完成 (或失败), 及其结果值。 Promise 对象是一个代理对象（代理一个值），被代理的值在 Promise 对象创建时可能是未知的。它允许你为异步操作的成功和失败分别绑定相应的处理方法（handlers）。 这让异步方法可以像同步方法那样返回值，但并不是立即返回最终执行结果，而是一个能代表未来出现的结果的 promise 对象\n\n一个 Promise 有以下几种状态:\n\n- pending: 初始状态，既不是成功，也不是失败状态。\n- fulfilled: 意味着操作成功完成。\n- rejected: 意味着操作失败。\n\npending 状态的 Promise 对象可能会变为 fulfilled 状态并传递一个值给相应的状态处理方法，也可能变为失败状态（rejected）并传递失败信息。当其中任一种情况出现时，Promise 对象的 then 方法绑定的处理方法（handlers ）就会被调用（then 方法包含两个参数：onfulfilled 和 onrejected，它们都是 Function 类型。当 Promise 状态为 fulfilled 时，调用 then 的 onfulfilled 方法，当 Promise 状态为 rejected 时，调用 then 的 onrejected 方法， 所以在异步操作的完成和绑定处理方法之间不存在竞争）。\n\n## 方法\n\n**`Promise.all(iterable)`**\n\n这个方法返回一个新的 promise 对象，该 promise 对象在 iterable 参数对象里所有的 promise 对象都成功的时候才会触发成功，一旦有任何一个 iterable 里面的 promise 对象失败则立即触发该 promise 对象的失败。这个新的 promise 对象在触发成功状态以后，会把一个包含 iterable 里所有 promise 返回值的数组作为成功回调的返回值，顺序跟 iterable 的顺序保持一致；如果这个新的 promise 对象触发了失败状态，它会把 iterable 里第一个触发失败的 promise 对象的错误信息作为它的失败错误信息。Promise.all 方法常被用于处理多个 promise 对象的状态集合。\n\n每个iterable都处于fulfilled或者rejected状态才返回\n\n如果 iterable===[]，则返回 undefined\n\n```\nPromise.all([ajax1,ajax2,ajax3]).then()\n```\n\n**`Promise.race(iterable)`**\n\n当 iterable 参数里的任意一个子 promise 被成功或失败后，父 promise 马上也会用子 promise 的成功返回值或失败详情作为参数调用父 promise 绑定的相应句柄，并返回该 promise 对象。\n\n哪个快就用那个的状态\n\n如果 iterable===[]，则报错\n\n**`Promise.reject(reason)`**\n\n返回一个状态为失败的 Promise 对象，并将给定的失败信息传递给对应的处理方法\n\n**`Promise.resolve(value)`**\n\n返回一个状态由给定 value 决定的 Promise 对象。\n\n如果该值是 thenable(即，带有 then 方法的对象)，返回的 Promise 对象的最终状态由 then 方法执行决定；\n\n否则的话(**`该 value 为空，基本类型或者不带 then 方法的对象`**),返回的 Promise 对象状态为 fulfilled，并且将该 value 传递给对应的 then 方法。\n\n通常而言，如果你不知道一个值是否是 Promise 对象，使用 Promise.resolve(value) 来返回一个 Promise 对象,这样就能将该 value 以 Promise 对象形式使用。\n\n## 创建 Promise\n\nPromise 对象是由关键字 new 及其构造函数来创建的。\n\n该构造函数会把一个叫做“处理器函数”（executor function）的函数作为它的参数。这个“处理器函数”接受两个函数——resolve 和 reject ——作为其参数。\n\n**一旦创建，则立即执行处理器函数**\n\n**promise 状态一旦改变则不能再变。**\n\n当异步任务顺利完成且返回结果值时，会调用 resolve 函数；而当异步任务失败且返回失败原因（通常是一个错误对象）时，会调用 reject 函数。\n\n```\nconst myFirstPromise = new Promise((resolve, reject) => {\n  // ?做一些异步操作，最终会调用下面两者之一:\n  //\n  //   resolve(someValue); // fulfilled\n  // ?或\n  //   reject(\"failure reason\"); // rejected\n});\n\n```\n\n想要某个函数?拥有 promise 功能，只需让其返回一个 promise 即可。\n\n```\nfunction myAsyncFunction(url) {\n  return new Promise((resolve, reject) => {\n    const xhr = new XMLHttpRequest();\n    xhr.open(\"GET\", url);\n    xhr.onload = () => resolve(xhr.responseText);\n    xhr.onerror = () => reject(xhr.statusText);\n    xhr.send();\n  });\n};\n\n```\n\n## 面试题解析\n\n```\nPromise.resolve(1)\n  .then(2)\n  .then(Promise.resolve(3))\n  .then(console.log)\n\n#### 解析\n\nPromise.resolve 方法的参数如果是一个原始值，或者是一个不具有 then 方法的对象，则 Promise.resolve 方法返回一个新的 Promise 对象，状态为resolved，Promise.resolve 方法的参数，会同时传给回调函数。\n\nthen 方法接受的参数是函数，而如果传递的并非是一个函数，它实际上会将其解释为 then(null)，这就会导致前一个 Promise 的结果会穿透下面。\n\n上面题目等于： Promise.resolve(1).then(console.log)\n```\n\n```\n// 涉及eventLoop\n\nconst promise1 = new Promise((resolve, reject) => {\n  setTimeout(() => {\n    resolve('foo');\n  }, 300);\n});\n\npromise1.then((value) => {\n  console.log(value);\n  // expected output: \"foo\"\n});\n\nconsole.log(promise1);\n// expected output: [object Promise]\n\n```\n","source":"_drafts/Promise.md","raw":"---\ntitle: Promise 对象\ncategories:\ntags:\n---\n\n## 描述\n\nPromise对象用于表示一个异步操作的最终完成 (或失败), 及其结果值。 Promise 对象是一个代理对象（代理一个值），被代理的值在 Promise 对象创建时可能是未知的。它允许你为异步操作的成功和失败分别绑定相应的处理方法（handlers）。 这让异步方法可以像同步方法那样返回值，但并不是立即返回最终执行结果，而是一个能代表未来出现的结果的 promise 对象\n\n一个 Promise 有以下几种状态:\n\n- pending: 初始状态，既不是成功，也不是失败状态。\n- fulfilled: 意味着操作成功完成。\n- rejected: 意味着操作失败。\n\npending 状态的 Promise 对象可能会变为 fulfilled 状态并传递一个值给相应的状态处理方法，也可能变为失败状态（rejected）并传递失败信息。当其中任一种情况出现时，Promise 对象的 then 方法绑定的处理方法（handlers ）就会被调用（then 方法包含两个参数：onfulfilled 和 onrejected，它们都是 Function 类型。当 Promise 状态为 fulfilled 时，调用 then 的 onfulfilled 方法，当 Promise 状态为 rejected 时，调用 then 的 onrejected 方法， 所以在异步操作的完成和绑定处理方法之间不存在竞争）。\n\n## 方法\n\n**`Promise.all(iterable)`**\n\n这个方法返回一个新的 promise 对象，该 promise 对象在 iterable 参数对象里所有的 promise 对象都成功的时候才会触发成功，一旦有任何一个 iterable 里面的 promise 对象失败则立即触发该 promise 对象的失败。这个新的 promise 对象在触发成功状态以后，会把一个包含 iterable 里所有 promise 返回值的数组作为成功回调的返回值，顺序跟 iterable 的顺序保持一致；如果这个新的 promise 对象触发了失败状态，它会把 iterable 里第一个触发失败的 promise 对象的错误信息作为它的失败错误信息。Promise.all 方法常被用于处理多个 promise 对象的状态集合。\n\n每个iterable都处于fulfilled或者rejected状态才返回\n\n如果 iterable===[]，则返回 undefined\n\n```\nPromise.all([ajax1,ajax2,ajax3]).then()\n```\n\n**`Promise.race(iterable)`**\n\n当 iterable 参数里的任意一个子 promise 被成功或失败后，父 promise 马上也会用子 promise 的成功返回值或失败详情作为参数调用父 promise 绑定的相应句柄，并返回该 promise 对象。\n\n哪个快就用那个的状态\n\n如果 iterable===[]，则报错\n\n**`Promise.reject(reason)`**\n\n返回一个状态为失败的 Promise 对象，并将给定的失败信息传递给对应的处理方法\n\n**`Promise.resolve(value)`**\n\n返回一个状态由给定 value 决定的 Promise 对象。\n\n如果该值是 thenable(即，带有 then 方法的对象)，返回的 Promise 对象的最终状态由 then 方法执行决定；\n\n否则的话(**`该 value 为空，基本类型或者不带 then 方法的对象`**),返回的 Promise 对象状态为 fulfilled，并且将该 value 传递给对应的 then 方法。\n\n通常而言，如果你不知道一个值是否是 Promise 对象，使用 Promise.resolve(value) 来返回一个 Promise 对象,这样就能将该 value 以 Promise 对象形式使用。\n\n## 创建 Promise\n\nPromise 对象是由关键字 new 及其构造函数来创建的。\n\n该构造函数会把一个叫做“处理器函数”（executor function）的函数作为它的参数。这个“处理器函数”接受两个函数——resolve 和 reject ——作为其参数。\n\n**一旦创建，则立即执行处理器函数**\n\n**promise 状态一旦改变则不能再变。**\n\n当异步任务顺利完成且返回结果值时，会调用 resolve 函数；而当异步任务失败且返回失败原因（通常是一个错误对象）时，会调用 reject 函数。\n\n```\nconst myFirstPromise = new Promise((resolve, reject) => {\n  // ?做一些异步操作，最终会调用下面两者之一:\n  //\n  //   resolve(someValue); // fulfilled\n  // ?或\n  //   reject(\"failure reason\"); // rejected\n});\n\n```\n\n想要某个函数?拥有 promise 功能，只需让其返回一个 promise 即可。\n\n```\nfunction myAsyncFunction(url) {\n  return new Promise((resolve, reject) => {\n    const xhr = new XMLHttpRequest();\n    xhr.open(\"GET\", url);\n    xhr.onload = () => resolve(xhr.responseText);\n    xhr.onerror = () => reject(xhr.statusText);\n    xhr.send();\n  });\n};\n\n```\n\n## 面试题解析\n\n```\nPromise.resolve(1)\n  .then(2)\n  .then(Promise.resolve(3))\n  .then(console.log)\n\n#### 解析\n\nPromise.resolve 方法的参数如果是一个原始值，或者是一个不具有 then 方法的对象，则 Promise.resolve 方法返回一个新的 Promise 对象，状态为resolved，Promise.resolve 方法的参数，会同时传给回调函数。\n\nthen 方法接受的参数是函数，而如果传递的并非是一个函数，它实际上会将其解释为 then(null)，这就会导致前一个 Promise 的结果会穿透下面。\n\n上面题目等于： Promise.resolve(1).then(console.log)\n```\n\n```\n// 涉及eventLoop\n\nconst promise1 = new Promise((resolve, reject) => {\n  setTimeout(() => {\n    resolve('foo');\n  }, 300);\n});\n\npromise1.then((value) => {\n  console.log(value);\n  // expected output: \"foo\"\n});\n\nconsole.log(promise1);\n// expected output: [object Promise]\n\n```\n","slug":"Promise","published":0,"date":"2020-05-22T06:30:30.009Z","updated":"2020-05-22T06:30:30.009Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckb1z4dey00049n945o8u193j","content":"<h2 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h2><p>Promise对象用于表示一个异步操作的最终完成 (或失败), 及其结果值。 Promise 对象是一个代理对象（代理一个值），被代理的值在 Promise 对象创建时可能是未知的。它允许你为异步操作的成功和失败分别绑定相应的处理方法（handlers）。 这让异步方法可以像同步方法那样返回值，但并不是立即返回最终执行结果，而是一个能代表未来出现的结果的 promise 对象</p>\n<p>一个 Promise 有以下几种状态:</p>\n<ul>\n<li>pending: 初始状态，既不是成功，也不是失败状态。</li>\n<li>fulfilled: 意味着操作成功完成。</li>\n<li>rejected: 意味着操作失败。</li>\n</ul>\n<p>pending 状态的 Promise 对象可能会变为 fulfilled 状态并传递一个值给相应的状态处理方法，也可能变为失败状态（rejected）并传递失败信息。当其中任一种情况出现时，Promise 对象的 then 方法绑定的处理方法（handlers ）就会被调用（then 方法包含两个参数：onfulfilled 和 onrejected，它们都是 Function 类型。当 Promise 状态为 fulfilled 时，调用 then 的 onfulfilled 方法，当 Promise 状态为 rejected 时，调用 then 的 onrejected 方法， 所以在异步操作的完成和绑定处理方法之间不存在竞争）。</p>\n<h2 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h2><p><strong><code>Promise.all(iterable)</code></strong></p>\n<p>这个方法返回一个新的 promise 对象，该 promise 对象在 iterable 参数对象里所有的 promise 对象都成功的时候才会触发成功，一旦有任何一个 iterable 里面的 promise 对象失败则立即触发该 promise 对象的失败。这个新的 promise 对象在触发成功状态以后，会把一个包含 iterable 里所有 promise 返回值的数组作为成功回调的返回值，顺序跟 iterable 的顺序保持一致；如果这个新的 promise 对象触发了失败状态，它会把 iterable 里第一个触发失败的 promise 对象的错误信息作为它的失败错误信息。Promise.all 方法常被用于处理多个 promise 对象的状态集合。</p>\n<p>每个iterable都处于fulfilled或者rejected状态才返回</p>\n<p>如果 iterable===[]，则返回 undefined</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Promise.all([ajax1,ajax2,ajax3]).then()</span><br></pre></td></tr></table></figure>\n\n<p><strong><code>Promise.race(iterable)</code></strong></p>\n<p>当 iterable 参数里的任意一个子 promise 被成功或失败后，父 promise 马上也会用子 promise 的成功返回值或失败详情作为参数调用父 promise 绑定的相应句柄，并返回该 promise 对象。</p>\n<p>哪个快就用那个的状态</p>\n<p>如果 iterable===[]，则报错</p>\n<p><strong><code>Promise.reject(reason)</code></strong></p>\n<p>返回一个状态为失败的 Promise 对象，并将给定的失败信息传递给对应的处理方法</p>\n<p><strong><code>Promise.resolve(value)</code></strong></p>\n<p>返回一个状态由给定 value 决定的 Promise 对象。</p>\n<p>如果该值是 thenable(即，带有 then 方法的对象)，返回的 Promise 对象的最终状态由 then 方法执行决定；</p>\n<p>否则的话(<strong><code>该 value 为空，基本类型或者不带 then 方法的对象</code></strong>),返回的 Promise 对象状态为 fulfilled，并且将该 value 传递给对应的 then 方法。</p>\n<p>通常而言，如果你不知道一个值是否是 Promise 对象，使用 Promise.resolve(value) 来返回一个 Promise 对象,这样就能将该 value 以 Promise 对象形式使用。</p>\n<h2 id=\"创建-Promise\"><a href=\"#创建-Promise\" class=\"headerlink\" title=\"创建 Promise\"></a>创建 Promise</h2><p>Promise 对象是由关键字 new 及其构造函数来创建的。</p>\n<p>该构造函数会把一个叫做“处理器函数”（executor function）的函数作为它的参数。这个“处理器函数”接受两个函数——resolve 和 reject ——作为其参数。</p>\n<p><strong>一旦创建，则立即执行处理器函数</strong></p>\n<p><strong>promise 状态一旦改变则不能再变。</strong></p>\n<p>当异步任务顺利完成且返回结果值时，会调用 resolve 函数；而当异步任务失败且返回失败原因（通常是一个错误对象）时，会调用 reject 函数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const myFirstPromise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class=\"line\">  // ?做一些异步操作，最终会调用下面两者之一:</span><br><span class=\"line\">  //</span><br><span class=\"line\">  //   resolve(someValue); // fulfilled</span><br><span class=\"line\">  // ?或</span><br><span class=\"line\">  //   reject(&quot;failure reason&quot;); // rejected</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>想要某个函数?拥有 promise 功能，只需让其返回一个 promise 即可。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function myAsyncFunction(url) &#123;</span><br><span class=\"line\">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class=\"line\">    const xhr = new XMLHttpRequest();</span><br><span class=\"line\">    xhr.open(&quot;GET&quot;, url);</span><br><span class=\"line\">    xhr.onload = () =&gt; resolve(xhr.responseText);</span><br><span class=\"line\">    xhr.onerror = () =&gt; reject(xhr.statusText);</span><br><span class=\"line\">    xhr.send();</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"面试题解析\"><a href=\"#面试题解析\" class=\"headerlink\" title=\"面试题解析\"></a>面试题解析</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Promise.resolve(1)</span><br><span class=\"line\">  .then(2)</span><br><span class=\"line\">  .then(Promise.resolve(3))</span><br><span class=\"line\">  .then(console.log)</span><br><span class=\"line\"></span><br><span class=\"line\">#### 解析</span><br><span class=\"line\"></span><br><span class=\"line\">Promise.resolve 方法的参数如果是一个原始值，或者是一个不具有 then 方法的对象，则 Promise.resolve 方法返回一个新的 Promise 对象，状态为resolved，Promise.resolve 方法的参数，会同时传给回调函数。</span><br><span class=\"line\"></span><br><span class=\"line\">then 方法接受的参数是函数，而如果传递的并非是一个函数，它实际上会将其解释为 then(null)，这就会导致前一个 Promise 的结果会穿透下面。</span><br><span class=\"line\"></span><br><span class=\"line\">上面题目等于： Promise.resolve(1).then(console.log)</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 涉及eventLoop</span><br><span class=\"line\"></span><br><span class=\"line\">const promise1 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class=\"line\">  setTimeout(() =&gt; &#123;</span><br><span class=\"line\">    resolve(&apos;foo&apos;);</span><br><span class=\"line\">  &#125;, 300);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">promise1.then((value) =&gt; &#123;</span><br><span class=\"line\">  console.log(value);</span><br><span class=\"line\">  // expected output: &quot;foo&quot;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(promise1);</span><br><span class=\"line\">// expected output: [object Promise]</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h2><p>Promise对象用于表示一个异步操作的最终完成 (或失败), 及其结果值。 Promise 对象是一个代理对象（代理一个值），被代理的值在 Promise 对象创建时可能是未知的。它允许你为异步操作的成功和失败分别绑定相应的处理方法（handlers）。 这让异步方法可以像同步方法那样返回值，但并不是立即返回最终执行结果，而是一个能代表未来出现的结果的 promise 对象</p>\n<p>一个 Promise 有以下几种状态:</p>\n<ul>\n<li>pending: 初始状态，既不是成功，也不是失败状态。</li>\n<li>fulfilled: 意味着操作成功完成。</li>\n<li>rejected: 意味着操作失败。</li>\n</ul>\n<p>pending 状态的 Promise 对象可能会变为 fulfilled 状态并传递一个值给相应的状态处理方法，也可能变为失败状态（rejected）并传递失败信息。当其中任一种情况出现时，Promise 对象的 then 方法绑定的处理方法（handlers ）就会被调用（then 方法包含两个参数：onfulfilled 和 onrejected，它们都是 Function 类型。当 Promise 状态为 fulfilled 时，调用 then 的 onfulfilled 方法，当 Promise 状态为 rejected 时，调用 then 的 onrejected 方法， 所以在异步操作的完成和绑定处理方法之间不存在竞争）。</p>\n<h2 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h2><p><strong><code>Promise.all(iterable)</code></strong></p>\n<p>这个方法返回一个新的 promise 对象，该 promise 对象在 iterable 参数对象里所有的 promise 对象都成功的时候才会触发成功，一旦有任何一个 iterable 里面的 promise 对象失败则立即触发该 promise 对象的失败。这个新的 promise 对象在触发成功状态以后，会把一个包含 iterable 里所有 promise 返回值的数组作为成功回调的返回值，顺序跟 iterable 的顺序保持一致；如果这个新的 promise 对象触发了失败状态，它会把 iterable 里第一个触发失败的 promise 对象的错误信息作为它的失败错误信息。Promise.all 方法常被用于处理多个 promise 对象的状态集合。</p>\n<p>每个iterable都处于fulfilled或者rejected状态才返回</p>\n<p>如果 iterable===[]，则返回 undefined</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Promise.all([ajax1,ajax2,ajax3]).then()</span><br></pre></td></tr></table></figure>\n\n<p><strong><code>Promise.race(iterable)</code></strong></p>\n<p>当 iterable 参数里的任意一个子 promise 被成功或失败后，父 promise 马上也会用子 promise 的成功返回值或失败详情作为参数调用父 promise 绑定的相应句柄，并返回该 promise 对象。</p>\n<p>哪个快就用那个的状态</p>\n<p>如果 iterable===[]，则报错</p>\n<p><strong><code>Promise.reject(reason)</code></strong></p>\n<p>返回一个状态为失败的 Promise 对象，并将给定的失败信息传递给对应的处理方法</p>\n<p><strong><code>Promise.resolve(value)</code></strong></p>\n<p>返回一个状态由给定 value 决定的 Promise 对象。</p>\n<p>如果该值是 thenable(即，带有 then 方法的对象)，返回的 Promise 对象的最终状态由 then 方法执行决定；</p>\n<p>否则的话(<strong><code>该 value 为空，基本类型或者不带 then 方法的对象</code></strong>),返回的 Promise 对象状态为 fulfilled，并且将该 value 传递给对应的 then 方法。</p>\n<p>通常而言，如果你不知道一个值是否是 Promise 对象，使用 Promise.resolve(value) 来返回一个 Promise 对象,这样就能将该 value 以 Promise 对象形式使用。</p>\n<h2 id=\"创建-Promise\"><a href=\"#创建-Promise\" class=\"headerlink\" title=\"创建 Promise\"></a>创建 Promise</h2><p>Promise 对象是由关键字 new 及其构造函数来创建的。</p>\n<p>该构造函数会把一个叫做“处理器函数”（executor function）的函数作为它的参数。这个“处理器函数”接受两个函数——resolve 和 reject ——作为其参数。</p>\n<p><strong>一旦创建，则立即执行处理器函数</strong></p>\n<p><strong>promise 状态一旦改变则不能再变。</strong></p>\n<p>当异步任务顺利完成且返回结果值时，会调用 resolve 函数；而当异步任务失败且返回失败原因（通常是一个错误对象）时，会调用 reject 函数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const myFirstPromise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class=\"line\">  // ?做一些异步操作，最终会调用下面两者之一:</span><br><span class=\"line\">  //</span><br><span class=\"line\">  //   resolve(someValue); // fulfilled</span><br><span class=\"line\">  // ?或</span><br><span class=\"line\">  //   reject(&quot;failure reason&quot;); // rejected</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>想要某个函数?拥有 promise 功能，只需让其返回一个 promise 即可。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function myAsyncFunction(url) &#123;</span><br><span class=\"line\">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class=\"line\">    const xhr = new XMLHttpRequest();</span><br><span class=\"line\">    xhr.open(&quot;GET&quot;, url);</span><br><span class=\"line\">    xhr.onload = () =&gt; resolve(xhr.responseText);</span><br><span class=\"line\">    xhr.onerror = () =&gt; reject(xhr.statusText);</span><br><span class=\"line\">    xhr.send();</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"面试题解析\"><a href=\"#面试题解析\" class=\"headerlink\" title=\"面试题解析\"></a>面试题解析</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Promise.resolve(1)</span><br><span class=\"line\">  .then(2)</span><br><span class=\"line\">  .then(Promise.resolve(3))</span><br><span class=\"line\">  .then(console.log)</span><br><span class=\"line\"></span><br><span class=\"line\">#### 解析</span><br><span class=\"line\"></span><br><span class=\"line\">Promise.resolve 方法的参数如果是一个原始值，或者是一个不具有 then 方法的对象，则 Promise.resolve 方法返回一个新的 Promise 对象，状态为resolved，Promise.resolve 方法的参数，会同时传给回调函数。</span><br><span class=\"line\"></span><br><span class=\"line\">then 方法接受的参数是函数，而如果传递的并非是一个函数，它实际上会将其解释为 then(null)，这就会导致前一个 Promise 的结果会穿透下面。</span><br><span class=\"line\"></span><br><span class=\"line\">上面题目等于： Promise.resolve(1).then(console.log)</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 涉及eventLoop</span><br><span class=\"line\"></span><br><span class=\"line\">const promise1 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class=\"line\">  setTimeout(() =&gt; &#123;</span><br><span class=\"line\">    resolve(&apos;foo&apos;);</span><br><span class=\"line\">  &#125;, 300);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">promise1.then((value) =&gt; &#123;</span><br><span class=\"line\">  console.log(value);</span><br><span class=\"line\">  // expected output: &quot;foo&quot;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(promise1);</span><br><span class=\"line\">// expected output: [object Promise]</span><br></pre></td></tr></table></figure>\n\n"},{"title":"Babel","_content":"\n## Babel 是什么？\n\n#### Babel 是一个 JavaScript 编译器\n\nBabel 是一个工具链，主要用于将 ECMAScript 2015+ 版本的代码转换为向后兼容的 JavaScript 语法，以便能够运行在当前和旧版本的浏览器或其他环境中\n\n下面列出的是 Babel 能为你做的事情：\n\n- 语法转换\n- 通过 Polyfill 方式在目标环境中添加缺失的特性 (通过 @babel/polyfill 模块)\n- 源码转换 (codemods)\n- 更多！\n\n## 插件\n\nBabel 是一个编译器（输入源码 => 输出编译后的代码）。就像其他编译器一样，编译过程分为三个阶段：解析、转换和打印输出。\n\n现在，Babel 虽然开箱即用，但是什么动作都不做。它基本上类似于 const babel = code => code; ，将代码解析之后再输出同样的代码。如果想要 Babel 做一些实际的工作，就需要为其添加插件。\n\n除了一个一个的添加插件，你还可以以 preset 的形式启用一组插件。\n\n## 预设（Presets）\n\n不想自己动手组合插件？没问题！preset 可以作为 Babel 插件的组合，甚至可以作为可以共享的 options 配置。\n\n官方 Preset\n我们已经针对常用环境编写了一些 preset：\n\n- @babel/preset-env\n- @babel/preset-flow\n- @babel/preset-react\n- @babel/preset-typescript\n\n## 总结：\n\n我们使用 @babel/cli 从终端运行 Babel，利用 @babel/polyfill 来模拟所有新的 JavaScript 功能，而 env preset 只对我们所使用的并且目标浏览器中缺失的功能进行代码转换和加载 polyfill。\n\n## 相关\n\n[core-js@3](https://juejin.im/post/5e355be0f265da3e491a53c5)\n","source":"_drafts/Babel.md","raw":"---\ntitle: Babel\ncategories:\ntags:\n---\n\n## Babel 是什么？\n\n#### Babel 是一个 JavaScript 编译器\n\nBabel 是一个工具链，主要用于将 ECMAScript 2015+ 版本的代码转换为向后兼容的 JavaScript 语法，以便能够运行在当前和旧版本的浏览器或其他环境中\n\n下面列出的是 Babel 能为你做的事情：\n\n- 语法转换\n- 通过 Polyfill 方式在目标环境中添加缺失的特性 (通过 @babel/polyfill 模块)\n- 源码转换 (codemods)\n- 更多！\n\n## 插件\n\nBabel 是一个编译器（输入源码 => 输出编译后的代码）。就像其他编译器一样，编译过程分为三个阶段：解析、转换和打印输出。\n\n现在，Babel 虽然开箱即用，但是什么动作都不做。它基本上类似于 const babel = code => code; ，将代码解析之后再输出同样的代码。如果想要 Babel 做一些实际的工作，就需要为其添加插件。\n\n除了一个一个的添加插件，你还可以以 preset 的形式启用一组插件。\n\n## 预设（Presets）\n\n不想自己动手组合插件？没问题！preset 可以作为 Babel 插件的组合，甚至可以作为可以共享的 options 配置。\n\n官方 Preset\n我们已经针对常用环境编写了一些 preset：\n\n- @babel/preset-env\n- @babel/preset-flow\n- @babel/preset-react\n- @babel/preset-typescript\n\n## 总结：\n\n我们使用 @babel/cli 从终端运行 Babel，利用 @babel/polyfill 来模拟所有新的 JavaScript 功能，而 env preset 只对我们所使用的并且目标浏览器中缺失的功能进行代码转换和加载 polyfill。\n\n## 相关\n\n[core-js@3](https://juejin.im/post/5e355be0f265da3e491a53c5)\n","slug":"Babel","published":0,"date":"2019-10-28T01:41:02.219Z","updated":"2020-03-03T03:34:41.294Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckb1z4dez00059n94cn9ge2o8","content":"<h2 id=\"Babel-是什么？\"><a href=\"#Babel-是什么？\" class=\"headerlink\" title=\"Babel 是什么？\"></a>Babel 是什么？</h2><h4 id=\"Babel-是一个-JavaScript-编译器\"><a href=\"#Babel-是一个-JavaScript-编译器\" class=\"headerlink\" title=\"Babel 是一个 JavaScript 编译器\"></a>Babel 是一个 JavaScript 编译器</h4><p>Babel 是一个工具链，主要用于将 ECMAScript 2015+ 版本的代码转换为向后兼容的 JavaScript 语法，以便能够运行在当前和旧版本的浏览器或其他环境中</p>\n<p>下面列出的是 Babel 能为你做的事情：</p>\n<ul>\n<li>语法转换</li>\n<li>通过 Polyfill 方式在目标环境中添加缺失的特性 (通过 @babel/polyfill 模块)</li>\n<li>源码转换 (codemods)</li>\n<li>更多！</li>\n</ul>\n<h2 id=\"插件\"><a href=\"#插件\" class=\"headerlink\" title=\"插件\"></a>插件</h2><p>Babel 是一个编译器（输入源码 =&gt; 输出编译后的代码）。就像其他编译器一样，编译过程分为三个阶段：解析、转换和打印输出。</p>\n<p>现在，Babel 虽然开箱即用，但是什么动作都不做。它基本上类似于 const babel = code =&gt; code; ，将代码解析之后再输出同样的代码。如果想要 Babel 做一些实际的工作，就需要为其添加插件。</p>\n<p>除了一个一个的添加插件，你还可以以 preset 的形式启用一组插件。</p>\n<h2 id=\"预设（Presets）\"><a href=\"#预设（Presets）\" class=\"headerlink\" title=\"预设（Presets）\"></a>预设（Presets）</h2><p>不想自己动手组合插件？没问题！preset 可以作为 Babel 插件的组合，甚至可以作为可以共享的 options 配置。</p>\n<p>官方 Preset<br>我们已经针对常用环境编写了一些 preset：</p>\n<ul>\n<li>@babel/preset-env</li>\n<li>@babel/preset-flow</li>\n<li>@babel/preset-react</li>\n<li>@babel/preset-typescript</li>\n</ul>\n<h2 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h2><p>我们使用 @babel/cli 从终端运行 Babel，利用 @babel/polyfill 来模拟所有新的 JavaScript 功能，而 env preset 只对我们所使用的并且目标浏览器中缺失的功能进行代码转换和加载 polyfill。</p>\n<h2 id=\"相关\"><a href=\"#相关\" class=\"headerlink\" title=\"相关\"></a>相关</h2><p><a href=\"https://juejin.im/post/5e355be0f265da3e491a53c5\" target=\"_blank\" rel=\"noopener\">core-js@3</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Babel-是什么？\"><a href=\"#Babel-是什么？\" class=\"headerlink\" title=\"Babel 是什么？\"></a>Babel 是什么？</h2><h4 id=\"Babel-是一个-JavaScript-编译器\"><a href=\"#Babel-是一个-JavaScript-编译器\" class=\"headerlink\" title=\"Babel 是一个 JavaScript 编译器\"></a>Babel 是一个 JavaScript 编译器</h4><p>Babel 是一个工具链，主要用于将 ECMAScript 2015+ 版本的代码转换为向后兼容的 JavaScript 语法，以便能够运行在当前和旧版本的浏览器或其他环境中</p>\n<p>下面列出的是 Babel 能为你做的事情：</p>\n<ul>\n<li>语法转换</li>\n<li>通过 Polyfill 方式在目标环境中添加缺失的特性 (通过 @babel/polyfill 模块)</li>\n<li>源码转换 (codemods)</li>\n<li>更多！</li>\n</ul>\n<h2 id=\"插件\"><a href=\"#插件\" class=\"headerlink\" title=\"插件\"></a>插件</h2><p>Babel 是一个编译器（输入源码 =&gt; 输出编译后的代码）。就像其他编译器一样，编译过程分为三个阶段：解析、转换和打印输出。</p>\n<p>现在，Babel 虽然开箱即用，但是什么动作都不做。它基本上类似于 const babel = code =&gt; code; ，将代码解析之后再输出同样的代码。如果想要 Babel 做一些实际的工作，就需要为其添加插件。</p>\n<p>除了一个一个的添加插件，你还可以以 preset 的形式启用一组插件。</p>\n<h2 id=\"预设（Presets）\"><a href=\"#预设（Presets）\" class=\"headerlink\" title=\"预设（Presets）\"></a>预设（Presets）</h2><p>不想自己动手组合插件？没问题！preset 可以作为 Babel 插件的组合，甚至可以作为可以共享的 options 配置。</p>\n<p>官方 Preset<br>我们已经针对常用环境编写了一些 preset：</p>\n<ul>\n<li>@babel/preset-env</li>\n<li>@babel/preset-flow</li>\n<li>@babel/preset-react</li>\n<li>@babel/preset-typescript</li>\n</ul>\n<h2 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h2><p>我们使用 @babel/cli 从终端运行 Babel，利用 @babel/polyfill 来模拟所有新的 JavaScript 功能，而 env preset 只对我们所使用的并且目标浏览器中缺失的功能进行代码转换和加载 polyfill。</p>\n<h2 id=\"相关\"><a href=\"#相关\" class=\"headerlink\" title=\"相关\"></a>相关</h2><p><a href=\"https://juejin.im/post/5e355be0f265da3e491a53c5\" target=\"_blank\" rel=\"noopener\">core-js@3</a></p>\n"},{"title":"Math 对象","_content":"","source":"_drafts/Math 对象.md","raw":"---\ntitle: Math 对象\ncategories:\ntags:\n---\n","slug":"Math-对象","published":0,"date":"2020-03-03T08:04:14.952Z","updated":"2020-03-03T08:04:40.970Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckb1z4df100069n94cpntdq5a","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"REM","_content":"\n#### rem\n\nrem 是根据 rootvalue 去设置\n","source":"_drafts/Rem.md","raw":"---\ntitle: REM\ncategories:\ntags:\n---\n\n#### rem\n\nrem 是根据 rootvalue 去设置\n","slug":"Rem","published":0,"date":"2020-01-15T07:08:26.707Z","updated":"2020-01-15T07:09:09.701Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckb1z4df200079n94cer9u2ck","content":"<h4 id=\"rem\"><a href=\"#rem\" class=\"headerlink\" title=\"rem\"></a>rem</h4><p>rem 是根据 rootvalue 去设置</p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"rem\"><a href=\"#rem\" class=\"headerlink\" title=\"rem\"></a>rem</h4><p>rem 是根据 rootvalue 去设置</p>\n"},{"title":"Redux 。","_content":"\n## 设计思想\n\nRedux 的设计思想很简单，就两句话。\n\n1. Web 应用是一个状态机，视图与状态是一一对应的。\n\n2. 所有的状态，保存在一个对象里面。\n\n## 基本概念和 API\n","source":"_drafts/Redux.md","raw":"---\ntitle: Redux 。\ncategories:\ntags:\n---\n\n## 设计思想\n\nRedux 的设计思想很简单，就两句话。\n\n1. Web 应用是一个状态机，视图与状态是一一对应的。\n\n2. 所有的状态，保存在一个对象里面。\n\n## 基本概念和 API\n","slug":"Redux","published":0,"date":"2019-10-21T02:39:07.004Z","updated":"2019-11-13T06:19:46.378Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckb1z4df300089n94uuna7mgw","content":"<h2 id=\"设计思想\"><a href=\"#设计思想\" class=\"headerlink\" title=\"设计思想\"></a>设计思想</h2><p>Redux 的设计思想很简单，就两句话。</p>\n<ol>\n<li><p>Web 应用是一个状态机，视图与状态是一一对应的。</p>\n</li>\n<li><p>所有的状态，保存在一个对象里面。</p>\n</li>\n</ol>\n<h2 id=\"基本概念和-API\"><a href=\"#基本概念和-API\" class=\"headerlink\" title=\"基本概念和 API\"></a>基本概念和 API</h2>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"设计思想\"><a href=\"#设计思想\" class=\"headerlink\" title=\"设计思想\"></a>设计思想</h2><p>Redux 的设计思想很简单，就两句话。</p>\n<ol>\n<li><p>Web 应用是一个状态机，视图与状态是一一对应的。</p>\n</li>\n<li><p>所有的状态，保存在一个对象里面。</p>\n</li>\n</ol>\n<h2 id=\"基本概念和-API\"><a href=\"#基本概念和-API\" class=\"headerlink\" title=\"基本概念和 API\"></a>基本概念和 API</h2>"},{"title":"React","_content":"\n#### sass 和 less\n\n`npm init react-app xxx`\n默认安装 sass,如果需要使用 less,则需要另外安装\n\n#### styled-jsx && styled-jsx-plugin-less || style-jsx-plugin-sass\n\n个人建议使用 styled-jsx 处理 css\n\n遇到的问题:\n\n```\n// npm init react-app xxx 直接使用styled-jsx就会出现这个问题。如果恢复webpack配置，npm run eject 则不会出现这个bug,暂时还不知道什么原因\n\nindex.js:1 Warning: Received `true` for a non-boolean attribute `jsx`.\n\nIf you want to write it to the DOM, pass a string instead: jsx=\"true\" or jsx={value.toString()}.\n    in style (at App.js:25)\n    in App (at src/index.js:7)\n```\n\n[https://stackoverflow.com/questions/57261540/warning-received-true-for-a-non-boolean-attribute-jsx-zeit-styled-jsx](https://stackoverflow.com/questions/57261540/warning-received-true-for-a-non-boolean-attribute-jsx-zeit-styled-jsx)\n\n#### 文件目录\n\n好像不能 import src 之外的文件夹\n\n[https://stackoverflow.com/questions/44114436/the-create-react-app-imports-restriction-outside-of-src-directory?noredirect=1](https://stackoverflow.com/questions/44114436/the-create-react-app-imports-restriction-outside-of-src-directory?noredirect=1)\n\n#### 按需加载\n\n[https://github.com/ant-design/ant-design-mobile/issues/3094](https://github.com/ant-design/ant-design-mobile/issues/3094)\n\n#### hooks 表单\n\n`npm install react-hook-form`\n\n#### react 组件\n\n[https://juejin.im/entry/59a4eca4f265da24951798a5](https://juejin.im/entry/59a4eca4f265da24951798a5)\n","source":"_drafts/React.md","raw":"---\ntitle: React\ncategories:\ntags:\n---\n\n#### sass 和 less\n\n`npm init react-app xxx`\n默认安装 sass,如果需要使用 less,则需要另外安装\n\n#### styled-jsx && styled-jsx-plugin-less || style-jsx-plugin-sass\n\n个人建议使用 styled-jsx 处理 css\n\n遇到的问题:\n\n```\n// npm init react-app xxx 直接使用styled-jsx就会出现这个问题。如果恢复webpack配置，npm run eject 则不会出现这个bug,暂时还不知道什么原因\n\nindex.js:1 Warning: Received `true` for a non-boolean attribute `jsx`.\n\nIf you want to write it to the DOM, pass a string instead: jsx=\"true\" or jsx={value.toString()}.\n    in style (at App.js:25)\n    in App (at src/index.js:7)\n```\n\n[https://stackoverflow.com/questions/57261540/warning-received-true-for-a-non-boolean-attribute-jsx-zeit-styled-jsx](https://stackoverflow.com/questions/57261540/warning-received-true-for-a-non-boolean-attribute-jsx-zeit-styled-jsx)\n\n#### 文件目录\n\n好像不能 import src 之外的文件夹\n\n[https://stackoverflow.com/questions/44114436/the-create-react-app-imports-restriction-outside-of-src-directory?noredirect=1](https://stackoverflow.com/questions/44114436/the-create-react-app-imports-restriction-outside-of-src-directory?noredirect=1)\n\n#### 按需加载\n\n[https://github.com/ant-design/ant-design-mobile/issues/3094](https://github.com/ant-design/ant-design-mobile/issues/3094)\n\n#### hooks 表单\n\n`npm install react-hook-form`\n\n#### react 组件\n\n[https://juejin.im/entry/59a4eca4f265da24951798a5](https://juejin.im/entry/59a4eca4f265da24951798a5)\n","slug":"React","published":0,"date":"2020-01-03T08:09:03.008Z","updated":"2020-01-08T02:37:31.642Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckb1z4df400099n94wzx2rz3b","content":"<h4 id=\"sass-和-less\"><a href=\"#sass-和-less\" class=\"headerlink\" title=\"sass 和 less\"></a>sass 和 less</h4><p><code>npm init react-app xxx</code><br>默认安装 sass,如果需要使用 less,则需要另外安装</p>\n<h4 id=\"styled-jsx-amp-amp-styled-jsx-plugin-less-style-jsx-plugin-sass\"><a href=\"#styled-jsx-amp-amp-styled-jsx-plugin-less-style-jsx-plugin-sass\" class=\"headerlink\" title=\"styled-jsx &amp;&amp; styled-jsx-plugin-less || style-jsx-plugin-sass\"></a>styled-jsx &amp;&amp; styled-jsx-plugin-less || style-jsx-plugin-sass</h4><p>个人建议使用 styled-jsx 处理 css</p>\n<p>遇到的问题:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// npm init react-app xxx 直接使用styled-jsx就会出现这个问题。如果恢复webpack配置，npm run eject 则不会出现这个bug,暂时还不知道什么原因</span><br><span class=\"line\"></span><br><span class=\"line\">index.js:1 Warning: Received `true` for a non-boolean attribute `jsx`.</span><br><span class=\"line\"></span><br><span class=\"line\">If you want to write it to the DOM, pass a string instead: jsx=&quot;true&quot; or jsx=&#123;value.toString()&#125;.</span><br><span class=\"line\">    in style (at App.js:25)</span><br><span class=\"line\">    in App (at src/index.js:7)</span><br></pre></td></tr></table></figure>\n\n<p><a href=\"https://stackoverflow.com/questions/57261540/warning-received-true-for-a-non-boolean-attribute-jsx-zeit-styled-jsx\" target=\"_blank\" rel=\"noopener\">https://stackoverflow.com/questions/57261540/warning-received-true-for-a-non-boolean-attribute-jsx-zeit-styled-jsx</a></p>\n<h4 id=\"文件目录\"><a href=\"#文件目录\" class=\"headerlink\" title=\"文件目录\"></a>文件目录</h4><p>好像不能 import src 之外的文件夹</p>\n<p><a href=\"https://stackoverflow.com/questions/44114436/the-create-react-app-imports-restriction-outside-of-src-directory?noredirect=1\" target=\"_blank\" rel=\"noopener\">https://stackoverflow.com/questions/44114436/the-create-react-app-imports-restriction-outside-of-src-directory?noredirect=1</a></p>\n<h4 id=\"按需加载\"><a href=\"#按需加载\" class=\"headerlink\" title=\"按需加载\"></a>按需加载</h4><p><a href=\"https://github.com/ant-design/ant-design-mobile/issues/3094\" target=\"_blank\" rel=\"noopener\">https://github.com/ant-design/ant-design-mobile/issues/3094</a></p>\n<h4 id=\"hooks-表单\"><a href=\"#hooks-表单\" class=\"headerlink\" title=\"hooks 表单\"></a>hooks 表单</h4><p><code>npm install react-hook-form</code></p>\n<h4 id=\"react-组件\"><a href=\"#react-组件\" class=\"headerlink\" title=\"react 组件\"></a>react 组件</h4><p><a href=\"https://juejin.im/entry/59a4eca4f265da24951798a5\" target=\"_blank\" rel=\"noopener\">https://juejin.im/entry/59a4eca4f265da24951798a5</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"sass-和-less\"><a href=\"#sass-和-less\" class=\"headerlink\" title=\"sass 和 less\"></a>sass 和 less</h4><p><code>npm init react-app xxx</code><br>默认安装 sass,如果需要使用 less,则需要另外安装</p>\n<h4 id=\"styled-jsx-amp-amp-styled-jsx-plugin-less-style-jsx-plugin-sass\"><a href=\"#styled-jsx-amp-amp-styled-jsx-plugin-less-style-jsx-plugin-sass\" class=\"headerlink\" title=\"styled-jsx &amp;&amp; styled-jsx-plugin-less || style-jsx-plugin-sass\"></a>styled-jsx &amp;&amp; styled-jsx-plugin-less || style-jsx-plugin-sass</h4><p>个人建议使用 styled-jsx 处理 css</p>\n<p>遇到的问题:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// npm init react-app xxx 直接使用styled-jsx就会出现这个问题。如果恢复webpack配置，npm run eject 则不会出现这个bug,暂时还不知道什么原因</span><br><span class=\"line\"></span><br><span class=\"line\">index.js:1 Warning: Received `true` for a non-boolean attribute `jsx`.</span><br><span class=\"line\"></span><br><span class=\"line\">If you want to write it to the DOM, pass a string instead: jsx=&quot;true&quot; or jsx=&#123;value.toString()&#125;.</span><br><span class=\"line\">    in style (at App.js:25)</span><br><span class=\"line\">    in App (at src/index.js:7)</span><br></pre></td></tr></table></figure>\n\n<p><a href=\"https://stackoverflow.com/questions/57261540/warning-received-true-for-a-non-boolean-attribute-jsx-zeit-styled-jsx\" target=\"_blank\" rel=\"noopener\">https://stackoverflow.com/questions/57261540/warning-received-true-for-a-non-boolean-attribute-jsx-zeit-styled-jsx</a></p>\n<h4 id=\"文件目录\"><a href=\"#文件目录\" class=\"headerlink\" title=\"文件目录\"></a>文件目录</h4><p>好像不能 import src 之外的文件夹</p>\n<p><a href=\"https://stackoverflow.com/questions/44114436/the-create-react-app-imports-restriction-outside-of-src-directory?noredirect=1\" target=\"_blank\" rel=\"noopener\">https://stackoverflow.com/questions/44114436/the-create-react-app-imports-restriction-outside-of-src-directory?noredirect=1</a></p>\n<h4 id=\"按需加载\"><a href=\"#按需加载\" class=\"headerlink\" title=\"按需加载\"></a>按需加载</h4><p><a href=\"https://github.com/ant-design/ant-design-mobile/issues/3094\" target=\"_blank\" rel=\"noopener\">https://github.com/ant-design/ant-design-mobile/issues/3094</a></p>\n<h4 id=\"hooks-表单\"><a href=\"#hooks-表单\" class=\"headerlink\" title=\"hooks 表单\"></a>hooks 表单</h4><p><code>npm install react-hook-form</code></p>\n<h4 id=\"react-组件\"><a href=\"#react-组件\" class=\"headerlink\" title=\"react 组件\"></a>react 组件</h4><p><a href=\"https://juejin.im/entry/59a4eca4f265da24951798a5\" target=\"_blank\" rel=\"noopener\">https://juejin.im/entry/59a4eca4f265da24951798a5</a></p>\n"},{"title":"Service workers","_content":"","source":"_drafts/Service-workers.md","raw":"---\ntitle: Service workers\ncategories:\ntags:\n---\n","slug":"Service-workers","published":0,"date":"2019-10-23T02:32:35.970Z","updated":"2019-10-23T02:32:35.971Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckb1z4df5000a9n940sm2ugky","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Yarn","_content":"","source":"_drafts/Yarn.md","raw":"---\ntitle: Yarn\ncategories:\ntags:\n---\n","slug":"Yarn","published":0,"date":"2020-01-21T07:10:56.255Z","updated":"2020-01-21T07:10:56.255Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckb1z4df6000b9n94rotjd1kj","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Vue 组件库","_content":"\n## UMD (Universal Module Definition),\n\n希望提供一个前后端跨平台的解决方案(支持 AMD 与 CommonJS 模块方式)。\n\nUMD 的实现很简单：\n\n- 先判断是否支持 Node.js 模块格式（exports 是否存在），存在则使用 Node.js 模块格式。\n- 再判断是否支持 AMD（define 是否存在），存在则使用 AMD 方式加载模块。\n- 前两个都不存在，则将模块公开到全局（window 或 global）。\n\n`\n// if the module has no dependencies, the above pattern can be simplified to\n(function (root, factory) {\nif (typeof define === 'function' && define.amd) {\n// AMD. Register as an anonymous module.\ndefine([], factory);\n} else if (typeof exports === 'object') {\n// Node. Does not work with strict CommonJS, but\n// only CommonJS-like environments that support module.exports,\n// like Node.\nmodule.exports = factory();\n} else {\n// Browser globals (root is window)\nroot.returnExports = factory();\n}\n}(this, function () {\n\n    // Just return a value to define the module export.\n    // This example returns an object, but the module\n    // can return a function as the exported value.\n    return {};\n\n}));\n`\n","source":"_drafts/Vue-组件库.md","raw":"---\ntitle: Vue 组件库\ncategories:\ntags:\n---\n\n## UMD (Universal Module Definition),\n\n希望提供一个前后端跨平台的解决方案(支持 AMD 与 CommonJS 模块方式)。\n\nUMD 的实现很简单：\n\n- 先判断是否支持 Node.js 模块格式（exports 是否存在），存在则使用 Node.js 模块格式。\n- 再判断是否支持 AMD（define 是否存在），存在则使用 AMD 方式加载模块。\n- 前两个都不存在，则将模块公开到全局（window 或 global）。\n\n`\n// if the module has no dependencies, the above pattern can be simplified to\n(function (root, factory) {\nif (typeof define === 'function' && define.amd) {\n// AMD. Register as an anonymous module.\ndefine([], factory);\n} else if (typeof exports === 'object') {\n// Node. Does not work with strict CommonJS, but\n// only CommonJS-like environments that support module.exports,\n// like Node.\nmodule.exports = factory();\n} else {\n// Browser globals (root is window)\nroot.returnExports = factory();\n}\n}(this, function () {\n\n    // Just return a value to define the module export.\n    // This example returns an object, but the module\n    // can return a function as the exported value.\n    return {};\n\n}));\n`\n","slug":"Vue-组件库","published":0,"date":"2020-01-14T08:48:10.383Z","updated":"2020-01-14T08:54:52.805Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckb1z4df7000c9n94a6rsv1l7","content":"<h2 id=\"UMD-Universal-Module-Definition\"><a href=\"#UMD-Universal-Module-Definition\" class=\"headerlink\" title=\"UMD (Universal Module Definition),\"></a>UMD (Universal Module Definition),</h2><p>希望提供一个前后端跨平台的解决方案(支持 AMD 与 CommonJS 模块方式)。</p>\n<p>UMD 的实现很简单：</p>\n<ul>\n<li>先判断是否支持 Node.js 模块格式（exports 是否存在），存在则使用 Node.js 模块格式。</li>\n<li>再判断是否支持 AMD（define 是否存在），存在则使用 AMD 方式加载模块。</li>\n<li>前两个都不存在，则将模块公开到全局（window 或 global）。</li>\n</ul>\n<p>`<br>// if the module has no dependencies, the above pattern can be simplified to<br>(function (root, factory) {<br>if (typeof define === ‘function’ &amp;&amp; define.amd) {<br>// AMD. Register as an anonymous module.<br>define([], factory);<br>} else if (typeof exports === ‘object’) {<br>// Node. Does not work with strict CommonJS, but<br>// only CommonJS-like environments that support module.exports,<br>// like Node.<br>module.exports = factory();<br>} else {<br>// Browser globals (root is window)<br>root.returnExports = factory();<br>}<br>}(this, function () {</p>\n<pre><code>// Just return a value to define the module export.\n// This example returns an object, but the module\n// can return a function as the exported value.\nreturn {};</code></pre><p>}));<br>`</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"UMD-Universal-Module-Definition\"><a href=\"#UMD-Universal-Module-Definition\" class=\"headerlink\" title=\"UMD (Universal Module Definition),\"></a>UMD (Universal Module Definition),</h2><p>希望提供一个前后端跨平台的解决方案(支持 AMD 与 CommonJS 模块方式)。</p>\n<p>UMD 的实现很简单：</p>\n<ul>\n<li>先判断是否支持 Node.js 模块格式（exports 是否存在），存在则使用 Node.js 模块格式。</li>\n<li>再判断是否支持 AMD（define 是否存在），存在则使用 AMD 方式加载模块。</li>\n<li>前两个都不存在，则将模块公开到全局（window 或 global）。</li>\n</ul>\n<p>`<br>// if the module has no dependencies, the above pattern can be simplified to<br>(function (root, factory) {<br>if (typeof define === ‘function’ &amp;&amp; define.amd) {<br>// AMD. Register as an anonymous module.<br>define([], factory);<br>} else if (typeof exports === ‘object’) {<br>// Node. Does not work with strict CommonJS, but<br>// only CommonJS-like environments that support module.exports,<br>// like Node.<br>module.exports = factory();<br>} else {<br>// Browser globals (root is window)<br>root.returnExports = factory();<br>}<br>}(this, function () {</p>\n<pre><code>// Just return a value to define the module export.\n// This example returns an object, but the module\n// can return a function as the exported value.\nreturn {};</code></pre><p>}));<br>`</p>\n"},{"title":"async await、Promise、setTimeout执行顺序","_content":"\n**同步代码(包括 promise 的构造函数) -> promise.then -> setTimeout**\n\n```\nasync function async1(){\n   console.log('async1 start');\n    await async2();\n    console.log('async1 end')\n}\nasync function async2(){\n    console.log('async2')\n}\nconsole.log('script start');\nsetTimeout(function(){\n    console.log('setTimeout')\n},0);\nasync1();\nnew Promise(function(resolve){\n    console.log('promise1');\n    resolve();\n}).then(function(){\n    console.log('promise2')\n});\nconsole.log('script end')\n```\n\n```\n解析：\nconsole.log('script start');\nconsole.log('async1 start');\nconsole.log('async2')\nconsole.log('promise1');\nconsole.log('async1 end')\nconsole.log('script end')\nconsole.log('promise2')\n console.log('setTimeout')\n\n```\n","source":"_drafts/async-await、Promise、setTimeout执行顺序.md","raw":"---\ntitle: async await、Promise、setTimeout执行顺序\ncategories:\ntags:\n  - javascript\n---\n\n**同步代码(包括 promise 的构造函数) -> promise.then -> setTimeout**\n\n```\nasync function async1(){\n   console.log('async1 start');\n    await async2();\n    console.log('async1 end')\n}\nasync function async2(){\n    console.log('async2')\n}\nconsole.log('script start');\nsetTimeout(function(){\n    console.log('setTimeout')\n},0);\nasync1();\nnew Promise(function(resolve){\n    console.log('promise1');\n    resolve();\n}).then(function(){\n    console.log('promise2')\n});\nconsole.log('script end')\n```\n\n```\n解析：\nconsole.log('script start');\nconsole.log('async1 start');\nconsole.log('async2')\nconsole.log('promise1');\nconsole.log('async1 end')\nconsole.log('script end')\nconsole.log('promise2')\n console.log('setTimeout')\n\n```\n","slug":"async-await、Promise、setTimeout执行顺序","published":0,"date":"2019-09-09T02:29:57.472Z","updated":"2019-10-14T09:09:45.892Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckb1z4df8000d9n94y971h3q4","content":"<p><strong>同步代码(包括 promise 的构造函数) -&gt; promise.then -&gt; setTimeout</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">async function async1()&#123;</span><br><span class=\"line\">   console.log(&apos;async1 start&apos;);</span><br><span class=\"line\">    await async2();</span><br><span class=\"line\">    console.log(&apos;async1 end&apos;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">async function async2()&#123;</span><br><span class=\"line\">    console.log(&apos;async2&apos;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(&apos;script start&apos;);</span><br><span class=\"line\">setTimeout(function()&#123;</span><br><span class=\"line\">    console.log(&apos;setTimeout&apos;)</span><br><span class=\"line\">&#125;,0);</span><br><span class=\"line\">async1();</span><br><span class=\"line\">new Promise(function(resolve)&#123;</span><br><span class=\"line\">    console.log(&apos;promise1&apos;);</span><br><span class=\"line\">    resolve();</span><br><span class=\"line\">&#125;).then(function()&#123;</span><br><span class=\"line\">    console.log(&apos;promise2&apos;)</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">console.log(&apos;script end&apos;)</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">解析：</span><br><span class=\"line\">console.log(&apos;script start&apos;);</span><br><span class=\"line\">console.log(&apos;async1 start&apos;);</span><br><span class=\"line\">console.log(&apos;async2&apos;)</span><br><span class=\"line\">console.log(&apos;promise1&apos;);</span><br><span class=\"line\">console.log(&apos;async1 end&apos;)</span><br><span class=\"line\">console.log(&apos;script end&apos;)</span><br><span class=\"line\">console.log(&apos;promise2&apos;)</span><br><span class=\"line\"> console.log(&apos;setTimeout&apos;)</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<p><strong>同步代码(包括 promise 的构造函数) -&gt; promise.then -&gt; setTimeout</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">async function async1()&#123;</span><br><span class=\"line\">   console.log(&apos;async1 start&apos;);</span><br><span class=\"line\">    await async2();</span><br><span class=\"line\">    console.log(&apos;async1 end&apos;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">async function async2()&#123;</span><br><span class=\"line\">    console.log(&apos;async2&apos;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(&apos;script start&apos;);</span><br><span class=\"line\">setTimeout(function()&#123;</span><br><span class=\"line\">    console.log(&apos;setTimeout&apos;)</span><br><span class=\"line\">&#125;,0);</span><br><span class=\"line\">async1();</span><br><span class=\"line\">new Promise(function(resolve)&#123;</span><br><span class=\"line\">    console.log(&apos;promise1&apos;);</span><br><span class=\"line\">    resolve();</span><br><span class=\"line\">&#125;).then(function()&#123;</span><br><span class=\"line\">    console.log(&apos;promise2&apos;)</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">console.log(&apos;script end&apos;)</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">解析：</span><br><span class=\"line\">console.log(&apos;script start&apos;);</span><br><span class=\"line\">console.log(&apos;async1 start&apos;);</span><br><span class=\"line\">console.log(&apos;async2&apos;)</span><br><span class=\"line\">console.log(&apos;promise1&apos;);</span><br><span class=\"line\">console.log(&apos;async1 end&apos;)</span><br><span class=\"line\">console.log(&apos;script end&apos;)</span><br><span class=\"line\">console.log(&apos;promise2&apos;)</span><br><span class=\"line\"> console.log(&apos;setTimeout&apos;)</span><br></pre></td></tr></table></figure>\n\n"},{"title":"V8 引擎","_content":"\n\nV8是一个非常复杂的项目，使用cloc统计可知，它竟然有超过100万行C++代码。\n\nV8由许多子模块构成，其中这4个模块是最重要的：\n\n1. Parser：负责将JavaScript源码转换为Abstract Syntax Tree (AST)\n2. Ignition：interpreter，即解释器，负责将AST转换为Bytecode，解释执行Bytecode；同时收集TurboFan优化编译所需的信息，比如函数参数的类型；\n3. TurboFan：compiler，即编译器，利用Ignitio所收集的类型信息，将Bytecode转换为优化的汇编代码；\n4. Orinoco：garbage collector，垃圾回收模块，负责将程序不再需要的内存空间回收；\n\n\n简单地说，Parser将JS源码转换为AST，然后Ignition将AST转换为Bytecode，最后TurboFan将Bytecode转换为经过优化的Machine Code(实际上是汇编代码)。\n\n## 相关阅读\n\n[V8引擎](https://blog.fundebug.com/2019/07/16/how-does-v8-work/)\n[js 引擎](https://kknews.cc/code/k26r26v.html)\nhttps://blog.csdn.net/IamChuancey/article/details/78453269\n","source":"_drafts/V8-引擎.md","raw":"---\ntitle: V8 引擎\ncategories:\ntags:\n---\n\n\nV8是一个非常复杂的项目，使用cloc统计可知，它竟然有超过100万行C++代码。\n\nV8由许多子模块构成，其中这4个模块是最重要的：\n\n1. Parser：负责将JavaScript源码转换为Abstract Syntax Tree (AST)\n2. Ignition：interpreter，即解释器，负责将AST转换为Bytecode，解释执行Bytecode；同时收集TurboFan优化编译所需的信息，比如函数参数的类型；\n3. TurboFan：compiler，即编译器，利用Ignitio所收集的类型信息，将Bytecode转换为优化的汇编代码；\n4. Orinoco：garbage collector，垃圾回收模块，负责将程序不再需要的内存空间回收；\n\n\n简单地说，Parser将JS源码转换为AST，然后Ignition将AST转换为Bytecode，最后TurboFan将Bytecode转换为经过优化的Machine Code(实际上是汇编代码)。\n\n## 相关阅读\n\n[V8引擎](https://blog.fundebug.com/2019/07/16/how-does-v8-work/)\n[js 引擎](https://kknews.cc/code/k26r26v.html)\nhttps://blog.csdn.net/IamChuancey/article/details/78453269\n","slug":"V8-引擎","published":0,"date":"2020-05-26T02:27:33.967Z","updated":"2020-05-26T03:59:26.682Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckb1z4df9000e9n94slmvit21","content":"<p>V8是一个非常复杂的项目，使用cloc统计可知，它竟然有超过100万行C++代码。</p>\n<p>V8由许多子模块构成，其中这4个模块是最重要的：</p>\n<ol>\n<li>Parser：负责将JavaScript源码转换为Abstract Syntax Tree (AST)</li>\n<li>Ignition：interpreter，即解释器，负责将AST转换为Bytecode，解释执行Bytecode；同时收集TurboFan优化编译所需的信息，比如函数参数的类型；</li>\n<li>TurboFan：compiler，即编译器，利用Ignitio所收集的类型信息，将Bytecode转换为优化的汇编代码；</li>\n<li>Orinoco：garbage collector，垃圾回收模块，负责将程序不再需要的内存空间回收；</li>\n</ol>\n<p>简单地说，Parser将JS源码转换为AST，然后Ignition将AST转换为Bytecode，最后TurboFan将Bytecode转换为经过优化的Machine Code(实际上是汇编代码)。</p>\n<h2 id=\"相关阅读\"><a href=\"#相关阅读\" class=\"headerlink\" title=\"相关阅读\"></a>相关阅读</h2><p><a href=\"https://blog.fundebug.com/2019/07/16/how-does-v8-work/\" target=\"_blank\" rel=\"noopener\">V8引擎</a><br><a href=\"https://kknews.cc/code/k26r26v.html\" target=\"_blank\" rel=\"noopener\">js 引擎</a><br><a href=\"https://blog.csdn.net/IamChuancey/article/details/78453269\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/IamChuancey/article/details/78453269</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>V8是一个非常复杂的项目，使用cloc统计可知，它竟然有超过100万行C++代码。</p>\n<p>V8由许多子模块构成，其中这4个模块是最重要的：</p>\n<ol>\n<li>Parser：负责将JavaScript源码转换为Abstract Syntax Tree (AST)</li>\n<li>Ignition：interpreter，即解释器，负责将AST转换为Bytecode，解释执行Bytecode；同时收集TurboFan优化编译所需的信息，比如函数参数的类型；</li>\n<li>TurboFan：compiler，即编译器，利用Ignitio所收集的类型信息，将Bytecode转换为优化的汇编代码；</li>\n<li>Orinoco：garbage collector，垃圾回收模块，负责将程序不再需要的内存空间回收；</li>\n</ol>\n<p>简单地说，Parser将JS源码转换为AST，然后Ignition将AST转换为Bytecode，最后TurboFan将Bytecode转换为经过优化的Machine Code(实际上是汇编代码)。</p>\n<h2 id=\"相关阅读\"><a href=\"#相关阅读\" class=\"headerlink\" title=\"相关阅读\"></a>相关阅读</h2><p><a href=\"https://blog.fundebug.com/2019/07/16/how-does-v8-work/\" target=\"_blank\" rel=\"noopener\">V8引擎</a><br><a href=\"https://kknews.cc/code/k26r26v.html\" target=\"_blank\" rel=\"noopener\">js 引擎</a><br><a href=\"https://blog.csdn.net/IamChuancey/article/details/78453269\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/IamChuancey/article/details/78453269</a></p>\n"},{"title":"eslint","_content":"\n## Eslint\n\n**eslint 相关的文件在根目录下 `.editorconfig` `.eslintignore` `.eslintrc.js`**\n\n`.editorconfig`： xxx 文件\n`.eslintignore`： eslint 忽略校验的配置文件\n`.eslintrc.js`： eslint 关键的配置文件\n\n## 配置根目录下的`.editorconfig`文件\n\n[https://editorconfig.org/](https://editorconfig.org/)\n\n```\n\nroot = true\n\n[*]\ncharset = utf-8\nend_of_line = lf\nindent_size = 2\nindent_style = space\ninsert_final_newline = true\nmax_line_length = 80\ntrim_trailing_whitespace = true\n\n[*.md]\nmax_line_length = 0\ntrim_trailing_whitespace = false\n```\n\n## 配置根目录下的`.eslintignore`文件\n\n```\ndist\nnode_modules\n```\n\n## 配置根目录下的`.eslintrc.js`文件\n\n```\nmodule.exports = {\n  root: true,\n  // vue 里面\n  parser: \"vue-eslint-parser\",\n  env: {\n    es6: true,\n    browser: true,\n    node: true\n  },\n  // parserOptions来指定语言版本为和模块类型\n  parserOptions: {\n    parser: \"babel-eslint\",\n    //  ecm版本\n    ecmaVersion: 6,\n    // 模块类型sourceType为module，如此便支持export和import来导出并引用文件\n    sourceType: \"module\",\n    ecmaFeatures: {\n      jsx: true,\n      modules: true,\n      experimentalObjectRestSpread: true\n    }\n  },\n  globals: {\n  },\n  extends: \"eslint:recommended\",\n  // vue:  extends: \"plugin:vue-libs/recommended\",\"@vue/typescript\",\"eslint:recommended\"\n  // required to lint *.vue files\n  plugins: [\"html\"],\n  // add your custom rules here\n  rules: {\n    \"no-console\": \"off\"\n  }\n};\n\n```\n\n##### 文章参考\n\n[https://larrylu.blog/improve-code-quality-using-eslint-742cf1f384f1](https://larrylu.blog/improve-code-quality-using-eslint-742cf1f384f1)\n","source":"_drafts/eslint.md","raw":"---\ntitle: eslint\ncategories:\ntags:\n  - eslint\n---\n\n## Eslint\n\n**eslint 相关的文件在根目录下 `.editorconfig` `.eslintignore` `.eslintrc.js`**\n\n`.editorconfig`： xxx 文件\n`.eslintignore`： eslint 忽略校验的配置文件\n`.eslintrc.js`： eslint 关键的配置文件\n\n## 配置根目录下的`.editorconfig`文件\n\n[https://editorconfig.org/](https://editorconfig.org/)\n\n```\n\nroot = true\n\n[*]\ncharset = utf-8\nend_of_line = lf\nindent_size = 2\nindent_style = space\ninsert_final_newline = true\nmax_line_length = 80\ntrim_trailing_whitespace = true\n\n[*.md]\nmax_line_length = 0\ntrim_trailing_whitespace = false\n```\n\n## 配置根目录下的`.eslintignore`文件\n\n```\ndist\nnode_modules\n```\n\n## 配置根目录下的`.eslintrc.js`文件\n\n```\nmodule.exports = {\n  root: true,\n  // vue 里面\n  parser: \"vue-eslint-parser\",\n  env: {\n    es6: true,\n    browser: true,\n    node: true\n  },\n  // parserOptions来指定语言版本为和模块类型\n  parserOptions: {\n    parser: \"babel-eslint\",\n    //  ecm版本\n    ecmaVersion: 6,\n    // 模块类型sourceType为module，如此便支持export和import来导出并引用文件\n    sourceType: \"module\",\n    ecmaFeatures: {\n      jsx: true,\n      modules: true,\n      experimentalObjectRestSpread: true\n    }\n  },\n  globals: {\n  },\n  extends: \"eslint:recommended\",\n  // vue:  extends: \"plugin:vue-libs/recommended\",\"@vue/typescript\",\"eslint:recommended\"\n  // required to lint *.vue files\n  plugins: [\"html\"],\n  // add your custom rules here\n  rules: {\n    \"no-console\": \"off\"\n  }\n};\n\n```\n\n##### 文章参考\n\n[https://larrylu.blog/improve-code-quality-using-eslint-742cf1f384f1](https://larrylu.blog/improve-code-quality-using-eslint-742cf1f384f1)\n","slug":"eslint","published":0,"date":"2019-08-29T07:04:05.314Z","updated":"2020-05-21T09:03:47.018Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckb1z4dfb000g9n9429d6hw6f","content":"<h2 id=\"Eslint\"><a href=\"#Eslint\" class=\"headerlink\" title=\"Eslint\"></a>Eslint</h2><p><strong>eslint 相关的文件在根目录下 <code>.editorconfig</code> <code>.eslintignore</code> <code>.eslintrc.js</code></strong></p>\n<p><code>.editorconfig</code>： xxx 文件<br><code>.eslintignore</code>： eslint 忽略校验的配置文件<br><code>.eslintrc.js</code>： eslint 关键的配置文件</p>\n<h2 id=\"配置根目录下的-editorconfig文件\"><a href=\"#配置根目录下的-editorconfig文件\" class=\"headerlink\" title=\"配置根目录下的.editorconfig文件\"></a>配置根目录下的<code>.editorconfig</code>文件</h2><p><a href=\"https://editorconfig.org/\" target=\"_blank\" rel=\"noopener\">https://editorconfig.org/</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">root = true</span><br><span class=\"line\"></span><br><span class=\"line\">[*]</span><br><span class=\"line\">charset = utf-8</span><br><span class=\"line\">end_of_line = lf</span><br><span class=\"line\">indent_size = 2</span><br><span class=\"line\">indent_style = space</span><br><span class=\"line\">insert_final_newline = true</span><br><span class=\"line\">max_line_length = 80</span><br><span class=\"line\">trim_trailing_whitespace = true</span><br><span class=\"line\"></span><br><span class=\"line\">[*.md]</span><br><span class=\"line\">max_line_length = 0</span><br><span class=\"line\">trim_trailing_whitespace = false</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"配置根目录下的-eslintignore文件\"><a href=\"#配置根目录下的-eslintignore文件\" class=\"headerlink\" title=\"配置根目录下的.eslintignore文件\"></a>配置根目录下的<code>.eslintignore</code>文件</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dist</span><br><span class=\"line\">node_modules</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"配置根目录下的-eslintrc-js文件\"><a href=\"#配置根目录下的-eslintrc-js文件\" class=\"headerlink\" title=\"配置根目录下的.eslintrc.js文件\"></a>配置根目录下的<code>.eslintrc.js</code>文件</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">  root: true,</span><br><span class=\"line\">  // vue 里面</span><br><span class=\"line\">  parser: &quot;vue-eslint-parser&quot;,</span><br><span class=\"line\">  env: &#123;</span><br><span class=\"line\">    es6: true,</span><br><span class=\"line\">    browser: true,</span><br><span class=\"line\">    node: true</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  // parserOptions来指定语言版本为和模块类型</span><br><span class=\"line\">  parserOptions: &#123;</span><br><span class=\"line\">    parser: &quot;babel-eslint&quot;,</span><br><span class=\"line\">    //  ecm版本</span><br><span class=\"line\">    ecmaVersion: 6,</span><br><span class=\"line\">    // 模块类型sourceType为module，如此便支持export和import来导出并引用文件</span><br><span class=\"line\">    sourceType: &quot;module&quot;,</span><br><span class=\"line\">    ecmaFeatures: &#123;</span><br><span class=\"line\">      jsx: true,</span><br><span class=\"line\">      modules: true,</span><br><span class=\"line\">      experimentalObjectRestSpread: true</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  globals: &#123;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  extends: &quot;eslint:recommended&quot;,</span><br><span class=\"line\">  // vue:  extends: &quot;plugin:vue-libs/recommended&quot;,&quot;@vue/typescript&quot;,&quot;eslint:recommended&quot;</span><br><span class=\"line\">  // required to lint *.vue files</span><br><span class=\"line\">  plugins: [&quot;html&quot;],</span><br><span class=\"line\">  // add your custom rules here</span><br><span class=\"line\">  rules: &#123;</span><br><span class=\"line\">    &quot;no-console&quot;: &quot;off&quot;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"文章参考\"><a href=\"#文章参考\" class=\"headerlink\" title=\"文章参考\"></a>文章参考</h5><p><a href=\"https://larrylu.blog/improve-code-quality-using-eslint-742cf1f384f1\" target=\"_blank\" rel=\"noopener\">https://larrylu.blog/improve-code-quality-using-eslint-742cf1f384f1</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Eslint\"><a href=\"#Eslint\" class=\"headerlink\" title=\"Eslint\"></a>Eslint</h2><p><strong>eslint 相关的文件在根目录下 <code>.editorconfig</code> <code>.eslintignore</code> <code>.eslintrc.js</code></strong></p>\n<p><code>.editorconfig</code>： xxx 文件<br><code>.eslintignore</code>： eslint 忽略校验的配置文件<br><code>.eslintrc.js</code>： eslint 关键的配置文件</p>\n<h2 id=\"配置根目录下的-editorconfig文件\"><a href=\"#配置根目录下的-editorconfig文件\" class=\"headerlink\" title=\"配置根目录下的.editorconfig文件\"></a>配置根目录下的<code>.editorconfig</code>文件</h2><p><a href=\"https://editorconfig.org/\" target=\"_blank\" rel=\"noopener\">https://editorconfig.org/</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">root = true</span><br><span class=\"line\"></span><br><span class=\"line\">[*]</span><br><span class=\"line\">charset = utf-8</span><br><span class=\"line\">end_of_line = lf</span><br><span class=\"line\">indent_size = 2</span><br><span class=\"line\">indent_style = space</span><br><span class=\"line\">insert_final_newline = true</span><br><span class=\"line\">max_line_length = 80</span><br><span class=\"line\">trim_trailing_whitespace = true</span><br><span class=\"line\"></span><br><span class=\"line\">[*.md]</span><br><span class=\"line\">max_line_length = 0</span><br><span class=\"line\">trim_trailing_whitespace = false</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"配置根目录下的-eslintignore文件\"><a href=\"#配置根目录下的-eslintignore文件\" class=\"headerlink\" title=\"配置根目录下的.eslintignore文件\"></a>配置根目录下的<code>.eslintignore</code>文件</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dist</span><br><span class=\"line\">node_modules</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"配置根目录下的-eslintrc-js文件\"><a href=\"#配置根目录下的-eslintrc-js文件\" class=\"headerlink\" title=\"配置根目录下的.eslintrc.js文件\"></a>配置根目录下的<code>.eslintrc.js</code>文件</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">  root: true,</span><br><span class=\"line\">  // vue 里面</span><br><span class=\"line\">  parser: &quot;vue-eslint-parser&quot;,</span><br><span class=\"line\">  env: &#123;</span><br><span class=\"line\">    es6: true,</span><br><span class=\"line\">    browser: true,</span><br><span class=\"line\">    node: true</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  // parserOptions来指定语言版本为和模块类型</span><br><span class=\"line\">  parserOptions: &#123;</span><br><span class=\"line\">    parser: &quot;babel-eslint&quot;,</span><br><span class=\"line\">    //  ecm版本</span><br><span class=\"line\">    ecmaVersion: 6,</span><br><span class=\"line\">    // 模块类型sourceType为module，如此便支持export和import来导出并引用文件</span><br><span class=\"line\">    sourceType: &quot;module&quot;,</span><br><span class=\"line\">    ecmaFeatures: &#123;</span><br><span class=\"line\">      jsx: true,</span><br><span class=\"line\">      modules: true,</span><br><span class=\"line\">      experimentalObjectRestSpread: true</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  globals: &#123;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  extends: &quot;eslint:recommended&quot;,</span><br><span class=\"line\">  // vue:  extends: &quot;plugin:vue-libs/recommended&quot;,&quot;@vue/typescript&quot;,&quot;eslint:recommended&quot;</span><br><span class=\"line\">  // required to lint *.vue files</span><br><span class=\"line\">  plugins: [&quot;html&quot;],</span><br><span class=\"line\">  // add your custom rules here</span><br><span class=\"line\">  rules: &#123;</span><br><span class=\"line\">    &quot;no-console&quot;: &quot;off&quot;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"文章参考\"><a href=\"#文章参考\" class=\"headerlink\" title=\"文章参考\"></a>文章参考</h5><p><a href=\"https://larrylu.blog/improve-code-quality-using-eslint-742cf1f384f1\" target=\"_blank\" rel=\"noopener\">https://larrylu.blog/improve-code-quality-using-eslint-742cf1f384f1</a></p>\n"},{"title":"git-commit 规范和代码风格检查","_content":"\n**本文思路：**\n\n1. commit 规范是什么\n2. 使用 commit 规范\n3. 什么时候检查提交的规范\n4. 提交之前添加代码风格检验\n5. 附加：commit 工具\n\n### commit 简介\n\nGit 每次提交代码，都要写 Commit message（提交说明），否则就不允许提交。\n目前，社区有多种 Commit message 的写法规范。Angular 规范是目前使用最广的写法，比较合理和系统化，并且有配套的工具。\n\n---\n\n### commit 格式\n\n目前规范使用较多的是 Angular 团队的规范, 继而衍生了 Conventional Commits specification. 很多工具也是基于此规范, 它的 message 格式如下:\n\n```\n<type>(<scope>): <subject>\n<BLANK LINE>\n<body>\n<BLANK LINE>\n<footer>\n\n```\n\n我们通过 git commit 命令带出的 vim 界面填写的最终结果应该类似如上这个结构, 大致分为三个部分(使用空行分割):\n\n- 标题行: 必填, 描述主要修改类型和内容\n- 主题内容: 描述为什么修改, 做了什么样的修改, 以及开发的思路等等\n- 页脚注释: 放 Breaking Changes 或 Closed Issues\n\n分别由如下部分构成:\n\n- type: commit 的类型\n  - upd：更新某功能（不是 feat, 不是 fix）\n  - feat: 新特性\n  - fix: 修改问题\n  - refactor: 代码重构\n  - docs: 文档修改\n  - style: 代码格式修改, 注意不是 css 修改\n  - test: 测试用例修改\n  - chore: 其他修改, 比如构建流程, 依赖管理.\n  - scope: commit 影响的范围, 比如: route, component, utils, build...\n- subject: commit 的概述, 建议符合 50/72 formatting\n- body: commit 具体修改内容, 可以分为多行, 建议符合 50/72 formatting\n- footer: 一些备注, 通常是 BREAKING CHANGE 或修复的 bug 的链接.\n\n这样一个符合规范的 commit message, 就好像是一份邮件.\n\n```bash\ngit commit -m \"fix: 修复了 XXX 功能\"\ngit commit -m \"feat: 增加了 XXX 功能\"\n```\n\n---\n\n## commitlint\n\n代码检验工具,需配合 husky（暂时可以不安装，下面单独模块解释） 使用\n\n```bash\n# Install commitlint cli and conventional config\nnpm install --save-dev @commitlint/{config-conventional,cli}\n# For Windows:\nnpm install --save-dev @commitlint/config-conventional @commitlint/cli\n\n# Configure commitlint to use conventional config\necho \"module.exports = {extends: ['@commitlint/config-conventional']}\" > commitlint.config.js\n```\n\n```\n{\n  \"husky\": {\n    \"hooks\": {\n      \"commit-msg\": \"commitlint -E HUSKY_GIT_PARAMS\"\n    }\n  }\n}\n```\n\n[https://github.com/conventional-changelog/commitlint](https://github.com/conventional-changelog/commitlint)\n\n---\n\n## husky\n\nhusky 会在 git 的钩子 pre-commit 进行相关操作\n\n安装 husky：\n\n```bash\nnpm install husky -D -S\n```\n\n然后修改 package.json，增加配置：\n\n```\n\"husky\": {\n    \"hooks\": {\n      \"commit-msg\": \"commitlint -E HUSKY_GIT_PARAMS\"\n      \"pre-commit\": \"eslint --ext .js,.vue src\"\n    }\n  }\n```\n\n这个时候加入了 eslint 代码风格检验, **但这样会有一个问题，就是这次提交，我可能只修改了一个文件，比如我就修改了 package.json 的内容，但它依然会校验所有 src 下面的.js 文件，非常的不友好。**\n\n---\n\n## lint-staged\n\n解决 husky 的痛点就需要使用 lint-staged 了。它只会校验检查你提交或者说你修改的部分内容。\n\n安装 lint-staged:\n\n```bash\nnpm install lint-staged -D -S\n```\n\n修改 package.json 配置：\n\n```\n\"husky\": {\n  \"hooks\": {\n    \"pre-commit\": \"lint-staged\",\n    \"commit-msg\": \"commitlint -E HUSKY_GIT_PARAMS\"\n  }\n},\n\"lint-staged\": {\n    \"src/**/*.{js,vue}\": [\n      \"eslint --fix\",\n      \"git add\"\n    ]\n  }\n```\n\n---\n\n## commitizen\n\n代码提交规范工具：commitizen/cz-cli, 我们需要借助它提供的 git cz 命令替代我们的 git commit 命令, 帮助我们生成符合规范的 commit message.\n除此之外, 我们还需要为 commitizen 指定一个 Adapter 比如: cz-conventional-changelog (一个符合 Angular 团队规范的 preset). 使得 commitizen 按照我们指定的规范帮助我们生成 commit message.\n\ncommitizen 作用: Simply use git cz instead of git commit when committing.\n\n安装依赖\n\n```bash\nnpm install -g commitizen cz-conventional-changelog\n```\n\n这个工具可用可不用，看个人喜好\n\n如上配置，每次它只会在你本地 commit 之前，校验你提交的内容是否符合你本地配置的 eslint 规则(这个见文档 ESLint )，如果符合规则，则会提交成功。如果不符合它会自动执行 eslint --fix 尝试帮你自动修复，如果修复成功则会帮你把修复好的代码提交，如果失败，则会提示你错误，让你修好这个错误之后才能允许你提交代码\n\n## 最终的流程\n\n达到上述效果，执行的流程如下：\n\n1. 待提交的代码 git add 添加到暂存区;\n2. 执行 git cz; // 也可以用原来的 git commit -m \"fix: 修复了 XXX 功能\"\n3. husky 注册在 git pre-commit 的钩子函数被调用，执行 lint-staged 和 commit 信息检查;\n4. Lint-staged 保证只对当前 add 到 git stage 区的文件进行扫描操作，这样做的原因在于，如果对全工程的文件进行扫描的话，并且之前的前端工程并未注重代码规则的检测的话，很大可能性会出现成百上千的 error，基本上心里是崩溃的。\n   因此，只对当前 add 的文件进行检测，达到及时止损的目的，历史代码可以切到新的分支进行修复后再进行合并。\n5. 如果有错误（没通过 ESlint 检查）则停止任务，同时打印错误信息，等待修复后再执行 commit;\n6. 成功 commit，可 push 到远程\n\n##### 相关依赖\n\n`commitizen` `husky` `lint-staged` `commitlint`\n\n## 相关阅读\n\n[阮一峰 commit_message_change 文章](https://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html)\n[https://github.com/XXHolic/blog/issues/16](https://github.com/XXHolic/blog/issues/16)\n","source":"_drafts/git-commit-规范.md","raw":"---\ntitle: git-commit 规范和代码风格检查\ncategories:\n  - 前端\ntags:\n  - git\n---\n\n**本文思路：**\n\n1. commit 规范是什么\n2. 使用 commit 规范\n3. 什么时候检查提交的规范\n4. 提交之前添加代码风格检验\n5. 附加：commit 工具\n\n### commit 简介\n\nGit 每次提交代码，都要写 Commit message（提交说明），否则就不允许提交。\n目前，社区有多种 Commit message 的写法规范。Angular 规范是目前使用最广的写法，比较合理和系统化，并且有配套的工具。\n\n---\n\n### commit 格式\n\n目前规范使用较多的是 Angular 团队的规范, 继而衍生了 Conventional Commits specification. 很多工具也是基于此规范, 它的 message 格式如下:\n\n```\n<type>(<scope>): <subject>\n<BLANK LINE>\n<body>\n<BLANK LINE>\n<footer>\n\n```\n\n我们通过 git commit 命令带出的 vim 界面填写的最终结果应该类似如上这个结构, 大致分为三个部分(使用空行分割):\n\n- 标题行: 必填, 描述主要修改类型和内容\n- 主题内容: 描述为什么修改, 做了什么样的修改, 以及开发的思路等等\n- 页脚注释: 放 Breaking Changes 或 Closed Issues\n\n分别由如下部分构成:\n\n- type: commit 的类型\n  - upd：更新某功能（不是 feat, 不是 fix）\n  - feat: 新特性\n  - fix: 修改问题\n  - refactor: 代码重构\n  - docs: 文档修改\n  - style: 代码格式修改, 注意不是 css 修改\n  - test: 测试用例修改\n  - chore: 其他修改, 比如构建流程, 依赖管理.\n  - scope: commit 影响的范围, 比如: route, component, utils, build...\n- subject: commit 的概述, 建议符合 50/72 formatting\n- body: commit 具体修改内容, 可以分为多行, 建议符合 50/72 formatting\n- footer: 一些备注, 通常是 BREAKING CHANGE 或修复的 bug 的链接.\n\n这样一个符合规范的 commit message, 就好像是一份邮件.\n\n```bash\ngit commit -m \"fix: 修复了 XXX 功能\"\ngit commit -m \"feat: 增加了 XXX 功能\"\n```\n\n---\n\n## commitlint\n\n代码检验工具,需配合 husky（暂时可以不安装，下面单独模块解释） 使用\n\n```bash\n# Install commitlint cli and conventional config\nnpm install --save-dev @commitlint/{config-conventional,cli}\n# For Windows:\nnpm install --save-dev @commitlint/config-conventional @commitlint/cli\n\n# Configure commitlint to use conventional config\necho \"module.exports = {extends: ['@commitlint/config-conventional']}\" > commitlint.config.js\n```\n\n```\n{\n  \"husky\": {\n    \"hooks\": {\n      \"commit-msg\": \"commitlint -E HUSKY_GIT_PARAMS\"\n    }\n  }\n}\n```\n\n[https://github.com/conventional-changelog/commitlint](https://github.com/conventional-changelog/commitlint)\n\n---\n\n## husky\n\nhusky 会在 git 的钩子 pre-commit 进行相关操作\n\n安装 husky：\n\n```bash\nnpm install husky -D -S\n```\n\n然后修改 package.json，增加配置：\n\n```\n\"husky\": {\n    \"hooks\": {\n      \"commit-msg\": \"commitlint -E HUSKY_GIT_PARAMS\"\n      \"pre-commit\": \"eslint --ext .js,.vue src\"\n    }\n  }\n```\n\n这个时候加入了 eslint 代码风格检验, **但这样会有一个问题，就是这次提交，我可能只修改了一个文件，比如我就修改了 package.json 的内容，但它依然会校验所有 src 下面的.js 文件，非常的不友好。**\n\n---\n\n## lint-staged\n\n解决 husky 的痛点就需要使用 lint-staged 了。它只会校验检查你提交或者说你修改的部分内容。\n\n安装 lint-staged:\n\n```bash\nnpm install lint-staged -D -S\n```\n\n修改 package.json 配置：\n\n```\n\"husky\": {\n  \"hooks\": {\n    \"pre-commit\": \"lint-staged\",\n    \"commit-msg\": \"commitlint -E HUSKY_GIT_PARAMS\"\n  }\n},\n\"lint-staged\": {\n    \"src/**/*.{js,vue}\": [\n      \"eslint --fix\",\n      \"git add\"\n    ]\n  }\n```\n\n---\n\n## commitizen\n\n代码提交规范工具：commitizen/cz-cli, 我们需要借助它提供的 git cz 命令替代我们的 git commit 命令, 帮助我们生成符合规范的 commit message.\n除此之外, 我们还需要为 commitizen 指定一个 Adapter 比如: cz-conventional-changelog (一个符合 Angular 团队规范的 preset). 使得 commitizen 按照我们指定的规范帮助我们生成 commit message.\n\ncommitizen 作用: Simply use git cz instead of git commit when committing.\n\n安装依赖\n\n```bash\nnpm install -g commitizen cz-conventional-changelog\n```\n\n这个工具可用可不用，看个人喜好\n\n如上配置，每次它只会在你本地 commit 之前，校验你提交的内容是否符合你本地配置的 eslint 规则(这个见文档 ESLint )，如果符合规则，则会提交成功。如果不符合它会自动执行 eslint --fix 尝试帮你自动修复，如果修复成功则会帮你把修复好的代码提交，如果失败，则会提示你错误，让你修好这个错误之后才能允许你提交代码\n\n## 最终的流程\n\n达到上述效果，执行的流程如下：\n\n1. 待提交的代码 git add 添加到暂存区;\n2. 执行 git cz; // 也可以用原来的 git commit -m \"fix: 修复了 XXX 功能\"\n3. husky 注册在 git pre-commit 的钩子函数被调用，执行 lint-staged 和 commit 信息检查;\n4. Lint-staged 保证只对当前 add 到 git stage 区的文件进行扫描操作，这样做的原因在于，如果对全工程的文件进行扫描的话，并且之前的前端工程并未注重代码规则的检测的话，很大可能性会出现成百上千的 error，基本上心里是崩溃的。\n   因此，只对当前 add 的文件进行检测，达到及时止损的目的，历史代码可以切到新的分支进行修复后再进行合并。\n5. 如果有错误（没通过 ESlint 检查）则停止任务，同时打印错误信息，等待修复后再执行 commit;\n6. 成功 commit，可 push 到远程\n\n##### 相关依赖\n\n`commitizen` `husky` `lint-staged` `commitlint`\n\n## 相关阅读\n\n[阮一峰 commit_message_change 文章](https://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html)\n[https://github.com/XXHolic/blog/issues/16](https://github.com/XXHolic/blog/issues/16)\n","slug":"git-commit-规范","published":0,"date":"2019-08-23T01:13:47.501Z","updated":"2020-05-21T07:11:33.569Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckb1z4dfc000h9n94iykooz9e","content":"<p><strong>本文思路：</strong></p>\n<ol>\n<li>commit 规范是什么</li>\n<li>使用 commit 规范</li>\n<li>什么时候检查提交的规范</li>\n<li>提交之前添加代码风格检验</li>\n<li>附加：commit 工具</li>\n</ol>\n<h3 id=\"commit-简介\"><a href=\"#commit-简介\" class=\"headerlink\" title=\"commit 简介\"></a>commit 简介</h3><p>Git 每次提交代码，都要写 Commit message（提交说明），否则就不允许提交。<br>目前，社区有多种 Commit message 的写法规范。Angular 规范是目前使用最广的写法，比较合理和系统化，并且有配套的工具。</p>\n<hr>\n<h3 id=\"commit-格式\"><a href=\"#commit-格式\" class=\"headerlink\" title=\"commit 格式\"></a>commit 格式</h3><p>目前规范使用较多的是 Angular 团队的规范, 继而衍生了 Conventional Commits specification. 很多工具也是基于此规范, 它的 message 格式如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;</span><br><span class=\"line\">&lt;BLANK LINE&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">&lt;BLANK LINE&gt;</span><br><span class=\"line\">&lt;footer&gt;</span><br></pre></td></tr></table></figure>\n\n<p>我们通过 git commit 命令带出的 vim 界面填写的最终结果应该类似如上这个结构, 大致分为三个部分(使用空行分割):</p>\n<ul>\n<li>标题行: 必填, 描述主要修改类型和内容</li>\n<li>主题内容: 描述为什么修改, 做了什么样的修改, 以及开发的思路等等</li>\n<li>页脚注释: 放 Breaking Changes 或 Closed Issues</li>\n</ul>\n<p>分别由如下部分构成:</p>\n<ul>\n<li>type: commit 的类型<ul>\n<li>upd：更新某功能（不是 feat, 不是 fix）</li>\n<li>feat: 新特性</li>\n<li>fix: 修改问题</li>\n<li>refactor: 代码重构</li>\n<li>docs: 文档修改</li>\n<li>style: 代码格式修改, 注意不是 css 修改</li>\n<li>test: 测试用例修改</li>\n<li>chore: 其他修改, 比如构建流程, 依赖管理.</li>\n<li>scope: commit 影响的范围, 比如: route, component, utils, build…</li>\n</ul>\n</li>\n<li>subject: commit 的概述, 建议符合 50/72 formatting</li>\n<li>body: commit 具体修改内容, 可以分为多行, 建议符合 50/72 formatting</li>\n<li>footer: 一些备注, 通常是 BREAKING CHANGE 或修复的 bug 的链接.</li>\n</ul>\n<p>这样一个符合规范的 commit message, 就好像是一份邮件.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit -m <span class=\"string\">\"fix: 修复了 XXX 功能\"</span></span><br><span class=\"line\">git commit -m <span class=\"string\">\"feat: 增加了 XXX 功能\"</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"commitlint\"><a href=\"#commitlint\" class=\"headerlink\" title=\"commitlint\"></a>commitlint</h2><p>代码检验工具,需配合 husky（暂时可以不安装，下面单独模块解释） 使用</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Install commitlint cli and conventional config</span></span><br><span class=\"line\">npm install --save-dev @commitlint/&#123;config-conventional,cli&#125;</span><br><span class=\"line\"><span class=\"comment\"># For Windows:</span></span><br><span class=\"line\">npm install --save-dev @commitlint/config-conventional @commitlint/cli</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Configure commitlint to use conventional config</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">\"module.exports = &#123;extends: ['@commitlint/config-conventional']&#125;\"</span> &gt; commitlint.config.js</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;husky&quot;: &#123;</span><br><span class=\"line\">    &quot;hooks&quot;: &#123;</span><br><span class=\"line\">      &quot;commit-msg&quot;: &quot;commitlint -E HUSKY_GIT_PARAMS&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><a href=\"https://github.com/conventional-changelog/commitlint\" target=\"_blank\" rel=\"noopener\">https://github.com/conventional-changelog/commitlint</a></p>\n<hr>\n<h2 id=\"husky\"><a href=\"#husky\" class=\"headerlink\" title=\"husky\"></a>husky</h2><p>husky 会在 git 的钩子 pre-commit 进行相关操作</p>\n<p>安装 husky：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install husky -D -S</span><br></pre></td></tr></table></figure>\n\n<p>然后修改 package.json，增加配置：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;husky&quot;: &#123;</span><br><span class=\"line\">    &quot;hooks&quot;: &#123;</span><br><span class=\"line\">      &quot;commit-msg&quot;: &quot;commitlint -E HUSKY_GIT_PARAMS&quot;</span><br><span class=\"line\">      &quot;pre-commit&quot;: &quot;eslint --ext .js,.vue src&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个时候加入了 eslint 代码风格检验, <strong>但这样会有一个问题，就是这次提交，我可能只修改了一个文件，比如我就修改了 package.json 的内容，但它依然会校验所有 src 下面的.js 文件，非常的不友好。</strong></p>\n<hr>\n<h2 id=\"lint-staged\"><a href=\"#lint-staged\" class=\"headerlink\" title=\"lint-staged\"></a>lint-staged</h2><p>解决 husky 的痛点就需要使用 lint-staged 了。它只会校验检查你提交或者说你修改的部分内容。</p>\n<p>安装 lint-staged:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install lint-staged -D -S</span><br></pre></td></tr></table></figure>\n\n<p>修改 package.json 配置：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;husky&quot;: &#123;</span><br><span class=\"line\">  &quot;hooks&quot;: &#123;</span><br><span class=\"line\">    &quot;pre-commit&quot;: &quot;lint-staged&quot;,</span><br><span class=\"line\">    &quot;commit-msg&quot;: &quot;commitlint -E HUSKY_GIT_PARAMS&quot;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">&quot;lint-staged&quot;: &#123;</span><br><span class=\"line\">    &quot;src/**/*.&#123;js,vue&#125;&quot;: [</span><br><span class=\"line\">      &quot;eslint --fix&quot;,</span><br><span class=\"line\">      &quot;git add&quot;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"commitizen\"><a href=\"#commitizen\" class=\"headerlink\" title=\"commitizen\"></a>commitizen</h2><p>代码提交规范工具：commitizen/cz-cli, 我们需要借助它提供的 git cz 命令替代我们的 git commit 命令, 帮助我们生成符合规范的 commit message.<br>除此之外, 我们还需要为 commitizen 指定一个 Adapter 比如: cz-conventional-changelog (一个符合 Angular 团队规范的 preset). 使得 commitizen 按照我们指定的规范帮助我们生成 commit message.</p>\n<p>commitizen 作用: Simply use git cz instead of git commit when committing.</p>\n<p>安装依赖</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g commitizen cz-conventional-changelog</span><br></pre></td></tr></table></figure>\n\n<p>这个工具可用可不用，看个人喜好</p>\n<p>如上配置，每次它只会在你本地 commit 之前，校验你提交的内容是否符合你本地配置的 eslint 规则(这个见文档 ESLint )，如果符合规则，则会提交成功。如果不符合它会自动执行 eslint –fix 尝试帮你自动修复，如果修复成功则会帮你把修复好的代码提交，如果失败，则会提示你错误，让你修好这个错误之后才能允许你提交代码</p>\n<h2 id=\"最终的流程\"><a href=\"#最终的流程\" class=\"headerlink\" title=\"最终的流程\"></a>最终的流程</h2><p>达到上述效果，执行的流程如下：</p>\n<ol>\n<li>待提交的代码 git add 添加到暂存区;</li>\n<li>执行 git cz; // 也可以用原来的 git commit -m “fix: 修复了 XXX 功能”</li>\n<li>husky 注册在 git pre-commit 的钩子函数被调用，执行 lint-staged 和 commit 信息检查;</li>\n<li>Lint-staged 保证只对当前 add 到 git stage 区的文件进行扫描操作，这样做的原因在于，如果对全工程的文件进行扫描的话，并且之前的前端工程并未注重代码规则的检测的话，很大可能性会出现成百上千的 error，基本上心里是崩溃的。<br>因此，只对当前 add 的文件进行检测，达到及时止损的目的，历史代码可以切到新的分支进行修复后再进行合并。</li>\n<li>如果有错误（没通过 ESlint 检查）则停止任务，同时打印错误信息，等待修复后再执行 commit;</li>\n<li>成功 commit，可 push 到远程</li>\n</ol>\n<h5 id=\"相关依赖\"><a href=\"#相关依赖\" class=\"headerlink\" title=\"相关依赖\"></a>相关依赖</h5><p><code>commitizen</code> <code>husky</code> <code>lint-staged</code> <code>commitlint</code></p>\n<h2 id=\"相关阅读\"><a href=\"#相关阅读\" class=\"headerlink\" title=\"相关阅读\"></a>相关阅读</h2><p><a href=\"https://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html\" target=\"_blank\" rel=\"noopener\">阮一峰 commit_message_change 文章</a><br><a href=\"https://github.com/XXHolic/blog/issues/16\" target=\"_blank\" rel=\"noopener\">https://github.com/XXHolic/blog/issues/16</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p><strong>本文思路：</strong></p>\n<ol>\n<li>commit 规范是什么</li>\n<li>使用 commit 规范</li>\n<li>什么时候检查提交的规范</li>\n<li>提交之前添加代码风格检验</li>\n<li>附加：commit 工具</li>\n</ol>\n<h3 id=\"commit-简介\"><a href=\"#commit-简介\" class=\"headerlink\" title=\"commit 简介\"></a>commit 简介</h3><p>Git 每次提交代码，都要写 Commit message（提交说明），否则就不允许提交。<br>目前，社区有多种 Commit message 的写法规范。Angular 规范是目前使用最广的写法，比较合理和系统化，并且有配套的工具。</p>\n<hr>\n<h3 id=\"commit-格式\"><a href=\"#commit-格式\" class=\"headerlink\" title=\"commit 格式\"></a>commit 格式</h3><p>目前规范使用较多的是 Angular 团队的规范, 继而衍生了 Conventional Commits specification. 很多工具也是基于此规范, 它的 message 格式如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;</span><br><span class=\"line\">&lt;BLANK LINE&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">&lt;BLANK LINE&gt;</span><br><span class=\"line\">&lt;footer&gt;</span><br></pre></td></tr></table></figure>\n\n<p>我们通过 git commit 命令带出的 vim 界面填写的最终结果应该类似如上这个结构, 大致分为三个部分(使用空行分割):</p>\n<ul>\n<li>标题行: 必填, 描述主要修改类型和内容</li>\n<li>主题内容: 描述为什么修改, 做了什么样的修改, 以及开发的思路等等</li>\n<li>页脚注释: 放 Breaking Changes 或 Closed Issues</li>\n</ul>\n<p>分别由如下部分构成:</p>\n<ul>\n<li>type: commit 的类型<ul>\n<li>upd：更新某功能（不是 feat, 不是 fix）</li>\n<li>feat: 新特性</li>\n<li>fix: 修改问题</li>\n<li>refactor: 代码重构</li>\n<li>docs: 文档修改</li>\n<li>style: 代码格式修改, 注意不是 css 修改</li>\n<li>test: 测试用例修改</li>\n<li>chore: 其他修改, 比如构建流程, 依赖管理.</li>\n<li>scope: commit 影响的范围, 比如: route, component, utils, build…</li>\n</ul>\n</li>\n<li>subject: commit 的概述, 建议符合 50/72 formatting</li>\n<li>body: commit 具体修改内容, 可以分为多行, 建议符合 50/72 formatting</li>\n<li>footer: 一些备注, 通常是 BREAKING CHANGE 或修复的 bug 的链接.</li>\n</ul>\n<p>这样一个符合规范的 commit message, 就好像是一份邮件.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit -m <span class=\"string\">\"fix: 修复了 XXX 功能\"</span></span><br><span class=\"line\">git commit -m <span class=\"string\">\"feat: 增加了 XXX 功能\"</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"commitlint\"><a href=\"#commitlint\" class=\"headerlink\" title=\"commitlint\"></a>commitlint</h2><p>代码检验工具,需配合 husky（暂时可以不安装，下面单独模块解释） 使用</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Install commitlint cli and conventional config</span></span><br><span class=\"line\">npm install --save-dev @commitlint/&#123;config-conventional,cli&#125;</span><br><span class=\"line\"><span class=\"comment\"># For Windows:</span></span><br><span class=\"line\">npm install --save-dev @commitlint/config-conventional @commitlint/cli</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Configure commitlint to use conventional config</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">\"module.exports = &#123;extends: ['@commitlint/config-conventional']&#125;\"</span> &gt; commitlint.config.js</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;husky&quot;: &#123;</span><br><span class=\"line\">    &quot;hooks&quot;: &#123;</span><br><span class=\"line\">      &quot;commit-msg&quot;: &quot;commitlint -E HUSKY_GIT_PARAMS&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><a href=\"https://github.com/conventional-changelog/commitlint\" target=\"_blank\" rel=\"noopener\">https://github.com/conventional-changelog/commitlint</a></p>\n<hr>\n<h2 id=\"husky\"><a href=\"#husky\" class=\"headerlink\" title=\"husky\"></a>husky</h2><p>husky 会在 git 的钩子 pre-commit 进行相关操作</p>\n<p>安装 husky：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install husky -D -S</span><br></pre></td></tr></table></figure>\n\n<p>然后修改 package.json，增加配置：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;husky&quot;: &#123;</span><br><span class=\"line\">    &quot;hooks&quot;: &#123;</span><br><span class=\"line\">      &quot;commit-msg&quot;: &quot;commitlint -E HUSKY_GIT_PARAMS&quot;</span><br><span class=\"line\">      &quot;pre-commit&quot;: &quot;eslint --ext .js,.vue src&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个时候加入了 eslint 代码风格检验, <strong>但这样会有一个问题，就是这次提交，我可能只修改了一个文件，比如我就修改了 package.json 的内容，但它依然会校验所有 src 下面的.js 文件，非常的不友好。</strong></p>\n<hr>\n<h2 id=\"lint-staged\"><a href=\"#lint-staged\" class=\"headerlink\" title=\"lint-staged\"></a>lint-staged</h2><p>解决 husky 的痛点就需要使用 lint-staged 了。它只会校验检查你提交或者说你修改的部分内容。</p>\n<p>安装 lint-staged:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install lint-staged -D -S</span><br></pre></td></tr></table></figure>\n\n<p>修改 package.json 配置：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;husky&quot;: &#123;</span><br><span class=\"line\">  &quot;hooks&quot;: &#123;</span><br><span class=\"line\">    &quot;pre-commit&quot;: &quot;lint-staged&quot;,</span><br><span class=\"line\">    &quot;commit-msg&quot;: &quot;commitlint -E HUSKY_GIT_PARAMS&quot;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">&quot;lint-staged&quot;: &#123;</span><br><span class=\"line\">    &quot;src/**/*.&#123;js,vue&#125;&quot;: [</span><br><span class=\"line\">      &quot;eslint --fix&quot;,</span><br><span class=\"line\">      &quot;git add&quot;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"commitizen\"><a href=\"#commitizen\" class=\"headerlink\" title=\"commitizen\"></a>commitizen</h2><p>代码提交规范工具：commitizen/cz-cli, 我们需要借助它提供的 git cz 命令替代我们的 git commit 命令, 帮助我们生成符合规范的 commit message.<br>除此之外, 我们还需要为 commitizen 指定一个 Adapter 比如: cz-conventional-changelog (一个符合 Angular 团队规范的 preset). 使得 commitizen 按照我们指定的规范帮助我们生成 commit message.</p>\n<p>commitizen 作用: Simply use git cz instead of git commit when committing.</p>\n<p>安装依赖</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g commitizen cz-conventional-changelog</span><br></pre></td></tr></table></figure>\n\n<p>这个工具可用可不用，看个人喜好</p>\n<p>如上配置，每次它只会在你本地 commit 之前，校验你提交的内容是否符合你本地配置的 eslint 规则(这个见文档 ESLint )，如果符合规则，则会提交成功。如果不符合它会自动执行 eslint –fix 尝试帮你自动修复，如果修复成功则会帮你把修复好的代码提交，如果失败，则会提示你错误，让你修好这个错误之后才能允许你提交代码</p>\n<h2 id=\"最终的流程\"><a href=\"#最终的流程\" class=\"headerlink\" title=\"最终的流程\"></a>最终的流程</h2><p>达到上述效果，执行的流程如下：</p>\n<ol>\n<li>待提交的代码 git add 添加到暂存区;</li>\n<li>执行 git cz; // 也可以用原来的 git commit -m “fix: 修复了 XXX 功能”</li>\n<li>husky 注册在 git pre-commit 的钩子函数被调用，执行 lint-staged 和 commit 信息检查;</li>\n<li>Lint-staged 保证只对当前 add 到 git stage 区的文件进行扫描操作，这样做的原因在于，如果对全工程的文件进行扫描的话，并且之前的前端工程并未注重代码规则的检测的话，很大可能性会出现成百上千的 error，基本上心里是崩溃的。<br>因此，只对当前 add 的文件进行检测，达到及时止损的目的，历史代码可以切到新的分支进行修复后再进行合并。</li>\n<li>如果有错误（没通过 ESlint 检查）则停止任务，同时打印错误信息，等待修复后再执行 commit;</li>\n<li>成功 commit，可 push 到远程</li>\n</ol>\n<h5 id=\"相关依赖\"><a href=\"#相关依赖\" class=\"headerlink\" title=\"相关依赖\"></a>相关依赖</h5><p><code>commitizen</code> <code>husky</code> <code>lint-staged</code> <code>commitlint</code></p>\n<h2 id=\"相关阅读\"><a href=\"#相关阅读\" class=\"headerlink\" title=\"相关阅读\"></a>相关阅读</h2><p><a href=\"https://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html\" target=\"_blank\" rel=\"noopener\">阮一峰 commit_message_change 文章</a><br><a href=\"https://github.com/XXHolic/blog/issues/16\" target=\"_blank\" rel=\"noopener\">https://github.com/XXHolic/blog/issues/16</a></p>\n"},{"title":"docker","_content":"\n## 查看 docker 版本\n\n```bash\n$ docker --version\nDocker version 19.03.1, build 74b1e89\n\n$ docker-compose --version\ndocker-compose version 1.24.1, build 4667896b\n\n$ docker-machine --version\ndocker-machine version 0.16.1, build cce350d7\n\n```\n\n## 查看 docker 容器\n\n```bash\n// 查看所有的容器\n$ docker ps -a\n\n// 查看已运行的容器\n$ docker ps\n```\n\n## 创建一个新的容器并运行一个命令\n\n```bash\n\n// 使用docker镜像nginx:latest以后台模式启动一个容器,并将容器命名为mynginx。\ndocker run --name mynginx -d nginx:latest\n\n// 使用镜像nginx:latest以后台模式启动一个容器,并将容器的80端口映射到主机随机端口。\ndocker run -P -d nginx:latest\n\n\n//使用镜像 nginx:latest，以后台模式启动一个容器,将容器的 80 端口映射到主机的 80 端口,主机的目录 /data 映射到容器的 /data。\ndocker run -p 80:80 -v /data:/data -d nginx:latest\n\n// 绑定容器的 8080 端口，并将其映射到本地主机 127.0.0.1 的 80 端口上。\n$ docker run -p 127.0.0.1:80:8080/tcp ubuntu bash\n\n使用镜像nginx:latest以交互模式启动一个容器,在容器内执行/bin/bash命令。\n$ docker run -it nginx:latest /bin/bash\n\n\n```\n\n## 进入容器（需要已运行） 未运行进去不\n\n```bash\n$ docker exec -it xxxx /bin/bash\n\n```\n\n## 启动容器（未运行）\n\n```bash\n$ docker start xxx\n\n```\n\n## 停止容器\n\n```bash\n$ docker stop xxx\n\n```\n\n## 删除容器 (必须先暂停容器)\n\n```bash\n$ docker rm xxx\n```\n\n## 查看 docker 镜像 images\n\n```bash\n$ docker images\n```\n\n## 删除镜像 images\n\n```bash\n$ docker rmi -f xxx\n```\n\n## 将容器打包成镜像\n\n```bash\n$ docker commit\n\nOPTIONS说明：\n-a :提交的镜像作者；\n-c :使用Dockerfile指令来创建镜像；\n-m :提交时的说明文字；\n-p :在commit时，将容器暂停。\n\ndocker commit -a \"提交镜像的作者\" -m \"提交的说明\" 容器名称或id  仓库名称/打包的镜像名称:标签\n\n\n注意：\n\ndocker commit 命令除了学习之外，还有一些特殊的应用场合，比如被入侵后保存现场等。但是，不要使用 docker commit 定制镜像，定制镜像应该使用 Dockerfile 来完成。\n\n使用 docker commit 意味着所有对镜像的操作都是黑箱操作，生成的镜像也被称为 黑箱镜像，换句话说，就是除了制作镜像的人知道执行过什么命令、怎么生成的镜像，别人根本无从得知。而且，即使是这个制作镜像的人，过一段时间后也无法记清具体在操作的。虽然 docker diff 或许可以告诉得到一些线索，但是远远不到可以确保生成一致镜像的地步。这种黑箱镜像的维护工作是非常痛苦的。\n```\n\n## 将镜像推送到 docker 仓库 （需要登录 docker login）\n\n```bash\n$ docker push 仓库名称/打包的镜像名称:标签\n```\n\n## 将本地镜像改名字 （标记本地镜像，将其归入某一仓库。）\n\n```bash\n$ docker tag IMAGEID(镜像id) REPOSITORY:TAG（仓库：标签）\n```\n\n## docker build 命令用于使用 Dockerfile 创建镜像。\n\n```bash\n\nOPTIONS说明：\n--build-arg=[] :设置镜像创建时的变量；\n\n--cpu-shares :设置 cpu 使用权重；\n\n--cpu-period :限制 CPU CFS周期；\n\n--cpu-quota :限制 CPU CFS配额；\n\n--cpuset-cpus :指定使用的CPU id；\n\n--cpuset-mems :指定使用的内存 id；\n\n--disable-content-trust :忽略校验，默认开启；\n\n-f :指定要使用的Dockerfile路径；\n\n--force-rm :设置镜像过程中删除中间容器；\n\n--isolation :使用容器隔离技术；\n\n--label=[] :设置镜像使用的元数据；\n\n-m :设置内存最大值；\n\n--memory-swap :设置Swap的最大值为内存+swap，\"-1\"表示不限swap；\n\n--no-cache :创建镜像的过程不使用缓存；\n\n--pull :尝试去更新镜像的新版本；\n\n--quiet, -q :安静模式，成功后只输出镜像 ID；\n\n--rm :设置镜像成功后删除中间容器；\n\n--shm-size :设置/dev/shm的大小，默认值是64M；\n\n--ulimit :Ulimit配置。\n\n--tag, -t: 镜像的名字及标签，通常 name:tag 或者 name 格式；可以在一次构建中为一个镜像设置多个标签。\n\n--network: 默认 default。在构建期间设置RUN指令的网络模式\n\n\n\n使用当前目录的 Dockerfile 创建镜像，标签为 runoob/ubuntu:v1。\n\n$ docker build -t runoob/ubuntu:v1 .\n\n\n\n有提到指令最后一个 . 是上下文路径\n\n上下文路径，是指 docker 在构建镜像，有时候想要使用到本机的文件（比如复制），docker build 命令得知这个路径后，会将路径下的所有内容打包。\n\n解析：由于 docker 的运行模式是 C/S。我们本机是 C，docker 引擎是 S。实际的构建过程是在 docker 引擎下完成的，所以这个时候无法用到我们本机的文件。这就需要把我们本机的指定目录下的文件一起打包提供给 docker 引擎使用。\n\n如果未说明最后一个参数，那么默认上下文路径就是 Dockerfile 所在的位置。\n\n注意：上下文路径下不要放无用的文件，因为会一起打包发送给 docker 引擎，如果文件过多会造成过程缓慢。\n```\n\n## Docker Mechine\n\nDocker Machine 是一个工具，用来在虚拟主机上安装 Docker Engine，并使用 docker-machine 命令来管理这些虚拟主机。\n","source":"_drafts/docker.md","raw":"---\ntitle: docker\ncategories:\ntags:\n---\n\n## 查看 docker 版本\n\n```bash\n$ docker --version\nDocker version 19.03.1, build 74b1e89\n\n$ docker-compose --version\ndocker-compose version 1.24.1, build 4667896b\n\n$ docker-machine --version\ndocker-machine version 0.16.1, build cce350d7\n\n```\n\n## 查看 docker 容器\n\n```bash\n// 查看所有的容器\n$ docker ps -a\n\n// 查看已运行的容器\n$ docker ps\n```\n\n## 创建一个新的容器并运行一个命令\n\n```bash\n\n// 使用docker镜像nginx:latest以后台模式启动一个容器,并将容器命名为mynginx。\ndocker run --name mynginx -d nginx:latest\n\n// 使用镜像nginx:latest以后台模式启动一个容器,并将容器的80端口映射到主机随机端口。\ndocker run -P -d nginx:latest\n\n\n//使用镜像 nginx:latest，以后台模式启动一个容器,将容器的 80 端口映射到主机的 80 端口,主机的目录 /data 映射到容器的 /data。\ndocker run -p 80:80 -v /data:/data -d nginx:latest\n\n// 绑定容器的 8080 端口，并将其映射到本地主机 127.0.0.1 的 80 端口上。\n$ docker run -p 127.0.0.1:80:8080/tcp ubuntu bash\n\n使用镜像nginx:latest以交互模式启动一个容器,在容器内执行/bin/bash命令。\n$ docker run -it nginx:latest /bin/bash\n\n\n```\n\n## 进入容器（需要已运行） 未运行进去不\n\n```bash\n$ docker exec -it xxxx /bin/bash\n\n```\n\n## 启动容器（未运行）\n\n```bash\n$ docker start xxx\n\n```\n\n## 停止容器\n\n```bash\n$ docker stop xxx\n\n```\n\n## 删除容器 (必须先暂停容器)\n\n```bash\n$ docker rm xxx\n```\n\n## 查看 docker 镜像 images\n\n```bash\n$ docker images\n```\n\n## 删除镜像 images\n\n```bash\n$ docker rmi -f xxx\n```\n\n## 将容器打包成镜像\n\n```bash\n$ docker commit\n\nOPTIONS说明：\n-a :提交的镜像作者；\n-c :使用Dockerfile指令来创建镜像；\n-m :提交时的说明文字；\n-p :在commit时，将容器暂停。\n\ndocker commit -a \"提交镜像的作者\" -m \"提交的说明\" 容器名称或id  仓库名称/打包的镜像名称:标签\n\n\n注意：\n\ndocker commit 命令除了学习之外，还有一些特殊的应用场合，比如被入侵后保存现场等。但是，不要使用 docker commit 定制镜像，定制镜像应该使用 Dockerfile 来完成。\n\n使用 docker commit 意味着所有对镜像的操作都是黑箱操作，生成的镜像也被称为 黑箱镜像，换句话说，就是除了制作镜像的人知道执行过什么命令、怎么生成的镜像，别人根本无从得知。而且，即使是这个制作镜像的人，过一段时间后也无法记清具体在操作的。虽然 docker diff 或许可以告诉得到一些线索，但是远远不到可以确保生成一致镜像的地步。这种黑箱镜像的维护工作是非常痛苦的。\n```\n\n## 将镜像推送到 docker 仓库 （需要登录 docker login）\n\n```bash\n$ docker push 仓库名称/打包的镜像名称:标签\n```\n\n## 将本地镜像改名字 （标记本地镜像，将其归入某一仓库。）\n\n```bash\n$ docker tag IMAGEID(镜像id) REPOSITORY:TAG（仓库：标签）\n```\n\n## docker build 命令用于使用 Dockerfile 创建镜像。\n\n```bash\n\nOPTIONS说明：\n--build-arg=[] :设置镜像创建时的变量；\n\n--cpu-shares :设置 cpu 使用权重；\n\n--cpu-period :限制 CPU CFS周期；\n\n--cpu-quota :限制 CPU CFS配额；\n\n--cpuset-cpus :指定使用的CPU id；\n\n--cpuset-mems :指定使用的内存 id；\n\n--disable-content-trust :忽略校验，默认开启；\n\n-f :指定要使用的Dockerfile路径；\n\n--force-rm :设置镜像过程中删除中间容器；\n\n--isolation :使用容器隔离技术；\n\n--label=[] :设置镜像使用的元数据；\n\n-m :设置内存最大值；\n\n--memory-swap :设置Swap的最大值为内存+swap，\"-1\"表示不限swap；\n\n--no-cache :创建镜像的过程不使用缓存；\n\n--pull :尝试去更新镜像的新版本；\n\n--quiet, -q :安静模式，成功后只输出镜像 ID；\n\n--rm :设置镜像成功后删除中间容器；\n\n--shm-size :设置/dev/shm的大小，默认值是64M；\n\n--ulimit :Ulimit配置。\n\n--tag, -t: 镜像的名字及标签，通常 name:tag 或者 name 格式；可以在一次构建中为一个镜像设置多个标签。\n\n--network: 默认 default。在构建期间设置RUN指令的网络模式\n\n\n\n使用当前目录的 Dockerfile 创建镜像，标签为 runoob/ubuntu:v1。\n\n$ docker build -t runoob/ubuntu:v1 .\n\n\n\n有提到指令最后一个 . 是上下文路径\n\n上下文路径，是指 docker 在构建镜像，有时候想要使用到本机的文件（比如复制），docker build 命令得知这个路径后，会将路径下的所有内容打包。\n\n解析：由于 docker 的运行模式是 C/S。我们本机是 C，docker 引擎是 S。实际的构建过程是在 docker 引擎下完成的，所以这个时候无法用到我们本机的文件。这就需要把我们本机的指定目录下的文件一起打包提供给 docker 引擎使用。\n\n如果未说明最后一个参数，那么默认上下文路径就是 Dockerfile 所在的位置。\n\n注意：上下文路径下不要放无用的文件，因为会一起打包发送给 docker 引擎，如果文件过多会造成过程缓慢。\n```\n\n## Docker Mechine\n\nDocker Machine 是一个工具，用来在虚拟主机上安装 Docker Engine，并使用 docker-machine 命令来管理这些虚拟主机。\n","slug":"docker","published":0,"date":"2019-12-18T07:10:48.820Z","updated":"2019-12-20T03:29:53.276Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckb1z4dfd000i9n945oaszn7t","content":"<h2 id=\"查看-docker-版本\"><a href=\"#查看-docker-版本\" class=\"headerlink\" title=\"查看 docker 版本\"></a>查看 docker 版本</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker --version</span><br><span class=\"line\">Docker version 19.03.1, build 74b1e89</span><br><span class=\"line\"></span><br><span class=\"line\">$ docker-compose --version</span><br><span class=\"line\">docker-compose version 1.24.1, build 4667896b</span><br><span class=\"line\"></span><br><span class=\"line\">$ docker-machine --version</span><br><span class=\"line\">docker-machine version 0.16.1, build cce350d7</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"查看-docker-容器\"><a href=\"#查看-docker-容器\" class=\"headerlink\" title=\"查看 docker 容器\"></a>查看 docker 容器</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 查看所有的容器</span><br><span class=\"line\">$ docker ps -a</span><br><span class=\"line\"></span><br><span class=\"line\">// 查看已运行的容器</span><br><span class=\"line\">$ docker ps</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"创建一个新的容器并运行一个命令\"><a href=\"#创建一个新的容器并运行一个命令\" class=\"headerlink\" title=\"创建一个新的容器并运行一个命令\"></a>创建一个新的容器并运行一个命令</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">// 使用docker镜像nginx:latest以后台模式启动一个容器,并将容器命名为mynginx。</span><br><span class=\"line\">docker run --name mynginx -d nginx:latest</span><br><span class=\"line\"></span><br><span class=\"line\">// 使用镜像nginx:latest以后台模式启动一个容器,并将容器的80端口映射到主机随机端口。</span><br><span class=\"line\">docker run -P -d nginx:latest</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">//使用镜像 nginx:latest，以后台模式启动一个容器,将容器的 80 端口映射到主机的 80 端口,主机的目录 /data 映射到容器的 /data。</span><br><span class=\"line\">docker run -p 80:80 -v /data:/data -d nginx:latest</span><br><span class=\"line\"></span><br><span class=\"line\">// 绑定容器的 8080 端口，并将其映射到本地主机 127.0.0.1 的 80 端口上。</span><br><span class=\"line\">$ docker run -p 127.0.0.1:80:8080/tcp ubuntu bash</span><br><span class=\"line\"></span><br><span class=\"line\">使用镜像nginx:latest以交互模式启动一个容器,在容器内执行/bin/bash命令。</span><br><span class=\"line\">$ docker run -it nginx:latest /bin/bash</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"进入容器（需要已运行）-未运行进去不\"><a href=\"#进入容器（需要已运行）-未运行进去不\" class=\"headerlink\" title=\"进入容器（需要已运行） 未运行进去不\"></a>进入容器（需要已运行） 未运行进去不</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker <span class=\"built_in\">exec</span> -it xxxx /bin/bash</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"启动容器（未运行）\"><a href=\"#启动容器（未运行）\" class=\"headerlink\" title=\"启动容器（未运行）\"></a>启动容器（未运行）</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker start xxx</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"停止容器\"><a href=\"#停止容器\" class=\"headerlink\" title=\"停止容器\"></a>停止容器</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker stop xxx</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"删除容器-必须先暂停容器\"><a href=\"#删除容器-必须先暂停容器\" class=\"headerlink\" title=\"删除容器 (必须先暂停容器)\"></a>删除容器 (必须先暂停容器)</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker rm xxx</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"查看-docker-镜像-images\"><a href=\"#查看-docker-镜像-images\" class=\"headerlink\" title=\"查看 docker 镜像 images\"></a>查看 docker 镜像 images</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker images</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"删除镜像-images\"><a href=\"#删除镜像-images\" class=\"headerlink\" title=\"删除镜像 images\"></a>删除镜像 images</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker rmi -f xxx</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"将容器打包成镜像\"><a href=\"#将容器打包成镜像\" class=\"headerlink\" title=\"将容器打包成镜像\"></a>将容器打包成镜像</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker commit</span><br><span class=\"line\"></span><br><span class=\"line\">OPTIONS说明：</span><br><span class=\"line\">-a :提交的镜像作者；</span><br><span class=\"line\">-c :使用Dockerfile指令来创建镜像；</span><br><span class=\"line\">-m :提交时的说明文字；</span><br><span class=\"line\">-p :在commit时，将容器暂停。</span><br><span class=\"line\"></span><br><span class=\"line\">docker commit -a <span class=\"string\">\"提交镜像的作者\"</span> -m <span class=\"string\">\"提交的说明\"</span> 容器名称或id  仓库名称/打包的镜像名称:标签</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">注意：</span><br><span class=\"line\"></span><br><span class=\"line\">docker commit 命令除了学习之外，还有一些特殊的应用场合，比如被入侵后保存现场等。但是，不要使用 docker commit 定制镜像，定制镜像应该使用 Dockerfile 来完成。</span><br><span class=\"line\"></span><br><span class=\"line\">使用 docker commit 意味着所有对镜像的操作都是黑箱操作，生成的镜像也被称为 黑箱镜像，换句话说，就是除了制作镜像的人知道执行过什么命令、怎么生成的镜像，别人根本无从得知。而且，即使是这个制作镜像的人，过一段时间后也无法记清具体在操作的。虽然 docker diff 或许可以告诉得到一些线索，但是远远不到可以确保生成一致镜像的地步。这种黑箱镜像的维护工作是非常痛苦的。</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"将镜像推送到-docker-仓库-（需要登录-docker-login）\"><a href=\"#将镜像推送到-docker-仓库-（需要登录-docker-login）\" class=\"headerlink\" title=\"将镜像推送到 docker 仓库 （需要登录 docker login）\"></a>将镜像推送到 docker 仓库 （需要登录 docker login）</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker push 仓库名称/打包的镜像名称:标签</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"将本地镜像改名字-（标记本地镜像，将其归入某一仓库。）\"><a href=\"#将本地镜像改名字-（标记本地镜像，将其归入某一仓库。）\" class=\"headerlink\" title=\"将本地镜像改名字 （标记本地镜像，将其归入某一仓库。）\"></a>将本地镜像改名字 （标记本地镜像，将其归入某一仓库。）</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker tag IMAGEID(镜像id) REPOSITORY:TAG（仓库：标签）</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"docker-build-命令用于使用-Dockerfile-创建镜像。\"><a href=\"#docker-build-命令用于使用-Dockerfile-创建镜像。\" class=\"headerlink\" title=\"docker build 命令用于使用 Dockerfile 创建镜像。\"></a>docker build 命令用于使用 Dockerfile 创建镜像。</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">OPTIONS说明：</span><br><span class=\"line\">--build-arg=[] :设置镜像创建时的变量；</span><br><span class=\"line\"></span><br><span class=\"line\">--cpu-shares :设置 cpu 使用权重；</span><br><span class=\"line\"></span><br><span class=\"line\">--cpu-period :限制 CPU CFS周期；</span><br><span class=\"line\"></span><br><span class=\"line\">--cpu-quota :限制 CPU CFS配额；</span><br><span class=\"line\"></span><br><span class=\"line\">--cpuset-cpus :指定使用的CPU id；</span><br><span class=\"line\"></span><br><span class=\"line\">--cpuset-mems :指定使用的内存 id；</span><br><span class=\"line\"></span><br><span class=\"line\">--<span class=\"built_in\">disable</span>-content-trust :忽略校验，默认开启；</span><br><span class=\"line\"></span><br><span class=\"line\">-f :指定要使用的Dockerfile路径；</span><br><span class=\"line\"></span><br><span class=\"line\">--force-rm :设置镜像过程中删除中间容器；</span><br><span class=\"line\"></span><br><span class=\"line\">--isolation :使用容器隔离技术；</span><br><span class=\"line\"></span><br><span class=\"line\">--label=[] :设置镜像使用的元数据；</span><br><span class=\"line\"></span><br><span class=\"line\">-m :设置内存最大值；</span><br><span class=\"line\"></span><br><span class=\"line\">--memory-swap :设置Swap的最大值为内存+swap，<span class=\"string\">\"-1\"</span>表示不限swap；</span><br><span class=\"line\"></span><br><span class=\"line\">--no-cache :创建镜像的过程不使用缓存；</span><br><span class=\"line\"></span><br><span class=\"line\">--pull :尝试去更新镜像的新版本；</span><br><span class=\"line\"></span><br><span class=\"line\">--quiet, -q :安静模式，成功后只输出镜像 ID；</span><br><span class=\"line\"></span><br><span class=\"line\">--rm :设置镜像成功后删除中间容器；</span><br><span class=\"line\"></span><br><span class=\"line\">--shm-size :设置/dev/shm的大小，默认值是64M；</span><br><span class=\"line\"></span><br><span class=\"line\">--<span class=\"built_in\">ulimit</span> :Ulimit配置。</span><br><span class=\"line\"></span><br><span class=\"line\">--tag, -t: 镜像的名字及标签，通常 name:tag 或者 name 格式；可以在一次构建中为一个镜像设置多个标签。</span><br><span class=\"line\"></span><br><span class=\"line\">--network: 默认 default。在构建期间设置RUN指令的网络模式</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">使用当前目录的 Dockerfile 创建镜像，标签为 runoob/ubuntu:v1。</span><br><span class=\"line\"></span><br><span class=\"line\">$ docker build -t runoob/ubuntu:v1 .</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">有提到指令最后一个 . 是上下文路径</span><br><span class=\"line\"></span><br><span class=\"line\">上下文路径，是指 docker 在构建镜像，有时候想要使用到本机的文件（比如复制），docker build 命令得知这个路径后，会将路径下的所有内容打包。</span><br><span class=\"line\"></span><br><span class=\"line\">解析：由于 docker 的运行模式是 C/S。我们本机是 C，docker 引擎是 S。实际的构建过程是在 docker 引擎下完成的，所以这个时候无法用到我们本机的文件。这就需要把我们本机的指定目录下的文件一起打包提供给 docker 引擎使用。</span><br><span class=\"line\"></span><br><span class=\"line\">如果未说明最后一个参数，那么默认上下文路径就是 Dockerfile 所在的位置。</span><br><span class=\"line\"></span><br><span class=\"line\">注意：上下文路径下不要放无用的文件，因为会一起打包发送给 docker 引擎，如果文件过多会造成过程缓慢。</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Docker-Mechine\"><a href=\"#Docker-Mechine\" class=\"headerlink\" title=\"Docker Mechine\"></a>Docker Mechine</h2><p>Docker Machine 是一个工具，用来在虚拟主机上安装 Docker Engine，并使用 docker-machine 命令来管理这些虚拟主机。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"查看-docker-版本\"><a href=\"#查看-docker-版本\" class=\"headerlink\" title=\"查看 docker 版本\"></a>查看 docker 版本</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker --version</span><br><span class=\"line\">Docker version 19.03.1, build 74b1e89</span><br><span class=\"line\"></span><br><span class=\"line\">$ docker-compose --version</span><br><span class=\"line\">docker-compose version 1.24.1, build 4667896b</span><br><span class=\"line\"></span><br><span class=\"line\">$ docker-machine --version</span><br><span class=\"line\">docker-machine version 0.16.1, build cce350d7</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"查看-docker-容器\"><a href=\"#查看-docker-容器\" class=\"headerlink\" title=\"查看 docker 容器\"></a>查看 docker 容器</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 查看所有的容器</span><br><span class=\"line\">$ docker ps -a</span><br><span class=\"line\"></span><br><span class=\"line\">// 查看已运行的容器</span><br><span class=\"line\">$ docker ps</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"创建一个新的容器并运行一个命令\"><a href=\"#创建一个新的容器并运行一个命令\" class=\"headerlink\" title=\"创建一个新的容器并运行一个命令\"></a>创建一个新的容器并运行一个命令</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">// 使用docker镜像nginx:latest以后台模式启动一个容器,并将容器命名为mynginx。</span><br><span class=\"line\">docker run --name mynginx -d nginx:latest</span><br><span class=\"line\"></span><br><span class=\"line\">// 使用镜像nginx:latest以后台模式启动一个容器,并将容器的80端口映射到主机随机端口。</span><br><span class=\"line\">docker run -P -d nginx:latest</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">//使用镜像 nginx:latest，以后台模式启动一个容器,将容器的 80 端口映射到主机的 80 端口,主机的目录 /data 映射到容器的 /data。</span><br><span class=\"line\">docker run -p 80:80 -v /data:/data -d nginx:latest</span><br><span class=\"line\"></span><br><span class=\"line\">// 绑定容器的 8080 端口，并将其映射到本地主机 127.0.0.1 的 80 端口上。</span><br><span class=\"line\">$ docker run -p 127.0.0.1:80:8080/tcp ubuntu bash</span><br><span class=\"line\"></span><br><span class=\"line\">使用镜像nginx:latest以交互模式启动一个容器,在容器内执行/bin/bash命令。</span><br><span class=\"line\">$ docker run -it nginx:latest /bin/bash</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"进入容器（需要已运行）-未运行进去不\"><a href=\"#进入容器（需要已运行）-未运行进去不\" class=\"headerlink\" title=\"进入容器（需要已运行） 未运行进去不\"></a>进入容器（需要已运行） 未运行进去不</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker <span class=\"built_in\">exec</span> -it xxxx /bin/bash</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"启动容器（未运行）\"><a href=\"#启动容器（未运行）\" class=\"headerlink\" title=\"启动容器（未运行）\"></a>启动容器（未运行）</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker start xxx</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"停止容器\"><a href=\"#停止容器\" class=\"headerlink\" title=\"停止容器\"></a>停止容器</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker stop xxx</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"删除容器-必须先暂停容器\"><a href=\"#删除容器-必须先暂停容器\" class=\"headerlink\" title=\"删除容器 (必须先暂停容器)\"></a>删除容器 (必须先暂停容器)</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker rm xxx</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"查看-docker-镜像-images\"><a href=\"#查看-docker-镜像-images\" class=\"headerlink\" title=\"查看 docker 镜像 images\"></a>查看 docker 镜像 images</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker images</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"删除镜像-images\"><a href=\"#删除镜像-images\" class=\"headerlink\" title=\"删除镜像 images\"></a>删除镜像 images</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker rmi -f xxx</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"将容器打包成镜像\"><a href=\"#将容器打包成镜像\" class=\"headerlink\" title=\"将容器打包成镜像\"></a>将容器打包成镜像</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker commit</span><br><span class=\"line\"></span><br><span class=\"line\">OPTIONS说明：</span><br><span class=\"line\">-a :提交的镜像作者；</span><br><span class=\"line\">-c :使用Dockerfile指令来创建镜像；</span><br><span class=\"line\">-m :提交时的说明文字；</span><br><span class=\"line\">-p :在commit时，将容器暂停。</span><br><span class=\"line\"></span><br><span class=\"line\">docker commit -a <span class=\"string\">\"提交镜像的作者\"</span> -m <span class=\"string\">\"提交的说明\"</span> 容器名称或id  仓库名称/打包的镜像名称:标签</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">注意：</span><br><span class=\"line\"></span><br><span class=\"line\">docker commit 命令除了学习之外，还有一些特殊的应用场合，比如被入侵后保存现场等。但是，不要使用 docker commit 定制镜像，定制镜像应该使用 Dockerfile 来完成。</span><br><span class=\"line\"></span><br><span class=\"line\">使用 docker commit 意味着所有对镜像的操作都是黑箱操作，生成的镜像也被称为 黑箱镜像，换句话说，就是除了制作镜像的人知道执行过什么命令、怎么生成的镜像，别人根本无从得知。而且，即使是这个制作镜像的人，过一段时间后也无法记清具体在操作的。虽然 docker diff 或许可以告诉得到一些线索，但是远远不到可以确保生成一致镜像的地步。这种黑箱镜像的维护工作是非常痛苦的。</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"将镜像推送到-docker-仓库-（需要登录-docker-login）\"><a href=\"#将镜像推送到-docker-仓库-（需要登录-docker-login）\" class=\"headerlink\" title=\"将镜像推送到 docker 仓库 （需要登录 docker login）\"></a>将镜像推送到 docker 仓库 （需要登录 docker login）</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker push 仓库名称/打包的镜像名称:标签</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"将本地镜像改名字-（标记本地镜像，将其归入某一仓库。）\"><a href=\"#将本地镜像改名字-（标记本地镜像，将其归入某一仓库。）\" class=\"headerlink\" title=\"将本地镜像改名字 （标记本地镜像，将其归入某一仓库。）\"></a>将本地镜像改名字 （标记本地镜像，将其归入某一仓库。）</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker tag IMAGEID(镜像id) REPOSITORY:TAG（仓库：标签）</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"docker-build-命令用于使用-Dockerfile-创建镜像。\"><a href=\"#docker-build-命令用于使用-Dockerfile-创建镜像。\" class=\"headerlink\" title=\"docker build 命令用于使用 Dockerfile 创建镜像。\"></a>docker build 命令用于使用 Dockerfile 创建镜像。</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">OPTIONS说明：</span><br><span class=\"line\">--build-arg=[] :设置镜像创建时的变量；</span><br><span class=\"line\"></span><br><span class=\"line\">--cpu-shares :设置 cpu 使用权重；</span><br><span class=\"line\"></span><br><span class=\"line\">--cpu-period :限制 CPU CFS周期；</span><br><span class=\"line\"></span><br><span class=\"line\">--cpu-quota :限制 CPU CFS配额；</span><br><span class=\"line\"></span><br><span class=\"line\">--cpuset-cpus :指定使用的CPU id；</span><br><span class=\"line\"></span><br><span class=\"line\">--cpuset-mems :指定使用的内存 id；</span><br><span class=\"line\"></span><br><span class=\"line\">--<span class=\"built_in\">disable</span>-content-trust :忽略校验，默认开启；</span><br><span class=\"line\"></span><br><span class=\"line\">-f :指定要使用的Dockerfile路径；</span><br><span class=\"line\"></span><br><span class=\"line\">--force-rm :设置镜像过程中删除中间容器；</span><br><span class=\"line\"></span><br><span class=\"line\">--isolation :使用容器隔离技术；</span><br><span class=\"line\"></span><br><span class=\"line\">--label=[] :设置镜像使用的元数据；</span><br><span class=\"line\"></span><br><span class=\"line\">-m :设置内存最大值；</span><br><span class=\"line\"></span><br><span class=\"line\">--memory-swap :设置Swap的最大值为内存+swap，<span class=\"string\">\"-1\"</span>表示不限swap；</span><br><span class=\"line\"></span><br><span class=\"line\">--no-cache :创建镜像的过程不使用缓存；</span><br><span class=\"line\"></span><br><span class=\"line\">--pull :尝试去更新镜像的新版本；</span><br><span class=\"line\"></span><br><span class=\"line\">--quiet, -q :安静模式，成功后只输出镜像 ID；</span><br><span class=\"line\"></span><br><span class=\"line\">--rm :设置镜像成功后删除中间容器；</span><br><span class=\"line\"></span><br><span class=\"line\">--shm-size :设置/dev/shm的大小，默认值是64M；</span><br><span class=\"line\"></span><br><span class=\"line\">--<span class=\"built_in\">ulimit</span> :Ulimit配置。</span><br><span class=\"line\"></span><br><span class=\"line\">--tag, -t: 镜像的名字及标签，通常 name:tag 或者 name 格式；可以在一次构建中为一个镜像设置多个标签。</span><br><span class=\"line\"></span><br><span class=\"line\">--network: 默认 default。在构建期间设置RUN指令的网络模式</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">使用当前目录的 Dockerfile 创建镜像，标签为 runoob/ubuntu:v1。</span><br><span class=\"line\"></span><br><span class=\"line\">$ docker build -t runoob/ubuntu:v1 .</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">有提到指令最后一个 . 是上下文路径</span><br><span class=\"line\"></span><br><span class=\"line\">上下文路径，是指 docker 在构建镜像，有时候想要使用到本机的文件（比如复制），docker build 命令得知这个路径后，会将路径下的所有内容打包。</span><br><span class=\"line\"></span><br><span class=\"line\">解析：由于 docker 的运行模式是 C/S。我们本机是 C，docker 引擎是 S。实际的构建过程是在 docker 引擎下完成的，所以这个时候无法用到我们本机的文件。这就需要把我们本机的指定目录下的文件一起打包提供给 docker 引擎使用。</span><br><span class=\"line\"></span><br><span class=\"line\">如果未说明最后一个参数，那么默认上下文路径就是 Dockerfile 所在的位置。</span><br><span class=\"line\"></span><br><span class=\"line\">注意：上下文路径下不要放无用的文件，因为会一起打包发送给 docker 引擎，如果文件过多会造成过程缓慢。</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Docker-Mechine\"><a href=\"#Docker-Mechine\" class=\"headerlink\" title=\"Docker Mechine\"></a>Docker Mechine</h2><p>Docker Machine 是一个工具，用来在虚拟主机上安装 Docker Engine，并使用 docker-machine 命令来管理这些虚拟主机。</p>\n"},{"title":"http 协议","_content":"\n## http 的隐患：\n\n1. 与服务器进行通信使用的是明文，内容可能会被窃听（HTTP 协议本身并不具备加密功能，所以无法对请求和响应的内容进行加密）\n2. 使用 HTTP 协议的服务器与客户端都不会验证通信方的身份，可能遭遇伪装。（所谓不验证通信方身份的意思是，比如说服务端，在服务端接收到请求的时候，只要请求的信息正确，服务器并不会去验证，这个请求是否由其对应的客户端发出。并且，服务器会对请求立即做出一次响应，返回相应的数据）\n3. 使用 HTTP 协议的服务器与客户端都无法验证报文的完整性，所以在通信过程中，报文有可能会被篡改等等。\n\n## 特点\n\n1. HTTP/1.0 一次只允许在一个 TCP 连接上发起一个请求；HTTP/1.1 流水线技术也只能部分处理请求并发，并仍然存在队列头阻塞问题，因此客户端在需要发起多次请求时，典型情况下，通常采用建立多连接来减少延迟。\n2. 单向请求，请求只能由客户端发起。\n3. 请求报文与响应报文首部信息冗余量大。\n4. 数据未压缩，数据传输量大。\n\n## https\n\n为了解决 http 协议的保密性（防泄密）、完整性（防篡改）、真实性（防假冒），发展出了 https 协议，HTTPS 是由 HTTP 协议+SSL 协议（TLS）构成。SSL 协议通过对信息进行加密，为网络通信提供安全保障。它运用了非对称密钥机制，这种机制是将公钥自由对外分发，而私钥只有信息接收者才有。简单的说，其实 HTTPS = HTTP + 加密 + 认证 + 完整性保护\n\nHTTP/2 的优势\n\n1. 相比 HTTP/1.x，HTTP/2 在底层传输做了很大的改动和优化\n2. HTTP/2 采用二进制格式传输数据，而非 HTTP/1.x 的文本格式。二进制格式在协议的解析和优化扩展上带来更多的优势和可能。\n3. HTTP/2 对消息头采用 HPACK 进行压缩传输，能够节省消息头占用的网络的流量。而 HTTP/1.x 每次请求，都会携带大量冗余头信息，浪费了很多带宽资源。头压缩能够很好的解决该问题。\n4. 多路复用，直白的说就是所有的请求都是通过一个 TCP 连接并发完成。HTTP/1.x 虽然能利用一个连接完成多次请求，但是多个请求之间是有先后顺序的，后面发送的请求必须等待上一个请求返回才能发送响应。这会很容易导致后面的请求被阻塞，而 HTTP/2 做到了真正的并发请求。同时， 流还支持优先级和流量控制。\n5. Server Push：服务端能够更快的把资源推送给客户端。例如服务端可以主动把 JS 和 CSS 文件推送给客户端，而不需要客户端解析 HTML 再发送这些请求。当客户端需要的时候，它已经在客户端了。\n\n**配置网站的 https:**\n\n1. 购买证书\n2. 修改 nginx 配置\n\n**小网站的 https**\n\n傻瓜式设置: **certbot**\n\n## 常见的状态码：\n\n- 200 OK 客户端请求成功\n- 301 Moved Permanently 请求永久重定向\n- 302 Moved Temporarily 请求临时重定向\n- 304 Not Modified 文件未修改，可以直接使用缓存的文件。\n- 400 Bad Request 由于客户端请求有语法错误，不能被服务器所理解。\n- 401 Unauthorized 请求未经授权。这个状态代码必须和 WWW-Authenticate 报头域一起使用\n- 403 Forbidden 服务器收到请求，但是拒绝提供服务。服务器通常会在响应正文中给出不提供服务的原因\n- 404 Not Found 请求的资源不存在，例如，输入了错误的 URL\n- 500 Internal Server Error 服务器发生不可预期的错误，导致无法完成客户端的请求。\n- 503 Service Unavailable 服务器当前不能够处理客户端的请求，在一段时间之后，服务器可能会恢复正常\n\n相关阅读：\n[http://www.ruanyifeng.com/blog/2016/08/http.html](http://www.ruanyifeng.com/blog/2016/08/http.html)\n","source":"_drafts/http-协议.md","raw":"---\ntitle: http 协议\ncategories:\ntags:\n---\n\n## http 的隐患：\n\n1. 与服务器进行通信使用的是明文，内容可能会被窃听（HTTP 协议本身并不具备加密功能，所以无法对请求和响应的内容进行加密）\n2. 使用 HTTP 协议的服务器与客户端都不会验证通信方的身份，可能遭遇伪装。（所谓不验证通信方身份的意思是，比如说服务端，在服务端接收到请求的时候，只要请求的信息正确，服务器并不会去验证，这个请求是否由其对应的客户端发出。并且，服务器会对请求立即做出一次响应，返回相应的数据）\n3. 使用 HTTP 协议的服务器与客户端都无法验证报文的完整性，所以在通信过程中，报文有可能会被篡改等等。\n\n## 特点\n\n1. HTTP/1.0 一次只允许在一个 TCP 连接上发起一个请求；HTTP/1.1 流水线技术也只能部分处理请求并发，并仍然存在队列头阻塞问题，因此客户端在需要发起多次请求时，典型情况下，通常采用建立多连接来减少延迟。\n2. 单向请求，请求只能由客户端发起。\n3. 请求报文与响应报文首部信息冗余量大。\n4. 数据未压缩，数据传输量大。\n\n## https\n\n为了解决 http 协议的保密性（防泄密）、完整性（防篡改）、真实性（防假冒），发展出了 https 协议，HTTPS 是由 HTTP 协议+SSL 协议（TLS）构成。SSL 协议通过对信息进行加密，为网络通信提供安全保障。它运用了非对称密钥机制，这种机制是将公钥自由对外分发，而私钥只有信息接收者才有。简单的说，其实 HTTPS = HTTP + 加密 + 认证 + 完整性保护\n\nHTTP/2 的优势\n\n1. 相比 HTTP/1.x，HTTP/2 在底层传输做了很大的改动和优化\n2. HTTP/2 采用二进制格式传输数据，而非 HTTP/1.x 的文本格式。二进制格式在协议的解析和优化扩展上带来更多的优势和可能。\n3. HTTP/2 对消息头采用 HPACK 进行压缩传输，能够节省消息头占用的网络的流量。而 HTTP/1.x 每次请求，都会携带大量冗余头信息，浪费了很多带宽资源。头压缩能够很好的解决该问题。\n4. 多路复用，直白的说就是所有的请求都是通过一个 TCP 连接并发完成。HTTP/1.x 虽然能利用一个连接完成多次请求，但是多个请求之间是有先后顺序的，后面发送的请求必须等待上一个请求返回才能发送响应。这会很容易导致后面的请求被阻塞，而 HTTP/2 做到了真正的并发请求。同时， 流还支持优先级和流量控制。\n5. Server Push：服务端能够更快的把资源推送给客户端。例如服务端可以主动把 JS 和 CSS 文件推送给客户端，而不需要客户端解析 HTML 再发送这些请求。当客户端需要的时候，它已经在客户端了。\n\n**配置网站的 https:**\n\n1. 购买证书\n2. 修改 nginx 配置\n\n**小网站的 https**\n\n傻瓜式设置: **certbot**\n\n## 常见的状态码：\n\n- 200 OK 客户端请求成功\n- 301 Moved Permanently 请求永久重定向\n- 302 Moved Temporarily 请求临时重定向\n- 304 Not Modified 文件未修改，可以直接使用缓存的文件。\n- 400 Bad Request 由于客户端请求有语法错误，不能被服务器所理解。\n- 401 Unauthorized 请求未经授权。这个状态代码必须和 WWW-Authenticate 报头域一起使用\n- 403 Forbidden 服务器收到请求，但是拒绝提供服务。服务器通常会在响应正文中给出不提供服务的原因\n- 404 Not Found 请求的资源不存在，例如，输入了错误的 URL\n- 500 Internal Server Error 服务器发生不可预期的错误，导致无法完成客户端的请求。\n- 503 Service Unavailable 服务器当前不能够处理客户端的请求，在一段时间之后，服务器可能会恢复正常\n\n相关阅读：\n[http://www.ruanyifeng.com/blog/2016/08/http.html](http://www.ruanyifeng.com/blog/2016/08/http.html)\n","slug":"http-协议","published":0,"date":"2019-10-21T07:24:25.623Z","updated":"2020-05-21T06:29:20.533Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckb1z4dff000m9n943u69rqvn","content":"<h2 id=\"http-的隐患：\"><a href=\"#http-的隐患：\" class=\"headerlink\" title=\"http 的隐患：\"></a>http 的隐患：</h2><ol>\n<li>与服务器进行通信使用的是明文，内容可能会被窃听（HTTP 协议本身并不具备加密功能，所以无法对请求和响应的内容进行加密）</li>\n<li>使用 HTTP 协议的服务器与客户端都不会验证通信方的身份，可能遭遇伪装。（所谓不验证通信方身份的意思是，比如说服务端，在服务端接收到请求的时候，只要请求的信息正确，服务器并不会去验证，这个请求是否由其对应的客户端发出。并且，服务器会对请求立即做出一次响应，返回相应的数据）</li>\n<li>使用 HTTP 协议的服务器与客户端都无法验证报文的完整性，所以在通信过程中，报文有可能会被篡改等等。</li>\n</ol>\n<h2 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h2><ol>\n<li>HTTP/1.0 一次只允许在一个 TCP 连接上发起一个请求；HTTP/1.1 流水线技术也只能部分处理请求并发，并仍然存在队列头阻塞问题，因此客户端在需要发起多次请求时，典型情况下，通常采用建立多连接来减少延迟。</li>\n<li>单向请求，请求只能由客户端发起。</li>\n<li>请求报文与响应报文首部信息冗余量大。</li>\n<li>数据未压缩，数据传输量大。</li>\n</ol>\n<h2 id=\"https\"><a href=\"#https\" class=\"headerlink\" title=\"https\"></a>https</h2><p>为了解决 http 协议的保密性（防泄密）、完整性（防篡改）、真实性（防假冒），发展出了 https 协议，HTTPS 是由 HTTP 协议+SSL 协议（TLS）构成。SSL 协议通过对信息进行加密，为网络通信提供安全保障。它运用了非对称密钥机制，这种机制是将公钥自由对外分发，而私钥只有信息接收者才有。简单的说，其实 HTTPS = HTTP + 加密 + 认证 + 完整性保护</p>\n<p>HTTP/2 的优势</p>\n<ol>\n<li>相比 HTTP/1.x，HTTP/2 在底层传输做了很大的改动和优化</li>\n<li>HTTP/2 采用二进制格式传输数据，而非 HTTP/1.x 的文本格式。二进制格式在协议的解析和优化扩展上带来更多的优势和可能。</li>\n<li>HTTP/2 对消息头采用 HPACK 进行压缩传输，能够节省消息头占用的网络的流量。而 HTTP/1.x 每次请求，都会携带大量冗余头信息，浪费了很多带宽资源。头压缩能够很好的解决该问题。</li>\n<li>多路复用，直白的说就是所有的请求都是通过一个 TCP 连接并发完成。HTTP/1.x 虽然能利用一个连接完成多次请求，但是多个请求之间是有先后顺序的，后面发送的请求必须等待上一个请求返回才能发送响应。这会很容易导致后面的请求被阻塞，而 HTTP/2 做到了真正的并发请求。同时， 流还支持优先级和流量控制。</li>\n<li>Server Push：服务端能够更快的把资源推送给客户端。例如服务端可以主动把 JS 和 CSS 文件推送给客户端，而不需要客户端解析 HTML 再发送这些请求。当客户端需要的时候，它已经在客户端了。</li>\n</ol>\n<p><strong>配置网站的 https:</strong></p>\n<ol>\n<li>购买证书</li>\n<li>修改 nginx 配置</li>\n</ol>\n<p><strong>小网站的 https</strong></p>\n<p>傻瓜式设置: <strong>certbot</strong></p>\n<h2 id=\"常见的状态码：\"><a href=\"#常见的状态码：\" class=\"headerlink\" title=\"常见的状态码：\"></a>常见的状态码：</h2><ul>\n<li>200 OK 客户端请求成功</li>\n<li>301 Moved Permanently 请求永久重定向</li>\n<li>302 Moved Temporarily 请求临时重定向</li>\n<li>304 Not Modified 文件未修改，可以直接使用缓存的文件。</li>\n<li>400 Bad Request 由于客户端请求有语法错误，不能被服务器所理解。</li>\n<li>401 Unauthorized 请求未经授权。这个状态代码必须和 WWW-Authenticate 报头域一起使用</li>\n<li>403 Forbidden 服务器收到请求，但是拒绝提供服务。服务器通常会在响应正文中给出不提供服务的原因</li>\n<li>404 Not Found 请求的资源不存在，例如，输入了错误的 URL</li>\n<li>500 Internal Server Error 服务器发生不可预期的错误，导致无法完成客户端的请求。</li>\n<li>503 Service Unavailable 服务器当前不能够处理客户端的请求，在一段时间之后，服务器可能会恢复正常</li>\n</ul>\n<p>相关阅读：<br><a href=\"http://www.ruanyifeng.com/blog/2016/08/http.html\" target=\"_blank\" rel=\"noopener\">http://www.ruanyifeng.com/blog/2016/08/http.html</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"http-的隐患：\"><a href=\"#http-的隐患：\" class=\"headerlink\" title=\"http 的隐患：\"></a>http 的隐患：</h2><ol>\n<li>与服务器进行通信使用的是明文，内容可能会被窃听（HTTP 协议本身并不具备加密功能，所以无法对请求和响应的内容进行加密）</li>\n<li>使用 HTTP 协议的服务器与客户端都不会验证通信方的身份，可能遭遇伪装。（所谓不验证通信方身份的意思是，比如说服务端，在服务端接收到请求的时候，只要请求的信息正确，服务器并不会去验证，这个请求是否由其对应的客户端发出。并且，服务器会对请求立即做出一次响应，返回相应的数据）</li>\n<li>使用 HTTP 协议的服务器与客户端都无法验证报文的完整性，所以在通信过程中，报文有可能会被篡改等等。</li>\n</ol>\n<h2 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h2><ol>\n<li>HTTP/1.0 一次只允许在一个 TCP 连接上发起一个请求；HTTP/1.1 流水线技术也只能部分处理请求并发，并仍然存在队列头阻塞问题，因此客户端在需要发起多次请求时，典型情况下，通常采用建立多连接来减少延迟。</li>\n<li>单向请求，请求只能由客户端发起。</li>\n<li>请求报文与响应报文首部信息冗余量大。</li>\n<li>数据未压缩，数据传输量大。</li>\n</ol>\n<h2 id=\"https\"><a href=\"#https\" class=\"headerlink\" title=\"https\"></a>https</h2><p>为了解决 http 协议的保密性（防泄密）、完整性（防篡改）、真实性（防假冒），发展出了 https 协议，HTTPS 是由 HTTP 协议+SSL 协议（TLS）构成。SSL 协议通过对信息进行加密，为网络通信提供安全保障。它运用了非对称密钥机制，这种机制是将公钥自由对外分发，而私钥只有信息接收者才有。简单的说，其实 HTTPS = HTTP + 加密 + 认证 + 完整性保护</p>\n<p>HTTP/2 的优势</p>\n<ol>\n<li>相比 HTTP/1.x，HTTP/2 在底层传输做了很大的改动和优化</li>\n<li>HTTP/2 采用二进制格式传输数据，而非 HTTP/1.x 的文本格式。二进制格式在协议的解析和优化扩展上带来更多的优势和可能。</li>\n<li>HTTP/2 对消息头采用 HPACK 进行压缩传输，能够节省消息头占用的网络的流量。而 HTTP/1.x 每次请求，都会携带大量冗余头信息，浪费了很多带宽资源。头压缩能够很好的解决该问题。</li>\n<li>多路复用，直白的说就是所有的请求都是通过一个 TCP 连接并发完成。HTTP/1.x 虽然能利用一个连接完成多次请求，但是多个请求之间是有先后顺序的，后面发送的请求必须等待上一个请求返回才能发送响应。这会很容易导致后面的请求被阻塞，而 HTTP/2 做到了真正的并发请求。同时， 流还支持优先级和流量控制。</li>\n<li>Server Push：服务端能够更快的把资源推送给客户端。例如服务端可以主动把 JS 和 CSS 文件推送给客户端，而不需要客户端解析 HTML 再发送这些请求。当客户端需要的时候，它已经在客户端了。</li>\n</ol>\n<p><strong>配置网站的 https:</strong></p>\n<ol>\n<li>购买证书</li>\n<li>修改 nginx 配置</li>\n</ol>\n<p><strong>小网站的 https</strong></p>\n<p>傻瓜式设置: <strong>certbot</strong></p>\n<h2 id=\"常见的状态码：\"><a href=\"#常见的状态码：\" class=\"headerlink\" title=\"常见的状态码：\"></a>常见的状态码：</h2><ul>\n<li>200 OK 客户端请求成功</li>\n<li>301 Moved Permanently 请求永久重定向</li>\n<li>302 Moved Temporarily 请求临时重定向</li>\n<li>304 Not Modified 文件未修改，可以直接使用缓存的文件。</li>\n<li>400 Bad Request 由于客户端请求有语法错误，不能被服务器所理解。</li>\n<li>401 Unauthorized 请求未经授权。这个状态代码必须和 WWW-Authenticate 报头域一起使用</li>\n<li>403 Forbidden 服务器收到请求，但是拒绝提供服务。服务器通常会在响应正文中给出不提供服务的原因</li>\n<li>404 Not Found 请求的资源不存在，例如，输入了错误的 URL</li>\n<li>500 Internal Server Error 服务器发生不可预期的错误，导致无法完成客户端的请求。</li>\n<li>503 Service Unavailable 服务器当前不能够处理客户端的请求，在一段时间之后，服务器可能会恢复正常</li>\n</ul>\n<p>相关阅读：<br><a href=\"http://www.ruanyifeng.com/blog/2016/08/http.html\" target=\"_blank\" rel=\"noopener\">http://www.ruanyifeng.com/blog/2016/08/http.html</a></p>\n"},{"title":"javascript基础","_content":"\n## 事件机制\n\n事件的三个阶段：\n\n1. 事件捕获\n2. 处于目标阶段\n3. 事件冒泡\n\n默认为事件冒泡\n\n## 浏览器页面渲染\n\n## 垃圾回收\n\n## 回流和重绘\n","source":"_drafts/javascript基础.md","raw":"---\ntitle: javascript基础\ncategories:\ntags:\n  - javascript\n---\n\n## 事件机制\n\n事件的三个阶段：\n\n1. 事件捕获\n2. 处于目标阶段\n3. 事件冒泡\n\n默认为事件冒泡\n\n## 浏览器页面渲染\n\n## 垃圾回收\n\n## 回流和重绘\n","slug":"javascript基础","published":0,"date":"2019-10-11T14:36:48.896Z","updated":"2019-10-11T14:47:00.727Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckb1z4dfh000n9n94pgbh8gdk","content":"<h2 id=\"事件机制\"><a href=\"#事件机制\" class=\"headerlink\" title=\"事件机制\"></a>事件机制</h2><p>事件的三个阶段：</p>\n<ol>\n<li>事件捕获</li>\n<li>处于目标阶段</li>\n<li>事件冒泡</li>\n</ol>\n<p>默认为事件冒泡</p>\n<h2 id=\"浏览器页面渲染\"><a href=\"#浏览器页面渲染\" class=\"headerlink\" title=\"浏览器页面渲染\"></a>浏览器页面渲染</h2><h2 id=\"垃圾回收\"><a href=\"#垃圾回收\" class=\"headerlink\" title=\"垃圾回收\"></a>垃圾回收</h2><h2 id=\"回流和重绘\"><a href=\"#回流和重绘\" class=\"headerlink\" title=\"回流和重绘\"></a>回流和重绘</h2>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"事件机制\"><a href=\"#事件机制\" class=\"headerlink\" title=\"事件机制\"></a>事件机制</h2><p>事件的三个阶段：</p>\n<ol>\n<li>事件捕获</li>\n<li>处于目标阶段</li>\n<li>事件冒泡</li>\n</ol>\n<p>默认为事件冒泡</p>\n<h2 id=\"浏览器页面渲染\"><a href=\"#浏览器页面渲染\" class=\"headerlink\" title=\"浏览器页面渲染\"></a>浏览器页面渲染</h2><h2 id=\"垃圾回收\"><a href=\"#垃圾回收\" class=\"headerlink\" title=\"垃圾回收\"></a>垃圾回收</h2><h2 id=\"回流和重绘\"><a href=\"#回流和重绘\" class=\"headerlink\" title=\"回流和重绘\"></a>回流和重绘</h2>"},{"title":"mvc和mvvm","_content":"\n## MVX\n\nMVX 的差异多在于 第 3 步\n\n1. MVC：Model 直接通知 View 更新 (不同 MVC 实现不同)\n2. MVP：Model 通知 Presenter 通知 View， Presenter 切断了 Model 和 View 的联系\n3. MVVW： 和 MVP 类似，不同点在于 Viewport 与 View 有一个绑定机制, 不需要 Viewport 显式通知 View 更新\n\n**MVX 的差别在于 Model 和 View 之间数据传递的方**\n\n## MVC\n\n如何设计一个程序的结构，这是一门专门的学问，叫做\"架构模式\"（architectural pattern），属于编程的方法论。\n\nMVC 模式就是架构模式的一种，它对我的启发特别大。我觉得它不仅适用于开发软件，也适用于其他广泛的设计和组织工作。\n\n下面是我对 MVC 模式的一些个人理解，不一定正确，主要用来整理思路。\n\nMVC 是三个单词的首字母缩写，它们是 Model（模型）、View（视图）和 Controller（控制）。所有通信都是单向的。\n\n这个模式认为，程序不论简单或复杂，从结构上看，都可以分成三层。\n\n```\n1）最上面的一层，是直接面向最终用户的\"视图层\"（View）。它是提供给用户的操作界面，是程序的外壳。\n\n2）最底下的一层，是核心的\"数据层\"（Model），也就是程序需要操作的数据或信息。\n\n3）中间的一层，就是\"控制层\"（Controller），它负责根据用户从\"视图层\"输入的指令，选取\"数据层\"中的数据，然后对其进行相应的操作，产生最终结果。\n```\n\n这三层是紧密联系在一起的，但又是互相独立的，每一层内部的变化不影响其他层。每一层都对外提供接口（Interface），供上面一层调用。这样一来，软件就可以实现模块化，修改外观或者变更数据都不用修改其他层，大大方便了维护和升级。\n\n控制器（Controller）- 负责转发请求，对请求进行处理。\n视图（View） - 界面设计人员进行图形界面设计。\n模型（Model） - 程序员编写程序应有的功能（实现算法等等）、数据库专家进行数据管理和数据库设计(可以实现具体的功能)。\n![]()\n\n## MVP\n\n### MVVM\n\nMVVM 模式将 Presenter 改名为 ViewModel，基本上与 MVP 模式完全一致。\n\n唯一的区别是，它采用双向绑定（data-binding）：View 的变动，自动反映在 ViewModel，反之亦然。Angular 和 Ember 都采用这种模式。\n\n相关阅读：\n[https://www.kancloud.cn/lixianshengdezhanghao/interview/904696](https://www.kancloud.cn/lixianshengdezhanghao/interview/904696)\n","source":"_drafts/mvc和mvvm.md","raw":"---\ntitle: mvc和mvvm\ncategories:\ntags:\n---\n\n## MVX\n\nMVX 的差异多在于 第 3 步\n\n1. MVC：Model 直接通知 View 更新 (不同 MVC 实现不同)\n2. MVP：Model 通知 Presenter 通知 View， Presenter 切断了 Model 和 View 的联系\n3. MVVW： 和 MVP 类似，不同点在于 Viewport 与 View 有一个绑定机制, 不需要 Viewport 显式通知 View 更新\n\n**MVX 的差别在于 Model 和 View 之间数据传递的方**\n\n## MVC\n\n如何设计一个程序的结构，这是一门专门的学问，叫做\"架构模式\"（architectural pattern），属于编程的方法论。\n\nMVC 模式就是架构模式的一种，它对我的启发特别大。我觉得它不仅适用于开发软件，也适用于其他广泛的设计和组织工作。\n\n下面是我对 MVC 模式的一些个人理解，不一定正确，主要用来整理思路。\n\nMVC 是三个单词的首字母缩写，它们是 Model（模型）、View（视图）和 Controller（控制）。所有通信都是单向的。\n\n这个模式认为，程序不论简单或复杂，从结构上看，都可以分成三层。\n\n```\n1）最上面的一层，是直接面向最终用户的\"视图层\"（View）。它是提供给用户的操作界面，是程序的外壳。\n\n2）最底下的一层，是核心的\"数据层\"（Model），也就是程序需要操作的数据或信息。\n\n3）中间的一层，就是\"控制层\"（Controller），它负责根据用户从\"视图层\"输入的指令，选取\"数据层\"中的数据，然后对其进行相应的操作，产生最终结果。\n```\n\n这三层是紧密联系在一起的，但又是互相独立的，每一层内部的变化不影响其他层。每一层都对外提供接口（Interface），供上面一层调用。这样一来，软件就可以实现模块化，修改外观或者变更数据都不用修改其他层，大大方便了维护和升级。\n\n控制器（Controller）- 负责转发请求，对请求进行处理。\n视图（View） - 界面设计人员进行图形界面设计。\n模型（Model） - 程序员编写程序应有的功能（实现算法等等）、数据库专家进行数据管理和数据库设计(可以实现具体的功能)。\n![]()\n\n## MVP\n\n### MVVM\n\nMVVM 模式将 Presenter 改名为 ViewModel，基本上与 MVP 模式完全一致。\n\n唯一的区别是，它采用双向绑定（data-binding）：View 的变动，自动反映在 ViewModel，反之亦然。Angular 和 Ember 都采用这种模式。\n\n相关阅读：\n[https://www.kancloud.cn/lixianshengdezhanghao/interview/904696](https://www.kancloud.cn/lixianshengdezhanghao/interview/904696)\n","slug":"mvc和mvvm","published":0,"date":"2019-09-26T07:56:04.639Z","updated":"2019-10-18T07:58:11.784Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckb1z4dfi000p9n94zhkoxy6h","content":"<h2 id=\"MVX\"><a href=\"#MVX\" class=\"headerlink\" title=\"MVX\"></a>MVX</h2><p>MVX 的差异多在于 第 3 步</p>\n<ol>\n<li>MVC：Model 直接通知 View 更新 (不同 MVC 实现不同)</li>\n<li>MVP：Model 通知 Presenter 通知 View， Presenter 切断了 Model 和 View 的联系</li>\n<li>MVVW： 和 MVP 类似，不同点在于 Viewport 与 View 有一个绑定机制, 不需要 Viewport 显式通知 View 更新</li>\n</ol>\n<p><strong>MVX 的差别在于 Model 和 View 之间数据传递的方</strong></p>\n<h2 id=\"MVC\"><a href=\"#MVC\" class=\"headerlink\" title=\"MVC\"></a>MVC</h2><p>如何设计一个程序的结构，这是一门专门的学问，叫做”架构模式”（architectural pattern），属于编程的方法论。</p>\n<p>MVC 模式就是架构模式的一种，它对我的启发特别大。我觉得它不仅适用于开发软件，也适用于其他广泛的设计和组织工作。</p>\n<p>下面是我对 MVC 模式的一些个人理解，不一定正确，主要用来整理思路。</p>\n<p>MVC 是三个单词的首字母缩写，它们是 Model（模型）、View（视图）和 Controller（控制）。所有通信都是单向的。</p>\n<p>这个模式认为，程序不论简单或复杂，从结构上看，都可以分成三层。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1）最上面的一层，是直接面向最终用户的&quot;视图层&quot;（View）。它是提供给用户的操作界面，是程序的外壳。</span><br><span class=\"line\"></span><br><span class=\"line\">2）最底下的一层，是核心的&quot;数据层&quot;（Model），也就是程序需要操作的数据或信息。</span><br><span class=\"line\"></span><br><span class=\"line\">3）中间的一层，就是&quot;控制层&quot;（Controller），它负责根据用户从&quot;视图层&quot;输入的指令，选取&quot;数据层&quot;中的数据，然后对其进行相应的操作，产生最终结果。</span><br></pre></td></tr></table></figure>\n\n<p>这三层是紧密联系在一起的，但又是互相独立的，每一层内部的变化不影响其他层。每一层都对外提供接口（Interface），供上面一层调用。这样一来，软件就可以实现模块化，修改外观或者变更数据都不用修改其他层，大大方便了维护和升级。</p>\n<p>控制器（Controller）- 负责转发请求，对请求进行处理。<br>视图（View） - 界面设计人员进行图形界面设计。<br>模型（Model） - 程序员编写程序应有的功能（实现算法等等）、数据库专家进行数据管理和数据库设计(可以实现具体的功能)。<br><img src alt></p>\n<h2 id=\"MVP\"><a href=\"#MVP\" class=\"headerlink\" title=\"MVP\"></a>MVP</h2><h3 id=\"MVVM\"><a href=\"#MVVM\" class=\"headerlink\" title=\"MVVM\"></a>MVVM</h3><p>MVVM 模式将 Presenter 改名为 ViewModel，基本上与 MVP 模式完全一致。</p>\n<p>唯一的区别是，它采用双向绑定（data-binding）：View 的变动，自动反映在 ViewModel，反之亦然。Angular 和 Ember 都采用这种模式。</p>\n<p>相关阅读：<br><a href=\"https://www.kancloud.cn/lixianshengdezhanghao/interview/904696\" target=\"_blank\" rel=\"noopener\">https://www.kancloud.cn/lixianshengdezhanghao/interview/904696</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"MVX\"><a href=\"#MVX\" class=\"headerlink\" title=\"MVX\"></a>MVX</h2><p>MVX 的差异多在于 第 3 步</p>\n<ol>\n<li>MVC：Model 直接通知 View 更新 (不同 MVC 实现不同)</li>\n<li>MVP：Model 通知 Presenter 通知 View， Presenter 切断了 Model 和 View 的联系</li>\n<li>MVVW： 和 MVP 类似，不同点在于 Viewport 与 View 有一个绑定机制, 不需要 Viewport 显式通知 View 更新</li>\n</ol>\n<p><strong>MVX 的差别在于 Model 和 View 之间数据传递的方</strong></p>\n<h2 id=\"MVC\"><a href=\"#MVC\" class=\"headerlink\" title=\"MVC\"></a>MVC</h2><p>如何设计一个程序的结构，这是一门专门的学问，叫做”架构模式”（architectural pattern），属于编程的方法论。</p>\n<p>MVC 模式就是架构模式的一种，它对我的启发特别大。我觉得它不仅适用于开发软件，也适用于其他广泛的设计和组织工作。</p>\n<p>下面是我对 MVC 模式的一些个人理解，不一定正确，主要用来整理思路。</p>\n<p>MVC 是三个单词的首字母缩写，它们是 Model（模型）、View（视图）和 Controller（控制）。所有通信都是单向的。</p>\n<p>这个模式认为，程序不论简单或复杂，从结构上看，都可以分成三层。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1）最上面的一层，是直接面向最终用户的&quot;视图层&quot;（View）。它是提供给用户的操作界面，是程序的外壳。</span><br><span class=\"line\"></span><br><span class=\"line\">2）最底下的一层，是核心的&quot;数据层&quot;（Model），也就是程序需要操作的数据或信息。</span><br><span class=\"line\"></span><br><span class=\"line\">3）中间的一层，就是&quot;控制层&quot;（Controller），它负责根据用户从&quot;视图层&quot;输入的指令，选取&quot;数据层&quot;中的数据，然后对其进行相应的操作，产生最终结果。</span><br></pre></td></tr></table></figure>\n\n<p>这三层是紧密联系在一起的，但又是互相独立的，每一层内部的变化不影响其他层。每一层都对外提供接口（Interface），供上面一层调用。这样一来，软件就可以实现模块化，修改外观或者变更数据都不用修改其他层，大大方便了维护和升级。</p>\n<p>控制器（Controller）- 负责转发请求，对请求进行处理。<br>视图（View） - 界面设计人员进行图形界面设计。<br>模型（Model） - 程序员编写程序应有的功能（实现算法等等）、数据库专家进行数据管理和数据库设计(可以实现具体的功能)。<br><img src alt></p>\n<h2 id=\"MVP\"><a href=\"#MVP\" class=\"headerlink\" title=\"MVP\"></a>MVP</h2><h3 id=\"MVVM\"><a href=\"#MVVM\" class=\"headerlink\" title=\"MVVM\"></a>MVVM</h3><p>MVVM 模式将 Presenter 改名为 ViewModel，基本上与 MVP 模式完全一致。</p>\n<p>唯一的区别是，它采用双向绑定（data-binding）：View 的变动，自动反映在 ViewModel，反之亦然。Angular 和 Ember 都采用这种模式。</p>\n<p>相关阅读：<br><a href=\"https://www.kancloud.cn/lixianshengdezhanghao/interview/904696\" target=\"_blank\" rel=\"noopener\">https://www.kancloud.cn/lixianshengdezhanghao/interview/904696</a></p>\n"},{"title":"taro","_content":"\n- Question\n  当前您正在使用 Taro 2.0 版本，请先执行 taro doctor 确保编译配置正确\n  如出现令你束手无策的问题，请使用 taro update 命令更新到你指定的稳定版本\n","source":"_drafts/taro.md","raw":"---\ntitle: taro\ncategories:\ntags:\n---\n\n- Question\n  当前您正在使用 Taro 2.0 版本，请先执行 taro doctor 确保编译配置正确\n  如出现令你束手无策的问题，请使用 taro update 命令更新到你指定的稳定版本\n","slug":"taro","published":0,"date":"2020-04-13T06:48:50.555Z","updated":"2020-04-13T06:49:15.050Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckb1z4dfj000r9n94lznkrm6b","content":"<ul>\n<li>Question<br>当前您正在使用 Taro 2.0 版本，请先执行 taro doctor 确保编译配置正确<br>如出现令你束手无策的问题，请使用 taro update 命令更新到你指定的稳定版本</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li>Question<br>当前您正在使用 Taro 2.0 版本，请先执行 taro doctor 确保编译配置正确<br>如出现令你束手无策的问题，请使用 taro update 命令更新到你指定的稳定版本</li>\n</ul>\n"},{"title":"npm-typescript","_content":"\n## 步骤\n\n- 初始化文件夹，初始化 git 仓库，初始化 npm，初始化 tsc\n- 修改 tsconfig.js 配置\n- 添加 npm 脚本\n- 添加 tslint 校验代码规则以及 editorconfig,prettier 统一代码风格\n- 设置 git 提交的校验钩子\n- 开始编写代码\n- watch 模式开发\n- 忽略 ts 编译生成的文件夹\n- 添加单元测试\n- 写一个单元测试示例\n- 设置一些有用的 npm 脚本\n- 完善 package.json 的描述信息\n- 提交代码到 git 仓库\n- 发布包到 npm。\n","source":"_drafts/npm-typescript.md","raw":"---\ntitle: npm-typescript\ncategories:\ntags:\n---\n\n## 步骤\n\n- 初始化文件夹，初始化 git 仓库，初始化 npm，初始化 tsc\n- 修改 tsconfig.js 配置\n- 添加 npm 脚本\n- 添加 tslint 校验代码规则以及 editorconfig,prettier 统一代码风格\n- 设置 git 提交的校验钩子\n- 开始编写代码\n- watch 模式开发\n- 忽略 ts 编译生成的文件夹\n- 添加单元测试\n- 写一个单元测试示例\n- 设置一些有用的 npm 脚本\n- 完善 package.json 的描述信息\n- 提交代码到 git 仓库\n- 发布包到 npm。\n","slug":"npm-typescript","published":0,"date":"2019-11-14T08:44:45.520Z","updated":"2019-11-14T08:45:42.915Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckb1z4dfk000t9n94nwaiph5v","content":"<h2 id=\"步骤\"><a href=\"#步骤\" class=\"headerlink\" title=\"步骤\"></a>步骤</h2><ul>\n<li>初始化文件夹，初始化 git 仓库，初始化 npm，初始化 tsc</li>\n<li>修改 tsconfig.js 配置</li>\n<li>添加 npm 脚本</li>\n<li>添加 tslint 校验代码规则以及 editorconfig,prettier 统一代码风格</li>\n<li>设置 git 提交的校验钩子</li>\n<li>开始编写代码</li>\n<li>watch 模式开发</li>\n<li>忽略 ts 编译生成的文件夹</li>\n<li>添加单元测试</li>\n<li>写一个单元测试示例</li>\n<li>设置一些有用的 npm 脚本</li>\n<li>完善 package.json 的描述信息</li>\n<li>提交代码到 git 仓库</li>\n<li>发布包到 npm。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"步骤\"><a href=\"#步骤\" class=\"headerlink\" title=\"步骤\"></a>步骤</h2><ul>\n<li>初始化文件夹，初始化 git 仓库，初始化 npm，初始化 tsc</li>\n<li>修改 tsconfig.js 配置</li>\n<li>添加 npm 脚本</li>\n<li>添加 tslint 校验代码规则以及 editorconfig,prettier 统一代码风格</li>\n<li>设置 git 提交的校验钩子</li>\n<li>开始编写代码</li>\n<li>watch 模式开发</li>\n<li>忽略 ts 编译生成的文件夹</li>\n<li>添加单元测试</li>\n<li>写一个单元测试示例</li>\n<li>设置一些有用的 npm 脚本</li>\n<li>完善 package.json 的描述信息</li>\n<li>提交代码到 git 仓库</li>\n<li>发布包到 npm。</li>\n</ul>\n"},{"title":"vuex","_content":"\nMutation 需遵守 Vue 的响应规则\n既然 Vuex 的 store 中的状态是响应式的，那么当我们变更状态时，监视状态的 Vue 组件也会自动更新。这也意味着 Vuex 中的 mutation 也需要与使用 Vue 一样遵守一些注意事项：\n\n最好提前在你的 store 中初始化好所有所需属性。\n\n当需要在对象上添加新属性时，你应该\n\n使用 Vue.set(obj, 'newProp', 123), 或者\n\n以新对象替换老对象。例如，利用 stage-3 的对象展开运算符我们可以这样写：\n\n相关阅读；\n\n[vuex modules](https://www.mmxiaowu.com/article/591a74f60ef91a5c93a340c4)\n","source":"_drafts/vuex.md","raw":"---\ntitle: vuex\ncategories:\ntags:\n---\n\nMutation 需遵守 Vue 的响应规则\n既然 Vuex 的 store 中的状态是响应式的，那么当我们变更状态时，监视状态的 Vue 组件也会自动更新。这也意味着 Vuex 中的 mutation 也需要与使用 Vue 一样遵守一些注意事项：\n\n最好提前在你的 store 中初始化好所有所需属性。\n\n当需要在对象上添加新属性时，你应该\n\n使用 Vue.set(obj, 'newProp', 123), 或者\n\n以新对象替换老对象。例如，利用 stage-3 的对象展开运算符我们可以这样写：\n\n相关阅读；\n\n[vuex modules](https://www.mmxiaowu.com/article/591a74f60ef91a5c93a340c4)\n","slug":"vuex","published":0,"date":"2019-10-03T01:55:10.863Z","updated":"2019-10-04T08:33:43.253Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckb1z4dfk000w9n94uwphe56a","content":"<p>Mutation 需遵守 Vue 的响应规则<br>既然 Vuex 的 store 中的状态是响应式的，那么当我们变更状态时，监视状态的 Vue 组件也会自动更新。这也意味着 Vuex 中的 mutation 也需要与使用 Vue 一样遵守一些注意事项：</p>\n<p>最好提前在你的 store 中初始化好所有所需属性。</p>\n<p>当需要在对象上添加新属性时，你应该</p>\n<p>使用 Vue.set(obj, ‘newProp’, 123), 或者</p>\n<p>以新对象替换老对象。例如，利用 stage-3 的对象展开运算符我们可以这样写：</p>\n<p>相关阅读；</p>\n<p><a href=\"https://www.mmxiaowu.com/article/591a74f60ef91a5c93a340c4\" target=\"_blank\" rel=\"noopener\">vuex modules</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Mutation 需遵守 Vue 的响应规则<br>既然 Vuex 的 store 中的状态是响应式的，那么当我们变更状态时，监视状态的 Vue 组件也会自动更新。这也意味着 Vuex 中的 mutation 也需要与使用 Vue 一样遵守一些注意事项：</p>\n<p>最好提前在你的 store 中初始化好所有所需属性。</p>\n<p>当需要在对象上添加新属性时，你应该</p>\n<p>使用 Vue.set(obj, ‘newProp’, 123), 或者</p>\n<p>以新对象替换老对象。例如，利用 stage-3 的对象展开运算符我们可以这样写：</p>\n<p>相关阅读；</p>\n<p><a href=\"https://www.mmxiaowu.com/article/591a74f60ef91a5c93a340c4\" target=\"_blank\" rel=\"noopener\">vuex modules</a></p>\n"},{"title":"vue3ts","_content":"\n## 插件\n\n[vue-class-component](https://github.com/vuejs/vue-class-component)\n强化 Vue 组件，使用 TypeScript/装饰器 增强 Vue 组件\n[vue-property-decorator](https://github.com/kaorun343/vue-property-decorator)\n在 vue-class-component 上增强更多的结合 Vue 特性的装饰器\n[vuex-class](https://github.com/ktsn/vuex-class)\n基于 vue-class-component 对 Vuex 提供的装饰器\n\n## 在已创建的项目中安装\n\n```\nvue3.0\n\nvue add @vue/typescript\n```\n\n## 相关文件解释\n\n**shims-tsx.d.ts，允许你以.tsx 结尾的文件，在 Vue 项目中编写 jsx 代码,, 在全局变量 global 中批量命名了数个内部模块**\n\n**shims-vue.d.ts 主要用于 TypeScript 识别.vue 文件，Ts 默认并不支持导入 vue 文件，这个文件告诉 ts 导入.vue 文件都按 VueConstructor<Vue>处理。**\n\n**declare：当使用第三方库时，我们需要引用它的声明文件，才能获得对应的代码补全、接口提示等功能。**\n\n这里列举出几个常用的：\n\n```declare var 声明全局变量\ndeclare function 声明全局方法\ndeclare class 声明全局类\ndeclare enum 声明全局枚举类型\ndeclare global 扩展全局变量\ndeclare module 扩展模块\n复制代码 namespace：“内部模块”现在称做“命名空间”\nmodule X { 相当于现在推荐的写法 namespace X {)\n```\n","source":"_drafts/vue3ts.md","raw":"---\ntitle: vue3ts\ncategories:\ntags:\n  - vue\n  - typescript\n---\n\n## 插件\n\n[vue-class-component](https://github.com/vuejs/vue-class-component)\n强化 Vue 组件，使用 TypeScript/装饰器 增强 Vue 组件\n[vue-property-decorator](https://github.com/kaorun343/vue-property-decorator)\n在 vue-class-component 上增强更多的结合 Vue 特性的装饰器\n[vuex-class](https://github.com/ktsn/vuex-class)\n基于 vue-class-component 对 Vuex 提供的装饰器\n\n## 在已创建的项目中安装\n\n```\nvue3.0\n\nvue add @vue/typescript\n```\n\n## 相关文件解释\n\n**shims-tsx.d.ts，允许你以.tsx 结尾的文件，在 Vue 项目中编写 jsx 代码,, 在全局变量 global 中批量命名了数个内部模块**\n\n**shims-vue.d.ts 主要用于 TypeScript 识别.vue 文件，Ts 默认并不支持导入 vue 文件，这个文件告诉 ts 导入.vue 文件都按 VueConstructor<Vue>处理。**\n\n**declare：当使用第三方库时，我们需要引用它的声明文件，才能获得对应的代码补全、接口提示等功能。**\n\n这里列举出几个常用的：\n\n```declare var 声明全局变量\ndeclare function 声明全局方法\ndeclare class 声明全局类\ndeclare enum 声明全局枚举类型\ndeclare global 扩展全局变量\ndeclare module 扩展模块\n复制代码 namespace：“内部模块”现在称做“命名空间”\nmodule X { 相当于现在推荐的写法 namespace X {)\n```\n","slug":"vue3ts","published":0,"date":"2019-10-03T02:49:55.298Z","updated":"2019-10-03T06:48:10.984Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckb1z4dfl000x9n94t65twyap","content":"<h2 id=\"插件\"><a href=\"#插件\" class=\"headerlink\" title=\"插件\"></a>插件</h2><p><a href=\"https://github.com/vuejs/vue-class-component\" target=\"_blank\" rel=\"noopener\">vue-class-component</a><br>强化 Vue 组件，使用 TypeScript/装饰器 增强 Vue 组件<br><a href=\"https://github.com/kaorun343/vue-property-decorator\" target=\"_blank\" rel=\"noopener\">vue-property-decorator</a><br>在 vue-class-component 上增强更多的结合 Vue 特性的装饰器<br><a href=\"https://github.com/ktsn/vuex-class\" target=\"_blank\" rel=\"noopener\">vuex-class</a><br>基于 vue-class-component 对 Vuex 提供的装饰器</p>\n<h2 id=\"在已创建的项目中安装\"><a href=\"#在已创建的项目中安装\" class=\"headerlink\" title=\"在已创建的项目中安装\"></a>在已创建的项目中安装</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vue3.0</span><br><span class=\"line\"></span><br><span class=\"line\">vue add @vue/typescript</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"相关文件解释\"><a href=\"#相关文件解释\" class=\"headerlink\" title=\"相关文件解释\"></a>相关文件解释</h2><p><strong>shims-tsx.d.ts，允许你以.tsx 结尾的文件，在 Vue 项目中编写 jsx 代码,, 在全局变量 global 中批量命名了数个内部模块</strong></p>\n<p><strong>shims-vue.d.ts 主要用于 TypeScript 识别.vue 文件，Ts 默认并不支持导入 vue 文件，这个文件告诉 ts 导入.vue 文件都按 VueConstructor<vue>处理。</vue></strong></p>\n<p><strong>declare：当使用第三方库时，我们需要引用它的声明文件，才能获得对应的代码补全、接口提示等功能。</strong></p>\n<p>这里列举出几个常用的：</p>\n<figure class=\"highlight plain\"><figcaption><span>var 声明全局变量</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">declare function 声明全局方法</span><br><span class=\"line\">declare class 声明全局类</span><br><span class=\"line\">declare enum 声明全局枚举类型</span><br><span class=\"line\">declare global 扩展全局变量</span><br><span class=\"line\">declare module 扩展模块</span><br><span class=\"line\">复制代码 namespace：“内部模块”现在称做“命名空间”</span><br><span class=\"line\">module X &#123; 相当于现在推荐的写法 namespace X &#123;)</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"插件\"><a href=\"#插件\" class=\"headerlink\" title=\"插件\"></a>插件</h2><p><a href=\"https://github.com/vuejs/vue-class-component\" target=\"_blank\" rel=\"noopener\">vue-class-component</a><br>强化 Vue 组件，使用 TypeScript/装饰器 增强 Vue 组件<br><a href=\"https://github.com/kaorun343/vue-property-decorator\" target=\"_blank\" rel=\"noopener\">vue-property-decorator</a><br>在 vue-class-component 上增强更多的结合 Vue 特性的装饰器<br><a href=\"https://github.com/ktsn/vuex-class\" target=\"_blank\" rel=\"noopener\">vuex-class</a><br>基于 vue-class-component 对 Vuex 提供的装饰器</p>\n<h2 id=\"在已创建的项目中安装\"><a href=\"#在已创建的项目中安装\" class=\"headerlink\" title=\"在已创建的项目中安装\"></a>在已创建的项目中安装</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vue3.0</span><br><span class=\"line\"></span><br><span class=\"line\">vue add @vue/typescript</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"相关文件解释\"><a href=\"#相关文件解释\" class=\"headerlink\" title=\"相关文件解释\"></a>相关文件解释</h2><p><strong>shims-tsx.d.ts，允许你以.tsx 结尾的文件，在 Vue 项目中编写 jsx 代码,, 在全局变量 global 中批量命名了数个内部模块</strong></p>\n<p><strong>shims-vue.d.ts 主要用于 TypeScript 识别.vue 文件，Ts 默认并不支持导入 vue 文件，这个文件告诉 ts 导入.vue 文件都按 VueConstructor<vue>处理。</vue></strong></p>\n<p><strong>declare：当使用第三方库时，我们需要引用它的声明文件，才能获得对应的代码补全、接口提示等功能。</strong></p>\n<p>这里列举出几个常用的：</p>\n<figure class=\"highlight plain\"><figcaption><span>var 声明全局变量</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">declare function 声明全局方法</span><br><span class=\"line\">declare class 声明全局类</span><br><span class=\"line\">declare enum 声明全局枚举类型</span><br><span class=\"line\">declare global 扩展全局变量</span><br><span class=\"line\">declare module 扩展模块</span><br><span class=\"line\">复制代码 namespace：“内部模块”现在称做“命名空间”</span><br><span class=\"line\">module X &#123; 相当于现在推荐的写法 namespace X &#123;)</span><br></pre></td></tr></table></figure>\n\n"},{"title":"vue知识点","_content":"\n## vue 中 computed、method、watch 区别\n\ncomputed\n计算属性不能是在 data 里定义过的\ncomputed 比较适合对多个变量或者对象进行处理后返回一个结果值，也就是数多个变量中的某一个值发生了变化则我们监控的这个值也就会发生变化，举例：购物车里面的商品列表和总金额之间的关系，只要商品列表里面的商品数量发生变化，或减少或增多或删除商品，总金额都应该发生变化\n在 Vue 中计算属性是基于它们的依赖进行缓存的，而方法是不会基于它们的依赖进行缓存的。从而使用 computed 属性要比 method 性能更好。\ncomputed 有缓存，若相关数据未发生变化，则不调用；\n\nmethod\n通过触发一个事件或者函数的回调来实现数据的更新，他的执行，依赖于事件的触发\n\nwatch\nwatch 主要用于监控 vue 实例的变化，它监控的变量当然必须在 data 里面声明才可以，它是监控单个变量或对象\n消耗比较大\nwatch 多用于数据交互频繁的内容。（例如定时 axios 从服务器获取数据）\n","source":"_drafts/vue知识点.md","raw":"---\ntitle: vue知识点\ncategories:\ntags:\n---\n\n## vue 中 computed、method、watch 区别\n\ncomputed\n计算属性不能是在 data 里定义过的\ncomputed 比较适合对多个变量或者对象进行处理后返回一个结果值，也就是数多个变量中的某一个值发生了变化则我们监控的这个值也就会发生变化，举例：购物车里面的商品列表和总金额之间的关系，只要商品列表里面的商品数量发生变化，或减少或增多或删除商品，总金额都应该发生变化\n在 Vue 中计算属性是基于它们的依赖进行缓存的，而方法是不会基于它们的依赖进行缓存的。从而使用 computed 属性要比 method 性能更好。\ncomputed 有缓存，若相关数据未发生变化，则不调用；\n\nmethod\n通过触发一个事件或者函数的回调来实现数据的更新，他的执行，依赖于事件的触发\n\nwatch\nwatch 主要用于监控 vue 实例的变化，它监控的变量当然必须在 data 里面声明才可以，它是监控单个变量或对象\n消耗比较大\nwatch 多用于数据交互频繁的内容。（例如定时 axios 从服务器获取数据）\n","slug":"vue知识点","published":0,"date":"2019-10-14T05:55:02.511Z","updated":"2019-10-14T05:55:34.682Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckb1z4dfm000y9n946gi5jtka","content":"<h2 id=\"vue-中-computed、method、watch-区别\"><a href=\"#vue-中-computed、method、watch-区别\" class=\"headerlink\" title=\"vue 中 computed、method、watch 区别\"></a>vue 中 computed、method、watch 区别</h2><p>computed<br>计算属性不能是在 data 里定义过的<br>computed 比较适合对多个变量或者对象进行处理后返回一个结果值，也就是数多个变量中的某一个值发生了变化则我们监控的这个值也就会发生变化，举例：购物车里面的商品列表和总金额之间的关系，只要商品列表里面的商品数量发生变化，或减少或增多或删除商品，总金额都应该发生变化<br>在 Vue 中计算属性是基于它们的依赖进行缓存的，而方法是不会基于它们的依赖进行缓存的。从而使用 computed 属性要比 method 性能更好。<br>computed 有缓存，若相关数据未发生变化，则不调用；</p>\n<p>method<br>通过触发一个事件或者函数的回调来实现数据的更新，他的执行，依赖于事件的触发</p>\n<p>watch<br>watch 主要用于监控 vue 实例的变化，它监控的变量当然必须在 data 里面声明才可以，它是监控单个变量或对象<br>消耗比较大<br>watch 多用于数据交互频繁的内容。（例如定时 axios 从服务器获取数据）</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"vue-中-computed、method、watch-区别\"><a href=\"#vue-中-computed、method、watch-区别\" class=\"headerlink\" title=\"vue 中 computed、method、watch 区别\"></a>vue 中 computed、method、watch 区别</h2><p>computed<br>计算属性不能是在 data 里定义过的<br>computed 比较适合对多个变量或者对象进行处理后返回一个结果值，也就是数多个变量中的某一个值发生了变化则我们监控的这个值也就会发生变化，举例：购物车里面的商品列表和总金额之间的关系，只要商品列表里面的商品数量发生变化，或减少或增多或删除商品，总金额都应该发生变化<br>在 Vue 中计算属性是基于它们的依赖进行缓存的，而方法是不会基于它们的依赖进行缓存的。从而使用 computed 属性要比 method 性能更好。<br>computed 有缓存，若相关数据未发生变化，则不调用；</p>\n<p>method<br>通过触发一个事件或者函数的回调来实现数据的更新，他的执行，依赖于事件的触发</p>\n<p>watch<br>watch 主要用于监控 vue 实例的变化，它监控的变量当然必须在 data 里面声明才可以，它是监控单个变量或对象<br>消耗比较大<br>watch 多用于数据交互频繁的内容。（例如定时 axios 从服务器获取数据）</p>\n"},{"title":"vue 打包优化","_content":"\n关键词:\n`webpack开启gzip压缩`、`nginx开启gzip压缩`、`使用cdn`、`vue懒加载`\n\n## 项目打包\n\n#### webpack-bundle-analyzer\n\n**如何分析问题**\n\n首先我们先了解一下`webpack-bundle-analyzer`这个插件，[npm](https://www.npmjs.com/package/webpack-bundle-analyzer)、[github](https://github.com/webpack-contrib/webpack-bundle-analyzer),详细的知识点看 github 官网就好,**一遍看不懂就多看几遍!!!** **一遍看不懂就多看几遍!!!** **一遍看不懂就多看几遍!!!**\n\n这里分别讲解一下`vue-cli2.0`和`vue-cli3.0`中具体的用法\n\n##### **vue-cli2.0 中`webpack-bundle-analyzer`的用法**\n\n1. 安装 webpack-bundle-analyzer， `cnpm i -D webpack-bundle-analyzer`\n2. 在`package.json`文件中的 scripts 字段中加入\n   `\"analyze\": \"NODE_ENV=production npm_config_report=true npm run build\"`\n\n   <!-- 命令的意思是：设置`NODE_ENV`为`production` 、`npm_config_report`为`true`，然后运行`npm run build` -->\n\n3. 打开`build`目录中的`webpack.prod.conf.js`，加入如下代码\n\n   ```\n   自定义配置：\n   if (process.env.npm_config_report) {\n     const BundleAnalyzerPlugin = require(\"webpack-bundle-analyzer\").BundleAnalyzerPlugin;\n     webpackConfig.plugins.push(\n       new BundleAnalyzerPlugin({\n         analyzerMode: \"server\",\n         analyzerHost: \"127.0.0.1\",\n         analyzerPort: 8887,\n         reportFilename: \"report.html\",\n         defaultSizes: \"parsed\",\n         openAnalyzer: true,\n         generateStatsFile: false,\n         statsFilename: \"stats.json\",\n         statsOptions: null,\n         logLevel: \"info\"\n       })\n     );\n   }\n\n   默认配置：\n   if (process.env.npm_config_report) {\n     const BundleAnalyzerPlugin = require(\"webpack-bundle-analyzer\").BundleAnalyzerPlugin;\n     webpackConfig.plugins.push(BundleAnalyzerPlugin);\n   }\n   ```\n\n4. 运行命令`npm run analyze`，浏览器会自动打开[http://127.0.0.1:8887](http://127.0.0.1:8887)(根据第三步配置的参数)\n\n##### **vue-cli3.0 中`webpack-bundle-analyzer`的用法**\n\n1. 安装 webpack-bundle-analyzer `cnpm i -D webpack-bundle-analyzer`\n2. 在`package.json`文件中的 scripts 字段中加入\n   `\"analyze\": \"npm_config_report=true npm run build\"`\n   <!-- 命令的意思是：设置`NODE_ENV`为`production` 、`npm_config_report`为`true`，然后运行`npm run build` -->\n3. 打开`vue.config.js`文件,加入如下代码\n\n   ```\n    自定义配置：\n    chainWebpack: config => {\n      if(process.env.npm_config_report){\n        const BundleAnalyzerPlugin = require(\"webpack-bundle-analyzer\").BundleAnalyzerPlugin;\n        config.plugin(\"webpack-bundle-analyzer\").use(\n          new BundleAnalyzerPlugin({\n              analyzerMode: \"server\",\n              analyzerHost: \"127.0.0.1\",\n              analyzerPort: 8887,\n              reportFilename: \"report.html\",\n              defaultSizes: \"parsed\",\n              openAnalyzer: true,\n              generateStatsFile: false,\n              statsFilename: \"stats.json\",\n              statsOptions: null,\n              logLevel: \"info\"\n          })\n        );\n      }\n    }\n    默认配置：\n    chainWebpack: config => {\n      if(process.env.npm_config_report){\n        const BundleAnalyzerPlugin  = require(\"webpack-bundle-analyzer\").BundleAnalyzerPlugin;\n        config.plugin(\"webpack-bundle-analyzer\").use(BundleAnalyzerPlugin);\n      }\n    }\n   ```\n\n4. 运行命令`npm run analyze`，浏览器会自动打开默认[http://127.0.0.1:8888](http://127.0.0.1:8887)\n\n![](/images/webpack-bundle-analyzer.gif)\n\n{% asset_img webpack-bundle-analyzer.gif This is an example image %}\n\n我们观察上图中哪些包太大，就可以优化哪些，比如上图的 loadsh.js\n\n##### vue2.0 中配置，\n\n1. 打开 build 目录下的 webpack.base.conf.js,加入如下代码\n\n```\n  externals: {\n    loadsh: \"_\",\n  }\n```\n\n2. 在根目录下的 idnex.html 引入 cdn 的相关文件\n\n```\n<script src=\"https://cdn.bootcss.com/lodash.js/4.17.15/lodash.js\"></script>\n```\n\n打包之后包的大小\n主要看 vendor 包的大小，缩小了内容，我们使用 cdn，使其存在于外部环境。\n由于 externals 属性，是将依赖排除，本该将 node_modules 中依赖包打入到 vendor bundle 中，变成外部扩展。\n\n## nginx 开启 gzip 压缩\n\ngzip 的压缩页面需要浏览器和服务器双方都支持，实际上就是服务器端压缩，传到浏览器后浏览器解压并解析。\n\n```\n# 开启gzip\ngzip on;\n# 启用gzip压缩的最小文件，小于设置值的文件将不会压缩\ngzip_min_length 1k;\n# gzip 压缩级别，1-10，数字越大压缩的越好，也越占用CPU时间，后面会有详细说明\ngzip_comp_level 2;\n# 进行压缩的文件类型。javascript有多种形式。其中的值可以在 mime.types 文件中找到。\ngzip_types text/plain application/javascript application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png font/ttf font/otf image/svg+xml;\n# 是否在http header中添加Vary: Accept-Encoding，建议开启\ngzip_vary on;\n# 禁用IE 6 gzip\ngzip_disable \"MSIE [1-6]\\.\";\n\n# 开启缓存\nlocation ~* ^.+\\.(ico|gif|jpg|jpeg|png)$ {\n    access_log   off;\n    expires      30d;\n}\n\nlocation ~* ^.+\\.(css|js|txt|xml|swf|wav)$ {\n    access_log   off;\n    expires      24h;\n}\nlocation ~* ^.+\\.(html|htm)$ {\n    expires      1h;\n}\n\nlocation ~* ^.+\\.(eot|ttf|otf|woff|svg)$ {\n    access_log   off;\n    expires max;\n}\n\n# 格式\n# expires 30s;\n# expires 30m;\n# expires 2h;\n# expires 30d;\n\n```\n\n然后在 vue 项目中也开始 zip 压缩，下面介绍 vue-cli2.0 和 vue-cli3.0,相关模块`compression-webpack-plugin`\n\n##### vue-cli2.0 Gzip\n\n2.0 版本应该默认有相关的配置，在 build 目录下的 webpack.prod.conf.js 中有如下代码\n\n```\nif (config.build.productionGzip) {\n const CompressionWebpackPlugin = require(\"compression-webpack-plugin\");\n\n webpackConfig.plugins.push(\n   new CompressionWebpackPlugin({\n     asset: \"[path].gz[query]\",\n     algorithm: \"gzip\",\n     test: new RegExp(\n       \"\\\\.(\" + config.build.productionGzipExtensions.join(\"|\") + \")$\"\n     ),\n     threshold: 10240,\n     minRatio: 0.8\n   })\n );\n}\n```\n\n上面的代码可以看出，如果 config.build.productionGzip 为 true 的话，则开始 gzip,所以我们只需配置 config.build.productionGzip 为 true.\n\n##### vue-cli3.0\n\n3.0 版本先手动安装`compression-webpack-plugin`模块，然后打开 vue.config.js 文件，配置如下代码：\n\n```\nconst CompressionPlugin = require(\"compression-webpack-plugin\")\nmodule.exports = {\nconfigureWebpack:config=>{\n        if(progress.env.NODE_ENV === 'production'){\n            return{\n                plugins: [\n\n                    new CompressionPlugin({\n                        test:/\\.js$|\\.html$|.\\css/, //匹配文件名\n                        threshold: 10240,//对超过10k的数据压缩\n                        deleteOriginalAssets: false //不删除源文件\n                    })\n                ]\n            }\n        }\n\n    },\n}\n```\n\n## Vue 异步组件\n\n组件正常引入：\n\n```\nimport CustomSql from '@/components/CustomSql'\n\nexport default {\n  components: {\n    CustomSql\n  }\n}\n```\n\n组件异步引入：\n\n```\nexport default {\n  components: {\n    CustomSql: () => import('./CustomSql')\n  }\n}\n```\n\n## 组件按需加载\n\n```\n`vue-router// prev const component1 = () => import('@/components/**')//now\n利用webpack require.ensure comst component2 = r => require.ensure([], () => r(require('@/components/+'**'+.vue'))`\n\n```\n\n## 首屏加载慢\n\n```\nvue-router// prev\nconst component1 = () => import('@/components/**')//now 利用webpack   require.ensure\ncomst component2 = r => require.ensure([], () => r(require('@/components/+'**'+.vue'))\n```\n\n> Vue 中路由懒加载就是使用异步组件和 Webpack 的代码分割功能实现的。\n\n// 打包后文件的 css、js 存放的静态文件，在 main 目录下\nassetsSubDirectory: 'static',\n// 静态文件的引用路径\nassetsPublicPath: './',\n","source":"_drafts/vue-打包优化.md","raw":"---\ntitle: vue 打包优化\ncategories:\ntags:\n  - vue\n  - 性能优化\n---\n\n关键词:\n`webpack开启gzip压缩`、`nginx开启gzip压缩`、`使用cdn`、`vue懒加载`\n\n## 项目打包\n\n#### webpack-bundle-analyzer\n\n**如何分析问题**\n\n首先我们先了解一下`webpack-bundle-analyzer`这个插件，[npm](https://www.npmjs.com/package/webpack-bundle-analyzer)、[github](https://github.com/webpack-contrib/webpack-bundle-analyzer),详细的知识点看 github 官网就好,**一遍看不懂就多看几遍!!!** **一遍看不懂就多看几遍!!!** **一遍看不懂就多看几遍!!!**\n\n这里分别讲解一下`vue-cli2.0`和`vue-cli3.0`中具体的用法\n\n##### **vue-cli2.0 中`webpack-bundle-analyzer`的用法**\n\n1. 安装 webpack-bundle-analyzer， `cnpm i -D webpack-bundle-analyzer`\n2. 在`package.json`文件中的 scripts 字段中加入\n   `\"analyze\": \"NODE_ENV=production npm_config_report=true npm run build\"`\n\n   <!-- 命令的意思是：设置`NODE_ENV`为`production` 、`npm_config_report`为`true`，然后运行`npm run build` -->\n\n3. 打开`build`目录中的`webpack.prod.conf.js`，加入如下代码\n\n   ```\n   自定义配置：\n   if (process.env.npm_config_report) {\n     const BundleAnalyzerPlugin = require(\"webpack-bundle-analyzer\").BundleAnalyzerPlugin;\n     webpackConfig.plugins.push(\n       new BundleAnalyzerPlugin({\n         analyzerMode: \"server\",\n         analyzerHost: \"127.0.0.1\",\n         analyzerPort: 8887,\n         reportFilename: \"report.html\",\n         defaultSizes: \"parsed\",\n         openAnalyzer: true,\n         generateStatsFile: false,\n         statsFilename: \"stats.json\",\n         statsOptions: null,\n         logLevel: \"info\"\n       })\n     );\n   }\n\n   默认配置：\n   if (process.env.npm_config_report) {\n     const BundleAnalyzerPlugin = require(\"webpack-bundle-analyzer\").BundleAnalyzerPlugin;\n     webpackConfig.plugins.push(BundleAnalyzerPlugin);\n   }\n   ```\n\n4. 运行命令`npm run analyze`，浏览器会自动打开[http://127.0.0.1:8887](http://127.0.0.1:8887)(根据第三步配置的参数)\n\n##### **vue-cli3.0 中`webpack-bundle-analyzer`的用法**\n\n1. 安装 webpack-bundle-analyzer `cnpm i -D webpack-bundle-analyzer`\n2. 在`package.json`文件中的 scripts 字段中加入\n   `\"analyze\": \"npm_config_report=true npm run build\"`\n   <!-- 命令的意思是：设置`NODE_ENV`为`production` 、`npm_config_report`为`true`，然后运行`npm run build` -->\n3. 打开`vue.config.js`文件,加入如下代码\n\n   ```\n    自定义配置：\n    chainWebpack: config => {\n      if(process.env.npm_config_report){\n        const BundleAnalyzerPlugin = require(\"webpack-bundle-analyzer\").BundleAnalyzerPlugin;\n        config.plugin(\"webpack-bundle-analyzer\").use(\n          new BundleAnalyzerPlugin({\n              analyzerMode: \"server\",\n              analyzerHost: \"127.0.0.1\",\n              analyzerPort: 8887,\n              reportFilename: \"report.html\",\n              defaultSizes: \"parsed\",\n              openAnalyzer: true,\n              generateStatsFile: false,\n              statsFilename: \"stats.json\",\n              statsOptions: null,\n              logLevel: \"info\"\n          })\n        );\n      }\n    }\n    默认配置：\n    chainWebpack: config => {\n      if(process.env.npm_config_report){\n        const BundleAnalyzerPlugin  = require(\"webpack-bundle-analyzer\").BundleAnalyzerPlugin;\n        config.plugin(\"webpack-bundle-analyzer\").use(BundleAnalyzerPlugin);\n      }\n    }\n   ```\n\n4. 运行命令`npm run analyze`，浏览器会自动打开默认[http://127.0.0.1:8888](http://127.0.0.1:8887)\n\n![](/images/webpack-bundle-analyzer.gif)\n\n{% asset_img webpack-bundle-analyzer.gif This is an example image %}\n\n我们观察上图中哪些包太大，就可以优化哪些，比如上图的 loadsh.js\n\n##### vue2.0 中配置，\n\n1. 打开 build 目录下的 webpack.base.conf.js,加入如下代码\n\n```\n  externals: {\n    loadsh: \"_\",\n  }\n```\n\n2. 在根目录下的 idnex.html 引入 cdn 的相关文件\n\n```\n<script src=\"https://cdn.bootcss.com/lodash.js/4.17.15/lodash.js\"></script>\n```\n\n打包之后包的大小\n主要看 vendor 包的大小，缩小了内容，我们使用 cdn，使其存在于外部环境。\n由于 externals 属性，是将依赖排除，本该将 node_modules 中依赖包打入到 vendor bundle 中，变成外部扩展。\n\n## nginx 开启 gzip 压缩\n\ngzip 的压缩页面需要浏览器和服务器双方都支持，实际上就是服务器端压缩，传到浏览器后浏览器解压并解析。\n\n```\n# 开启gzip\ngzip on;\n# 启用gzip压缩的最小文件，小于设置值的文件将不会压缩\ngzip_min_length 1k;\n# gzip 压缩级别，1-10，数字越大压缩的越好，也越占用CPU时间，后面会有详细说明\ngzip_comp_level 2;\n# 进行压缩的文件类型。javascript有多种形式。其中的值可以在 mime.types 文件中找到。\ngzip_types text/plain application/javascript application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png font/ttf font/otf image/svg+xml;\n# 是否在http header中添加Vary: Accept-Encoding，建议开启\ngzip_vary on;\n# 禁用IE 6 gzip\ngzip_disable \"MSIE [1-6]\\.\";\n\n# 开启缓存\nlocation ~* ^.+\\.(ico|gif|jpg|jpeg|png)$ {\n    access_log   off;\n    expires      30d;\n}\n\nlocation ~* ^.+\\.(css|js|txt|xml|swf|wav)$ {\n    access_log   off;\n    expires      24h;\n}\nlocation ~* ^.+\\.(html|htm)$ {\n    expires      1h;\n}\n\nlocation ~* ^.+\\.(eot|ttf|otf|woff|svg)$ {\n    access_log   off;\n    expires max;\n}\n\n# 格式\n# expires 30s;\n# expires 30m;\n# expires 2h;\n# expires 30d;\n\n```\n\n然后在 vue 项目中也开始 zip 压缩，下面介绍 vue-cli2.0 和 vue-cli3.0,相关模块`compression-webpack-plugin`\n\n##### vue-cli2.0 Gzip\n\n2.0 版本应该默认有相关的配置，在 build 目录下的 webpack.prod.conf.js 中有如下代码\n\n```\nif (config.build.productionGzip) {\n const CompressionWebpackPlugin = require(\"compression-webpack-plugin\");\n\n webpackConfig.plugins.push(\n   new CompressionWebpackPlugin({\n     asset: \"[path].gz[query]\",\n     algorithm: \"gzip\",\n     test: new RegExp(\n       \"\\\\.(\" + config.build.productionGzipExtensions.join(\"|\") + \")$\"\n     ),\n     threshold: 10240,\n     minRatio: 0.8\n   })\n );\n}\n```\n\n上面的代码可以看出，如果 config.build.productionGzip 为 true 的话，则开始 gzip,所以我们只需配置 config.build.productionGzip 为 true.\n\n##### vue-cli3.0\n\n3.0 版本先手动安装`compression-webpack-plugin`模块，然后打开 vue.config.js 文件，配置如下代码：\n\n```\nconst CompressionPlugin = require(\"compression-webpack-plugin\")\nmodule.exports = {\nconfigureWebpack:config=>{\n        if(progress.env.NODE_ENV === 'production'){\n            return{\n                plugins: [\n\n                    new CompressionPlugin({\n                        test:/\\.js$|\\.html$|.\\css/, //匹配文件名\n                        threshold: 10240,//对超过10k的数据压缩\n                        deleteOriginalAssets: false //不删除源文件\n                    })\n                ]\n            }\n        }\n\n    },\n}\n```\n\n## Vue 异步组件\n\n组件正常引入：\n\n```\nimport CustomSql from '@/components/CustomSql'\n\nexport default {\n  components: {\n    CustomSql\n  }\n}\n```\n\n组件异步引入：\n\n```\nexport default {\n  components: {\n    CustomSql: () => import('./CustomSql')\n  }\n}\n```\n\n## 组件按需加载\n\n```\n`vue-router// prev const component1 = () => import('@/components/**')//now\n利用webpack require.ensure comst component2 = r => require.ensure([], () => r(require('@/components/+'**'+.vue'))`\n\n```\n\n## 首屏加载慢\n\n```\nvue-router// prev\nconst component1 = () => import('@/components/**')//now 利用webpack   require.ensure\ncomst component2 = r => require.ensure([], () => r(require('@/components/+'**'+.vue'))\n```\n\n> Vue 中路由懒加载就是使用异步组件和 Webpack 的代码分割功能实现的。\n\n// 打包后文件的 css、js 存放的静态文件，在 main 目录下\nassetsSubDirectory: 'static',\n// 静态文件的引用路径\nassetsPublicPath: './',\n","slug":"vue-打包优化","published":0,"date":"2019-09-11T08:41:28.119Z","updated":"2019-10-16T07:11:00.301Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckb1z4dfn00109n94te4bxos2","content":"<p>关键词:<br><code>webpack开启gzip压缩</code>、<code>nginx开启gzip压缩</code>、<code>使用cdn</code>、<code>vue懒加载</code></p>\n<h2 id=\"项目打包\"><a href=\"#项目打包\" class=\"headerlink\" title=\"项目打包\"></a>项目打包</h2><h4 id=\"webpack-bundle-analyzer\"><a href=\"#webpack-bundle-analyzer\" class=\"headerlink\" title=\"webpack-bundle-analyzer\"></a>webpack-bundle-analyzer</h4><p><strong>如何分析问题</strong></p>\n<p>首先我们先了解一下<code>webpack-bundle-analyzer</code>这个插件，<a href=\"https://www.npmjs.com/package/webpack-bundle-analyzer\" target=\"_blank\" rel=\"noopener\">npm</a>、<a href=\"https://github.com/webpack-contrib/webpack-bundle-analyzer\" target=\"_blank\" rel=\"noopener\">github</a>,详细的知识点看 github 官网就好,<strong>一遍看不懂就多看几遍!!!</strong> <strong>一遍看不懂就多看几遍!!!</strong> <strong>一遍看不懂就多看几遍!!!</strong></p>\n<p>这里分别讲解一下<code>vue-cli2.0</code>和<code>vue-cli3.0</code>中具体的用法</p>\n<h5 id=\"vue-cli2-0-中webpack-bundle-analyzer的用法\"><a href=\"#vue-cli2-0-中webpack-bundle-analyzer的用法\" class=\"headerlink\" title=\"vue-cli2.0 中webpack-bundle-analyzer的用法\"></a><strong>vue-cli2.0 中<code>webpack-bundle-analyzer</code>的用法</strong></h5><ol>\n<li><p>安装 webpack-bundle-analyzer， <code>cnpm i -D webpack-bundle-analyzer</code></p>\n</li>\n<li><p>在<code>package.json</code>文件中的 scripts 字段中加入<br><code>&quot;analyze&quot;: &quot;NODE_ENV=production npm_config_report=true npm run build&quot;</code></p>\n<!-- 命令的意思是：设置`NODE_ENV`为`production` 、`npm_config_report`为`true`，然后运行`npm run build` -->\n</li>\n<li><p>打开<code>build</code>目录中的<code>webpack.prod.conf.js</code>，加入如下代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">自定义配置：</span><br><span class=\"line\">if (process.env.npm_config_report) &#123;</span><br><span class=\"line\">  const BundleAnalyzerPlugin = require(&quot;webpack-bundle-analyzer&quot;).BundleAnalyzerPlugin;</span><br><span class=\"line\">  webpackConfig.plugins.push(</span><br><span class=\"line\">    new BundleAnalyzerPlugin(&#123;</span><br><span class=\"line\">      analyzerMode: &quot;server&quot;,</span><br><span class=\"line\">      analyzerHost: &quot;127.0.0.1&quot;,</span><br><span class=\"line\">      analyzerPort: 8887,</span><br><span class=\"line\">      reportFilename: &quot;report.html&quot;,</span><br><span class=\"line\">      defaultSizes: &quot;parsed&quot;,</span><br><span class=\"line\">      openAnalyzer: true,</span><br><span class=\"line\">      generateStatsFile: false,</span><br><span class=\"line\">      statsFilename: &quot;stats.json&quot;,</span><br><span class=\"line\">      statsOptions: null,</span><br><span class=\"line\">      logLevel: &quot;info&quot;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">默认配置：</span><br><span class=\"line\">if (process.env.npm_config_report) &#123;</span><br><span class=\"line\">  const BundleAnalyzerPlugin = require(&quot;webpack-bundle-analyzer&quot;).BundleAnalyzerPlugin;</span><br><span class=\"line\">  webpackConfig.plugins.push(BundleAnalyzerPlugin);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>运行命令<code>npm run analyze</code>，浏览器会自动打开<a href=\"http://127.0.0.1:8887\" target=\"_blank\" rel=\"noopener\">http://127.0.0.1:8887</a>(根据第三步配置的参数)</p>\n</li>\n</ol>\n<h5 id=\"vue-cli3-0-中webpack-bundle-analyzer的用法\"><a href=\"#vue-cli3-0-中webpack-bundle-analyzer的用法\" class=\"headerlink\" title=\"vue-cli3.0 中webpack-bundle-analyzer的用法\"></a><strong>vue-cli3.0 中<code>webpack-bundle-analyzer</code>的用法</strong></h5><ol>\n<li><p>安装 webpack-bundle-analyzer <code>cnpm i -D webpack-bundle-analyzer</code></p>\n</li>\n<li><p>在<code>package.json</code>文件中的 scripts 字段中加入<br><code>&quot;analyze&quot;: &quot;npm_config_report=true npm run build&quot;</code></p>\n<!-- 命令的意思是：设置`NODE_ENV`为`production` 、`npm_config_report`为`true`，然后运行`npm run build` --></li>\n<li><p>打开<code>vue.config.js</code>文件,加入如下代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">自定义配置：</span><br><span class=\"line\">chainWebpack: config =&gt; &#123;</span><br><span class=\"line\">  if(process.env.npm_config_report)&#123;</span><br><span class=\"line\">    const BundleAnalyzerPlugin = require(&quot;webpack-bundle-analyzer&quot;).BundleAnalyzerPlugin;</span><br><span class=\"line\">    config.plugin(&quot;webpack-bundle-analyzer&quot;).use(</span><br><span class=\"line\">      new BundleAnalyzerPlugin(&#123;</span><br><span class=\"line\">          analyzerMode: &quot;server&quot;,</span><br><span class=\"line\">          analyzerHost: &quot;127.0.0.1&quot;,</span><br><span class=\"line\">          analyzerPort: 8887,</span><br><span class=\"line\">          reportFilename: &quot;report.html&quot;,</span><br><span class=\"line\">          defaultSizes: &quot;parsed&quot;,</span><br><span class=\"line\">          openAnalyzer: true,</span><br><span class=\"line\">          generateStatsFile: false,</span><br><span class=\"line\">          statsFilename: &quot;stats.json&quot;,</span><br><span class=\"line\">          statsOptions: null,</span><br><span class=\"line\">          logLevel: &quot;info&quot;</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">默认配置：</span><br><span class=\"line\">chainWebpack: config =&gt; &#123;</span><br><span class=\"line\">  if(process.env.npm_config_report)&#123;</span><br><span class=\"line\">    const BundleAnalyzerPlugin  = require(&quot;webpack-bundle-analyzer&quot;).BundleAnalyzerPlugin;</span><br><span class=\"line\">    config.plugin(&quot;webpack-bundle-analyzer&quot;).use(BundleAnalyzerPlugin);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>运行命令<code>npm run analyze</code>，浏览器会自动打开默认<a href=\"http://127.0.0.1:8887\" target=\"_blank\" rel=\"noopener\">http://127.0.0.1:8888</a></p>\n</li>\n</ol>\n<p><img src=\"/images/webpack-bundle-analyzer.gif\" alt></p>\n\n\n<p>我们观察上图中哪些包太大，就可以优化哪些，比如上图的 loadsh.js</p>\n<h5 id=\"vue2-0-中配置，\"><a href=\"#vue2-0-中配置，\" class=\"headerlink\" title=\"vue2.0 中配置，\"></a>vue2.0 中配置，</h5><ol>\n<li>打开 build 目录下的 webpack.base.conf.js,加入如下代码</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">externals: &#123;</span><br><span class=\"line\">  loadsh: &quot;_&quot;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>在根目录下的 idnex.html 引入 cdn 的相关文件</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script src=&quot;https://cdn.bootcss.com/lodash.js/4.17.15/lodash.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<p>打包之后包的大小<br>主要看 vendor 包的大小，缩小了内容，我们使用 cdn，使其存在于外部环境。<br>由于 externals 属性，是将依赖排除，本该将 node_modules 中依赖包打入到 vendor bundle 中，变成外部扩展。</p>\n<h2 id=\"nginx-开启-gzip-压缩\"><a href=\"#nginx-开启-gzip-压缩\" class=\"headerlink\" title=\"nginx 开启 gzip 压缩\"></a>nginx 开启 gzip 压缩</h2><p>gzip 的压缩页面需要浏览器和服务器双方都支持，实际上就是服务器端压缩，传到浏览器后浏览器解压并解析。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 开启gzip</span><br><span class=\"line\">gzip on;</span><br><span class=\"line\"># 启用gzip压缩的最小文件，小于设置值的文件将不会压缩</span><br><span class=\"line\">gzip_min_length 1k;</span><br><span class=\"line\"># gzip 压缩级别，1-10，数字越大压缩的越好，也越占用CPU时间，后面会有详细说明</span><br><span class=\"line\">gzip_comp_level 2;</span><br><span class=\"line\"># 进行压缩的文件类型。javascript有多种形式。其中的值可以在 mime.types 文件中找到。</span><br><span class=\"line\">gzip_types text/plain application/javascript application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png font/ttf font/otf image/svg+xml;</span><br><span class=\"line\"># 是否在http header中添加Vary: Accept-Encoding，建议开启</span><br><span class=\"line\">gzip_vary on;</span><br><span class=\"line\"># 禁用IE 6 gzip</span><br><span class=\"line\">gzip_disable &quot;MSIE [1-6]\\.&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\"># 开启缓存</span><br><span class=\"line\">location ~* ^.+\\.(ico|gif|jpg|jpeg|png)$ &#123;</span><br><span class=\"line\">    access_log   off;</span><br><span class=\"line\">    expires      30d;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">location ~* ^.+\\.(css|js|txt|xml|swf|wav)$ &#123;</span><br><span class=\"line\">    access_log   off;</span><br><span class=\"line\">    expires      24h;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">location ~* ^.+\\.(html|htm)$ &#123;</span><br><span class=\"line\">    expires      1h;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">location ~* ^.+\\.(eot|ttf|otf|woff|svg)$ &#123;</span><br><span class=\"line\">    access_log   off;</span><br><span class=\"line\">    expires max;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"># 格式</span><br><span class=\"line\"># expires 30s;</span><br><span class=\"line\"># expires 30m;</span><br><span class=\"line\"># expires 2h;</span><br><span class=\"line\"># expires 30d;</span><br></pre></td></tr></table></figure>\n\n<p>然后在 vue 项目中也开始 zip 压缩，下面介绍 vue-cli2.0 和 vue-cli3.0,相关模块<code>compression-webpack-plugin</code></p>\n<h5 id=\"vue-cli2-0-Gzip\"><a href=\"#vue-cli2-0-Gzip\" class=\"headerlink\" title=\"vue-cli2.0 Gzip\"></a>vue-cli2.0 Gzip</h5><p>2.0 版本应该默认有相关的配置，在 build 目录下的 webpack.prod.conf.js 中有如下代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (config.build.productionGzip) &#123;</span><br><span class=\"line\"> const CompressionWebpackPlugin = require(&quot;compression-webpack-plugin&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\"> webpackConfig.plugins.push(</span><br><span class=\"line\">   new CompressionWebpackPlugin(&#123;</span><br><span class=\"line\">     asset: &quot;[path].gz[query]&quot;,</span><br><span class=\"line\">     algorithm: &quot;gzip&quot;,</span><br><span class=\"line\">     test: new RegExp(</span><br><span class=\"line\">       &quot;\\\\.(&quot; + config.build.productionGzipExtensions.join(&quot;|&quot;) + &quot;)$&quot;</span><br><span class=\"line\">     ),</span><br><span class=\"line\">     threshold: 10240,</span><br><span class=\"line\">     minRatio: 0.8</span><br><span class=\"line\">   &#125;)</span><br><span class=\"line\"> );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的代码可以看出，如果 config.build.productionGzip 为 true 的话，则开始 gzip,所以我们只需配置 config.build.productionGzip 为 true.</p>\n<h5 id=\"vue-cli3-0\"><a href=\"#vue-cli3-0\" class=\"headerlink\" title=\"vue-cli3.0\"></a>vue-cli3.0</h5><p>3.0 版本先手动安装<code>compression-webpack-plugin</code>模块，然后打开 vue.config.js 文件，配置如下代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const CompressionPlugin = require(&quot;compression-webpack-plugin&quot;)</span><br><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">configureWebpack:config=&gt;&#123;</span><br><span class=\"line\">        if(progress.env.NODE_ENV === &apos;production&apos;)&#123;</span><br><span class=\"line\">            return&#123;</span><br><span class=\"line\">                plugins: [</span><br><span class=\"line\"></span><br><span class=\"line\">                    new CompressionPlugin(&#123;</span><br><span class=\"line\">                        test:/\\.js$|\\.html$|.\\css/, //匹配文件名</span><br><span class=\"line\">                        threshold: 10240,//对超过10k的数据压缩</span><br><span class=\"line\">                        deleteOriginalAssets: false //不删除源文件</span><br><span class=\"line\">                    &#125;)</span><br><span class=\"line\">                ]</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Vue-异步组件\"><a href=\"#Vue-异步组件\" class=\"headerlink\" title=\"Vue 异步组件\"></a>Vue 异步组件</h2><p>组件正常引入：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import CustomSql from &apos;@/components/CustomSql&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  components: &#123;</span><br><span class=\"line\">    CustomSql</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>组件异步引入：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export default &#123;</span><br><span class=\"line\">  components: &#123;</span><br><span class=\"line\">    CustomSql: () =&gt; import(&apos;./CustomSql&apos;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"组件按需加载\"><a href=\"#组件按需加载\" class=\"headerlink\" title=\"组件按需加载\"></a>组件按需加载</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">`vue-router// prev const component1 = () =&gt; import(&apos;@/components/**&apos;)//now</span><br><span class=\"line\">利用webpack require.ensure comst component2 = r =&gt; require.ensure([], () =&gt; r(require(&apos;@/components/+&apos;**&apos;+.vue&apos;))`</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"首屏加载慢\"><a href=\"#首屏加载慢\" class=\"headerlink\" title=\"首屏加载慢\"></a>首屏加载慢</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vue-router// prev</span><br><span class=\"line\">const component1 = () =&gt; import(&apos;@/components/**&apos;)//now 利用webpack   require.ensure</span><br><span class=\"line\">comst component2 = r =&gt; require.ensure([], () =&gt; r(require(&apos;@/components/+&apos;**&apos;+.vue&apos;))</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>Vue 中路由懒加载就是使用异步组件和 Webpack 的代码分割功能实现的。</p>\n</blockquote>\n<p>// 打包后文件的 css、js 存放的静态文件，在 main 目录下<br>assetsSubDirectory: ‘static’,<br>// 静态文件的引用路径<br>assetsPublicPath: ‘./‘,</p>\n","site":{"data":{}},"excerpt":"","more":"<p>关键词:<br><code>webpack开启gzip压缩</code>、<code>nginx开启gzip压缩</code>、<code>使用cdn</code>、<code>vue懒加载</code></p>\n<h2 id=\"项目打包\"><a href=\"#项目打包\" class=\"headerlink\" title=\"项目打包\"></a>项目打包</h2><h4 id=\"webpack-bundle-analyzer\"><a href=\"#webpack-bundle-analyzer\" class=\"headerlink\" title=\"webpack-bundle-analyzer\"></a>webpack-bundle-analyzer</h4><p><strong>如何分析问题</strong></p>\n<p>首先我们先了解一下<code>webpack-bundle-analyzer</code>这个插件，<a href=\"https://www.npmjs.com/package/webpack-bundle-analyzer\" target=\"_blank\" rel=\"noopener\">npm</a>、<a href=\"https://github.com/webpack-contrib/webpack-bundle-analyzer\" target=\"_blank\" rel=\"noopener\">github</a>,详细的知识点看 github 官网就好,<strong>一遍看不懂就多看几遍!!!</strong> <strong>一遍看不懂就多看几遍!!!</strong> <strong>一遍看不懂就多看几遍!!!</strong></p>\n<p>这里分别讲解一下<code>vue-cli2.0</code>和<code>vue-cli3.0</code>中具体的用法</p>\n<h5 id=\"vue-cli2-0-中webpack-bundle-analyzer的用法\"><a href=\"#vue-cli2-0-中webpack-bundle-analyzer的用法\" class=\"headerlink\" title=\"vue-cli2.0 中webpack-bundle-analyzer的用法\"></a><strong>vue-cli2.0 中<code>webpack-bundle-analyzer</code>的用法</strong></h5><ol>\n<li><p>安装 webpack-bundle-analyzer， <code>cnpm i -D webpack-bundle-analyzer</code></p>\n</li>\n<li><p>在<code>package.json</code>文件中的 scripts 字段中加入<br><code>&quot;analyze&quot;: &quot;NODE_ENV=production npm_config_report=true npm run build&quot;</code></p>\n<!-- 命令的意思是：设置`NODE_ENV`为`production` 、`npm_config_report`为`true`，然后运行`npm run build` -->\n</li>\n<li><p>打开<code>build</code>目录中的<code>webpack.prod.conf.js</code>，加入如下代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">自定义配置：</span><br><span class=\"line\">if (process.env.npm_config_report) &#123;</span><br><span class=\"line\">  const BundleAnalyzerPlugin = require(&quot;webpack-bundle-analyzer&quot;).BundleAnalyzerPlugin;</span><br><span class=\"line\">  webpackConfig.plugins.push(</span><br><span class=\"line\">    new BundleAnalyzerPlugin(&#123;</span><br><span class=\"line\">      analyzerMode: &quot;server&quot;,</span><br><span class=\"line\">      analyzerHost: &quot;127.0.0.1&quot;,</span><br><span class=\"line\">      analyzerPort: 8887,</span><br><span class=\"line\">      reportFilename: &quot;report.html&quot;,</span><br><span class=\"line\">      defaultSizes: &quot;parsed&quot;,</span><br><span class=\"line\">      openAnalyzer: true,</span><br><span class=\"line\">      generateStatsFile: false,</span><br><span class=\"line\">      statsFilename: &quot;stats.json&quot;,</span><br><span class=\"line\">      statsOptions: null,</span><br><span class=\"line\">      logLevel: &quot;info&quot;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">默认配置：</span><br><span class=\"line\">if (process.env.npm_config_report) &#123;</span><br><span class=\"line\">  const BundleAnalyzerPlugin = require(&quot;webpack-bundle-analyzer&quot;).BundleAnalyzerPlugin;</span><br><span class=\"line\">  webpackConfig.plugins.push(BundleAnalyzerPlugin);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>运行命令<code>npm run analyze</code>，浏览器会自动打开<a href=\"http://127.0.0.1:8887\" target=\"_blank\" rel=\"noopener\">http://127.0.0.1:8887</a>(根据第三步配置的参数)</p>\n</li>\n</ol>\n<h5 id=\"vue-cli3-0-中webpack-bundle-analyzer的用法\"><a href=\"#vue-cli3-0-中webpack-bundle-analyzer的用法\" class=\"headerlink\" title=\"vue-cli3.0 中webpack-bundle-analyzer的用法\"></a><strong>vue-cli3.0 中<code>webpack-bundle-analyzer</code>的用法</strong></h5><ol>\n<li><p>安装 webpack-bundle-analyzer <code>cnpm i -D webpack-bundle-analyzer</code></p>\n</li>\n<li><p>在<code>package.json</code>文件中的 scripts 字段中加入<br><code>&quot;analyze&quot;: &quot;npm_config_report=true npm run build&quot;</code></p>\n<!-- 命令的意思是：设置`NODE_ENV`为`production` 、`npm_config_report`为`true`，然后运行`npm run build` --></li>\n<li><p>打开<code>vue.config.js</code>文件,加入如下代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">自定义配置：</span><br><span class=\"line\">chainWebpack: config =&gt; &#123;</span><br><span class=\"line\">  if(process.env.npm_config_report)&#123;</span><br><span class=\"line\">    const BundleAnalyzerPlugin = require(&quot;webpack-bundle-analyzer&quot;).BundleAnalyzerPlugin;</span><br><span class=\"line\">    config.plugin(&quot;webpack-bundle-analyzer&quot;).use(</span><br><span class=\"line\">      new BundleAnalyzerPlugin(&#123;</span><br><span class=\"line\">          analyzerMode: &quot;server&quot;,</span><br><span class=\"line\">          analyzerHost: &quot;127.0.0.1&quot;,</span><br><span class=\"line\">          analyzerPort: 8887,</span><br><span class=\"line\">          reportFilename: &quot;report.html&quot;,</span><br><span class=\"line\">          defaultSizes: &quot;parsed&quot;,</span><br><span class=\"line\">          openAnalyzer: true,</span><br><span class=\"line\">          generateStatsFile: false,</span><br><span class=\"line\">          statsFilename: &quot;stats.json&quot;,</span><br><span class=\"line\">          statsOptions: null,</span><br><span class=\"line\">          logLevel: &quot;info&quot;</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">默认配置：</span><br><span class=\"line\">chainWebpack: config =&gt; &#123;</span><br><span class=\"line\">  if(process.env.npm_config_report)&#123;</span><br><span class=\"line\">    const BundleAnalyzerPlugin  = require(&quot;webpack-bundle-analyzer&quot;).BundleAnalyzerPlugin;</span><br><span class=\"line\">    config.plugin(&quot;webpack-bundle-analyzer&quot;).use(BundleAnalyzerPlugin);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>运行命令<code>npm run analyze</code>，浏览器会自动打开默认<a href=\"http://127.0.0.1:8887\" target=\"_blank\" rel=\"noopener\">http://127.0.0.1:8888</a></p>\n</li>\n</ol>\n<p><img src=\"/images/webpack-bundle-analyzer.gif\" alt></p>\n\n\n<p>我们观察上图中哪些包太大，就可以优化哪些，比如上图的 loadsh.js</p>\n<h5 id=\"vue2-0-中配置，\"><a href=\"#vue2-0-中配置，\" class=\"headerlink\" title=\"vue2.0 中配置，\"></a>vue2.0 中配置，</h5><ol>\n<li>打开 build 目录下的 webpack.base.conf.js,加入如下代码</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">externals: &#123;</span><br><span class=\"line\">  loadsh: &quot;_&quot;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>在根目录下的 idnex.html 引入 cdn 的相关文件</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script src=&quot;https://cdn.bootcss.com/lodash.js/4.17.15/lodash.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<p>打包之后包的大小<br>主要看 vendor 包的大小，缩小了内容，我们使用 cdn，使其存在于外部环境。<br>由于 externals 属性，是将依赖排除，本该将 node_modules 中依赖包打入到 vendor bundle 中，变成外部扩展。</p>\n<h2 id=\"nginx-开启-gzip-压缩\"><a href=\"#nginx-开启-gzip-压缩\" class=\"headerlink\" title=\"nginx 开启 gzip 压缩\"></a>nginx 开启 gzip 压缩</h2><p>gzip 的压缩页面需要浏览器和服务器双方都支持，实际上就是服务器端压缩，传到浏览器后浏览器解压并解析。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 开启gzip</span><br><span class=\"line\">gzip on;</span><br><span class=\"line\"># 启用gzip压缩的最小文件，小于设置值的文件将不会压缩</span><br><span class=\"line\">gzip_min_length 1k;</span><br><span class=\"line\"># gzip 压缩级别，1-10，数字越大压缩的越好，也越占用CPU时间，后面会有详细说明</span><br><span class=\"line\">gzip_comp_level 2;</span><br><span class=\"line\"># 进行压缩的文件类型。javascript有多种形式。其中的值可以在 mime.types 文件中找到。</span><br><span class=\"line\">gzip_types text/plain application/javascript application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png font/ttf font/otf image/svg+xml;</span><br><span class=\"line\"># 是否在http header中添加Vary: Accept-Encoding，建议开启</span><br><span class=\"line\">gzip_vary on;</span><br><span class=\"line\"># 禁用IE 6 gzip</span><br><span class=\"line\">gzip_disable &quot;MSIE [1-6]\\.&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\"># 开启缓存</span><br><span class=\"line\">location ~* ^.+\\.(ico|gif|jpg|jpeg|png)$ &#123;</span><br><span class=\"line\">    access_log   off;</span><br><span class=\"line\">    expires      30d;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">location ~* ^.+\\.(css|js|txt|xml|swf|wav)$ &#123;</span><br><span class=\"line\">    access_log   off;</span><br><span class=\"line\">    expires      24h;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">location ~* ^.+\\.(html|htm)$ &#123;</span><br><span class=\"line\">    expires      1h;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">location ~* ^.+\\.(eot|ttf|otf|woff|svg)$ &#123;</span><br><span class=\"line\">    access_log   off;</span><br><span class=\"line\">    expires max;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"># 格式</span><br><span class=\"line\"># expires 30s;</span><br><span class=\"line\"># expires 30m;</span><br><span class=\"line\"># expires 2h;</span><br><span class=\"line\"># expires 30d;</span><br></pre></td></tr></table></figure>\n\n<p>然后在 vue 项目中也开始 zip 压缩，下面介绍 vue-cli2.0 和 vue-cli3.0,相关模块<code>compression-webpack-plugin</code></p>\n<h5 id=\"vue-cli2-0-Gzip\"><a href=\"#vue-cli2-0-Gzip\" class=\"headerlink\" title=\"vue-cli2.0 Gzip\"></a>vue-cli2.0 Gzip</h5><p>2.0 版本应该默认有相关的配置，在 build 目录下的 webpack.prod.conf.js 中有如下代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (config.build.productionGzip) &#123;</span><br><span class=\"line\"> const CompressionWebpackPlugin = require(&quot;compression-webpack-plugin&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\"> webpackConfig.plugins.push(</span><br><span class=\"line\">   new CompressionWebpackPlugin(&#123;</span><br><span class=\"line\">     asset: &quot;[path].gz[query]&quot;,</span><br><span class=\"line\">     algorithm: &quot;gzip&quot;,</span><br><span class=\"line\">     test: new RegExp(</span><br><span class=\"line\">       &quot;\\\\.(&quot; + config.build.productionGzipExtensions.join(&quot;|&quot;) + &quot;)$&quot;</span><br><span class=\"line\">     ),</span><br><span class=\"line\">     threshold: 10240,</span><br><span class=\"line\">     minRatio: 0.8</span><br><span class=\"line\">   &#125;)</span><br><span class=\"line\"> );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的代码可以看出，如果 config.build.productionGzip 为 true 的话，则开始 gzip,所以我们只需配置 config.build.productionGzip 为 true.</p>\n<h5 id=\"vue-cli3-0\"><a href=\"#vue-cli3-0\" class=\"headerlink\" title=\"vue-cli3.0\"></a>vue-cli3.0</h5><p>3.0 版本先手动安装<code>compression-webpack-plugin</code>模块，然后打开 vue.config.js 文件，配置如下代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const CompressionPlugin = require(&quot;compression-webpack-plugin&quot;)</span><br><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">configureWebpack:config=&gt;&#123;</span><br><span class=\"line\">        if(progress.env.NODE_ENV === &apos;production&apos;)&#123;</span><br><span class=\"line\">            return&#123;</span><br><span class=\"line\">                plugins: [</span><br><span class=\"line\"></span><br><span class=\"line\">                    new CompressionPlugin(&#123;</span><br><span class=\"line\">                        test:/\\.js$|\\.html$|.\\css/, //匹配文件名</span><br><span class=\"line\">                        threshold: 10240,//对超过10k的数据压缩</span><br><span class=\"line\">                        deleteOriginalAssets: false //不删除源文件</span><br><span class=\"line\">                    &#125;)</span><br><span class=\"line\">                ]</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Vue-异步组件\"><a href=\"#Vue-异步组件\" class=\"headerlink\" title=\"Vue 异步组件\"></a>Vue 异步组件</h2><p>组件正常引入：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import CustomSql from &apos;@/components/CustomSql&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  components: &#123;</span><br><span class=\"line\">    CustomSql</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>组件异步引入：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export default &#123;</span><br><span class=\"line\">  components: &#123;</span><br><span class=\"line\">    CustomSql: () =&gt; import(&apos;./CustomSql&apos;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"组件按需加载\"><a href=\"#组件按需加载\" class=\"headerlink\" title=\"组件按需加载\"></a>组件按需加载</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">`vue-router// prev const component1 = () =&gt; import(&apos;@/components/**&apos;)//now</span><br><span class=\"line\">利用webpack require.ensure comst component2 = r =&gt; require.ensure([], () =&gt; r(require(&apos;@/components/+&apos;**&apos;+.vue&apos;))`</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"首屏加载慢\"><a href=\"#首屏加载慢\" class=\"headerlink\" title=\"首屏加载慢\"></a>首屏加载慢</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vue-router// prev</span><br><span class=\"line\">const component1 = () =&gt; import(&apos;@/components/**&apos;)//now 利用webpack   require.ensure</span><br><span class=\"line\">comst component2 = r =&gt; require.ensure([], () =&gt; r(require(&apos;@/components/+&apos;**&apos;+.vue&apos;))</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>Vue 中路由懒加载就是使用异步组件和 Webpack 的代码分割功能实现的。</p>\n</blockquote>\n<p>// 打包后文件的 css、js 存放的静态文件，在 main 目录下<br>assetsSubDirectory: ‘static’,<br>// 静态文件的引用路径<br>assetsPublicPath: ‘./‘,</p>\n"},{"title":"Event Loop","_content":"\n## 事件轮询\n\n事件轮询的工作是监听调用堆栈，并确定调用堆栈是否为空。如果调用堆栈是空的，它将检查消息队列，看看是否有任何挂起的回调等待执行。\n\n**请记住 setTimeout 不是 JS 引擎的一部分，它是 Web Api 的一部分。 setTimeout、setInterval、Fetch、DOM Events**\n\n**事件轮询、web api 和消息队列不是 JavaScript 引擎的一部分，而是浏览器的 JavaScript 运行时环境或 Nodejs JavaScript 运行时环境的一部分(对于 Nodejs)。在 Nodejs 中，web api 被 c/c++ api 所替代。**\n\n1. JS 引擎线程会维护一个执行栈，同步代码会依次加入到执行栈中依次执行并出栈。\n2. JS 引擎线程遇到异步函数，会将异步函数交给相应的 Webapi，而继续执行后面的任务。\n3. Webapi 会在条件满足的时候，将`异步对应的回调`加入到消息队列中，等待执行。\n4. 执行栈为空时，JS 引擎线程会去取消息队列中的回调函数（如果有的话），并加入到执行栈中执行。\n5. 完成后出栈，执行栈再次为空，重复上面的操作，这就是事件循环(event loop)机制。\n\n![](/images/eventLoop.webp)\n\n## 任务队列 === 消息队列\n\n也称为消息队列，是一个先进先出的队列，它里面存放着各种消息，即**异步操作的回调函数**，**异步操作会将相关回调添加到任务队列中**，而不同的异步操作添加到任务队列的时机也不同，如 onclick，setTimeout，ajax 处理的方式都不同，这些异步操作都是由浏览器内核的不同模块来执行的：\n\nonclick 由浏览器内核的 DOM Binding 模块来处理，当事件触发的时候，回调函数会立即添加到任务队列中；\nsetTimeout 会由浏览器内核的 timer 模块来进行延时处理，当时间到达的时候，才会将回调函数添加到任务队列中；\najax 会由浏览器内核的 network 模块来处理，在网络请求完成返回之后，才将回调添加到任务队列中;\n\n## 异步执行的运行机制\n\n1. 所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。\n2. 主线程之外，还存在一个\"任务队列\"（task queue）。只要异步任务有了运行结果，就在\"任务队列\"之中放置一个事件。\n3. 一旦\"执行栈\"中的所有同步任务执行完毕，系统就会读取\"任务队列\"，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。\n4. 主线程不断重复上面的第三步。\n\n## 宏任务与微任务\n\n2 macro-task(宏任务)、micro-task(微任务)\n\n除了广义的同步任务和异步任务，其实对异步任务还有更细致的划分\n\n```\nmacro-task(宏任务)：setTimeout，setInterval\nmicro-task(微任务)：Promise，process.nextTick\n```\n\nmacro-task(宏任务)和 microtask（微任务）属于对异步任务的分类，不同的 API 注册的异步任务会依次进入自身对应的队列中，然后等待 Event Loop 将它们依次压入执行栈中执行。\n\njs 事件循环机制，决定了代码执行顺序。\n第一步：js 解释器识别所有 js 代码，将同步的代码放到主线程执行；异步的代码放到 Event Table 执行。这也是第一次宏任务执行完毕！\n第二步：接下来执行所有的微任务\n\nJs 中，有两类任务队列：宏任务队列（macro tasks）和微任务队列（micro tasks）。宏任务队列可以有多个，微任务队列只有一个。那么什么任务，会分到哪个队列呢？\n\n宏任务：script（全局任务）, setTimeout, setInterval, setImmediate, I/O, UI rendering.\n微任务：process.nextTick, Promise, Object.observer, MutationObserver.\n\n优先级：主代码块 > setImmediate > MessageChannel > setTimeout / setInterval\n\n比如：setImmediate 指定的回调函数，总是排在 setTimeout 前面\n\n优先级：process.nextTick > Promise > MutationObserver\n\n异步任务之间并不是完全等同的，它们存在一个执行优先级。按照执行优先级，可区分为两类任务：微任务和宏任务，即：\n\n微任务：promise、Object.observe、MutationObserver\n宏任务：script、setTimeout、setInterval、I/O、UI rendering\n在一次事件循环中，异步事件返回的结果会被放入到一个任务队列中，但是根据异步事件的类型，需要把事件放入到对应的微任务队列或宏任务队列中。\n当主线程空闲时（执行栈为空），主线程会先查看微任务队列，执行清空后再查看宏任务队列，并执行清空，如此反复循环\n总结而言，浏览器中事件循环就一句话：当前执行栈执行完成时，立即优先处理微任务，再去处理宏任务，同一次事件循环中，微任务先于宏任务执行，\n\n[https://github.com/gauseen/blog/issues/6](https://github.com/gauseen/blog/issues/6)\n\n[https://www.cnblogs.com/jiangyuzhen/p/11064408.html](https://www.cnblogs.com/jiangyuzhen/p/11064408.html)\n[https://www.ruphi.cn/archives/350/](https://www.ruphi.cn/archives/350/)\n\n## 异步一般是指：\n\n网络请求\n计时器\nDOM 事件监听\n\n## setTimeout\n\n**setTimeout(fn,0)的含义是，指定某个任务在主线程最早可得的空闲时间执行，也就是说，尽可能早得执行。它在\"任务队列\"的尾部添加一个事件，因此要等到同步任务和\"任务队列\"现有的事件都处理完，才会得到执行。**\n\nHTML5 标准规定了 setTimeout()的第二个参数的最小值（最短间隔），不得低于 4 毫秒，如果低于这个值，就会自动增加。在此之前，老版本的浏览器都将最短间隔设为 10 毫秒。另外，对于那些 DOM 的变动（尤其是涉及页面重新渲染的部分），通常不会立即执行，而是每 16 毫秒执行一次。这时使用 requestAnimationFrame()的效果要好于 setTimeout()。\n\n需要注意的是，setTimeout()只是将事件插入了\"任务队列\"，必须等到当前代码（执行栈）执行完，主线程才会去执行它指定的回调函数。要是当前代码耗时很长，有可能要等很久，所以并没有办法保证，回调函数一定会在 setTimeout()指定的时间执行。\n\n## await 做了什么\n\n从字面意思上看 await 就是等待，await 等待的是一个表达式，这个表达式的返回值可以是一个 promise 对象也可以是其他值。\n\n很多人以为 await 会一直等待之后的表达式执行完之后才会继续执行后面的代码，实际上 await 是一个让出线程的标志。await 后面的表达式会先执行一遍，将 await 后面的代码加入到 microtask 中，然后就会跳出整个 async 函数来执行后面的代码。\n\n```\nasync function async1() {\n\tconsole.log('async1 start');\n\tawait async2();\n\tconsole.log('async1 end');\n}\n```\n\n```\nasync function async1() {\n\tconsole.log('async1 start');\n\tPromise.resolve(async2()).then(() => {\n                console.log('async1 end');\n        })\n}\n```\n\n## 相关阅读\n\n[事件轮训](https://segmentfault.com/a/1190000020400736)\n[http://www.ruanyifeng.com/blog/2014/10/event-loop.html](http://www.ruanyifeng.com/blog/2014/10/event-loop.html)\n[event loop](https://www.jianshu.com/p/de7aba994523)\n[https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/7](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/7)\n","source":"_drafts/Event-Loop.md","raw":"---\ntitle: Event Loop\ncategories:\ntags:\n  - javascript\n---\n\n## 事件轮询\n\n事件轮询的工作是监听调用堆栈，并确定调用堆栈是否为空。如果调用堆栈是空的，它将检查消息队列，看看是否有任何挂起的回调等待执行。\n\n**请记住 setTimeout 不是 JS 引擎的一部分，它是 Web Api 的一部分。 setTimeout、setInterval、Fetch、DOM Events**\n\n**事件轮询、web api 和消息队列不是 JavaScript 引擎的一部分，而是浏览器的 JavaScript 运行时环境或 Nodejs JavaScript 运行时环境的一部分(对于 Nodejs)。在 Nodejs 中，web api 被 c/c++ api 所替代。**\n\n1. JS 引擎线程会维护一个执行栈，同步代码会依次加入到执行栈中依次执行并出栈。\n2. JS 引擎线程遇到异步函数，会将异步函数交给相应的 Webapi，而继续执行后面的任务。\n3. Webapi 会在条件满足的时候，将`异步对应的回调`加入到消息队列中，等待执行。\n4. 执行栈为空时，JS 引擎线程会去取消息队列中的回调函数（如果有的话），并加入到执行栈中执行。\n5. 完成后出栈，执行栈再次为空，重复上面的操作，这就是事件循环(event loop)机制。\n\n![](/images/eventLoop.webp)\n\n## 任务队列 === 消息队列\n\n也称为消息队列，是一个先进先出的队列，它里面存放着各种消息，即**异步操作的回调函数**，**异步操作会将相关回调添加到任务队列中**，而不同的异步操作添加到任务队列的时机也不同，如 onclick，setTimeout，ajax 处理的方式都不同，这些异步操作都是由浏览器内核的不同模块来执行的：\n\nonclick 由浏览器内核的 DOM Binding 模块来处理，当事件触发的时候，回调函数会立即添加到任务队列中；\nsetTimeout 会由浏览器内核的 timer 模块来进行延时处理，当时间到达的时候，才会将回调函数添加到任务队列中；\najax 会由浏览器内核的 network 模块来处理，在网络请求完成返回之后，才将回调添加到任务队列中;\n\n## 异步执行的运行机制\n\n1. 所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。\n2. 主线程之外，还存在一个\"任务队列\"（task queue）。只要异步任务有了运行结果，就在\"任务队列\"之中放置一个事件。\n3. 一旦\"执行栈\"中的所有同步任务执行完毕，系统就会读取\"任务队列\"，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。\n4. 主线程不断重复上面的第三步。\n\n## 宏任务与微任务\n\n2 macro-task(宏任务)、micro-task(微任务)\n\n除了广义的同步任务和异步任务，其实对异步任务还有更细致的划分\n\n```\nmacro-task(宏任务)：setTimeout，setInterval\nmicro-task(微任务)：Promise，process.nextTick\n```\n\nmacro-task(宏任务)和 microtask（微任务）属于对异步任务的分类，不同的 API 注册的异步任务会依次进入自身对应的队列中，然后等待 Event Loop 将它们依次压入执行栈中执行。\n\njs 事件循环机制，决定了代码执行顺序。\n第一步：js 解释器识别所有 js 代码，将同步的代码放到主线程执行；异步的代码放到 Event Table 执行。这也是第一次宏任务执行完毕！\n第二步：接下来执行所有的微任务\n\nJs 中，有两类任务队列：宏任务队列（macro tasks）和微任务队列（micro tasks）。宏任务队列可以有多个，微任务队列只有一个。那么什么任务，会分到哪个队列呢？\n\n宏任务：script（全局任务）, setTimeout, setInterval, setImmediate, I/O, UI rendering.\n微任务：process.nextTick, Promise, Object.observer, MutationObserver.\n\n优先级：主代码块 > setImmediate > MessageChannel > setTimeout / setInterval\n\n比如：setImmediate 指定的回调函数，总是排在 setTimeout 前面\n\n优先级：process.nextTick > Promise > MutationObserver\n\n异步任务之间并不是完全等同的，它们存在一个执行优先级。按照执行优先级，可区分为两类任务：微任务和宏任务，即：\n\n微任务：promise、Object.observe、MutationObserver\n宏任务：script、setTimeout、setInterval、I/O、UI rendering\n在一次事件循环中，异步事件返回的结果会被放入到一个任务队列中，但是根据异步事件的类型，需要把事件放入到对应的微任务队列或宏任务队列中。\n当主线程空闲时（执行栈为空），主线程会先查看微任务队列，执行清空后再查看宏任务队列，并执行清空，如此反复循环\n总结而言，浏览器中事件循环就一句话：当前执行栈执行完成时，立即优先处理微任务，再去处理宏任务，同一次事件循环中，微任务先于宏任务执行，\n\n[https://github.com/gauseen/blog/issues/6](https://github.com/gauseen/blog/issues/6)\n\n[https://www.cnblogs.com/jiangyuzhen/p/11064408.html](https://www.cnblogs.com/jiangyuzhen/p/11064408.html)\n[https://www.ruphi.cn/archives/350/](https://www.ruphi.cn/archives/350/)\n\n## 异步一般是指：\n\n网络请求\n计时器\nDOM 事件监听\n\n## setTimeout\n\n**setTimeout(fn,0)的含义是，指定某个任务在主线程最早可得的空闲时间执行，也就是说，尽可能早得执行。它在\"任务队列\"的尾部添加一个事件，因此要等到同步任务和\"任务队列\"现有的事件都处理完，才会得到执行。**\n\nHTML5 标准规定了 setTimeout()的第二个参数的最小值（最短间隔），不得低于 4 毫秒，如果低于这个值，就会自动增加。在此之前，老版本的浏览器都将最短间隔设为 10 毫秒。另外，对于那些 DOM 的变动（尤其是涉及页面重新渲染的部分），通常不会立即执行，而是每 16 毫秒执行一次。这时使用 requestAnimationFrame()的效果要好于 setTimeout()。\n\n需要注意的是，setTimeout()只是将事件插入了\"任务队列\"，必须等到当前代码（执行栈）执行完，主线程才会去执行它指定的回调函数。要是当前代码耗时很长，有可能要等很久，所以并没有办法保证，回调函数一定会在 setTimeout()指定的时间执行。\n\n## await 做了什么\n\n从字面意思上看 await 就是等待，await 等待的是一个表达式，这个表达式的返回值可以是一个 promise 对象也可以是其他值。\n\n很多人以为 await 会一直等待之后的表达式执行完之后才会继续执行后面的代码，实际上 await 是一个让出线程的标志。await 后面的表达式会先执行一遍，将 await 后面的代码加入到 microtask 中，然后就会跳出整个 async 函数来执行后面的代码。\n\n```\nasync function async1() {\n\tconsole.log('async1 start');\n\tawait async2();\n\tconsole.log('async1 end');\n}\n```\n\n```\nasync function async1() {\n\tconsole.log('async1 start');\n\tPromise.resolve(async2()).then(() => {\n                console.log('async1 end');\n        })\n}\n```\n\n## 相关阅读\n\n[事件轮训](https://segmentfault.com/a/1190000020400736)\n[http://www.ruanyifeng.com/blog/2014/10/event-loop.html](http://www.ruanyifeng.com/blog/2014/10/event-loop.html)\n[event loop](https://www.jianshu.com/p/de7aba994523)\n[https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/7](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/7)\n","slug":"Event-Loop","published":0,"date":"2020-06-04T15:15:25.277Z","updated":"2020-06-05T01:41:52.548Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckb1z4dfn00119n945tvjpcqj","content":"<h2 id=\"事件轮询\"><a href=\"#事件轮询\" class=\"headerlink\" title=\"事件轮询\"></a>事件轮询</h2><p>事件轮询的工作是监听调用堆栈，并确定调用堆栈是否为空。如果调用堆栈是空的，它将检查消息队列，看看是否有任何挂起的回调等待执行。</p>\n<p><strong>请记住 setTimeout 不是 JS 引擎的一部分，它是 Web Api 的一部分。 setTimeout、setInterval、Fetch、DOM Events</strong></p>\n<p><strong>事件轮询、web api 和消息队列不是 JavaScript 引擎的一部分，而是浏览器的 JavaScript 运行时环境或 Nodejs JavaScript 运行时环境的一部分(对于 Nodejs)。在 Nodejs 中，web api 被 c/c++ api 所替代。</strong></p>\n<ol>\n<li>JS 引擎线程会维护一个执行栈，同步代码会依次加入到执行栈中依次执行并出栈。</li>\n<li>JS 引擎线程遇到异步函数，会将异步函数交给相应的 Webapi，而继续执行后面的任务。</li>\n<li>Webapi 会在条件满足的时候，将<code>异步对应的回调</code>加入到消息队列中，等待执行。</li>\n<li>执行栈为空时，JS 引擎线程会去取消息队列中的回调函数（如果有的话），并加入到执行栈中执行。</li>\n<li>完成后出栈，执行栈再次为空，重复上面的操作，这就是事件循环(event loop)机制。</li>\n</ol>\n<p><img src=\"/images/eventLoop.webp\" alt></p>\n<h2 id=\"任务队列-消息队列\"><a href=\"#任务队列-消息队列\" class=\"headerlink\" title=\"任务队列 === 消息队列\"></a>任务队列 === 消息队列</h2><p>也称为消息队列，是一个先进先出的队列，它里面存放着各种消息，即<strong>异步操作的回调函数</strong>，<strong>异步操作会将相关回调添加到任务队列中</strong>，而不同的异步操作添加到任务队列的时机也不同，如 onclick，setTimeout，ajax 处理的方式都不同，这些异步操作都是由浏览器内核的不同模块来执行的：</p>\n<p>onclick 由浏览器内核的 DOM Binding 模块来处理，当事件触发的时候，回调函数会立即添加到任务队列中；<br>setTimeout 会由浏览器内核的 timer 模块来进行延时处理，当时间到达的时候，才会将回调函数添加到任务队列中；<br>ajax 会由浏览器内核的 network 模块来处理，在网络请求完成返回之后，才将回调添加到任务队列中;</p>\n<h2 id=\"异步执行的运行机制\"><a href=\"#异步执行的运行机制\" class=\"headerlink\" title=\"异步执行的运行机制\"></a>异步执行的运行机制</h2><ol>\n<li>所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。</li>\n<li>主线程之外，还存在一个”任务队列”（task queue）。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件。</li>\n<li>一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。</li>\n<li>主线程不断重复上面的第三步。</li>\n</ol>\n<h2 id=\"宏任务与微任务\"><a href=\"#宏任务与微任务\" class=\"headerlink\" title=\"宏任务与微任务\"></a>宏任务与微任务</h2><p>2 macro-task(宏任务)、micro-task(微任务)</p>\n<p>除了广义的同步任务和异步任务，其实对异步任务还有更细致的划分</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">macro-task(宏任务)：setTimeout，setInterval</span><br><span class=\"line\">micro-task(微任务)：Promise，process.nextTick</span><br></pre></td></tr></table></figure>\n\n<p>macro-task(宏任务)和 microtask（微任务）属于对异步任务的分类，不同的 API 注册的异步任务会依次进入自身对应的队列中，然后等待 Event Loop 将它们依次压入执行栈中执行。</p>\n<p>js 事件循环机制，决定了代码执行顺序。<br>第一步：js 解释器识别所有 js 代码，将同步的代码放到主线程执行；异步的代码放到 Event Table 执行。这也是第一次宏任务执行完毕！<br>第二步：接下来执行所有的微任务</p>\n<p>Js 中，有两类任务队列：宏任务队列（macro tasks）和微任务队列（micro tasks）。宏任务队列可以有多个，微任务队列只有一个。那么什么任务，会分到哪个队列呢？</p>\n<p>宏任务：script（全局任务）, setTimeout, setInterval, setImmediate, I/O, UI rendering.<br>微任务：process.nextTick, Promise, Object.observer, MutationObserver.</p>\n<p>优先级：主代码块 &gt; setImmediate &gt; MessageChannel &gt; setTimeout / setInterval</p>\n<p>比如：setImmediate 指定的回调函数，总是排在 setTimeout 前面</p>\n<p>优先级：process.nextTick &gt; Promise &gt; MutationObserver</p>\n<p>异步任务之间并不是完全等同的，它们存在一个执行优先级。按照执行优先级，可区分为两类任务：微任务和宏任务，即：</p>\n<p>微任务：promise、Object.observe、MutationObserver<br>宏任务：script、setTimeout、setInterval、I/O、UI rendering<br>在一次事件循环中，异步事件返回的结果会被放入到一个任务队列中，但是根据异步事件的类型，需要把事件放入到对应的微任务队列或宏任务队列中。<br>当主线程空闲时（执行栈为空），主线程会先查看微任务队列，执行清空后再查看宏任务队列，并执行清空，如此反复循环<br>总结而言，浏览器中事件循环就一句话：当前执行栈执行完成时，立即优先处理微任务，再去处理宏任务，同一次事件循环中，微任务先于宏任务执行，</p>\n<p><a href=\"https://github.com/gauseen/blog/issues/6\" target=\"_blank\" rel=\"noopener\">https://github.com/gauseen/blog/issues/6</a></p>\n<p><a href=\"https://www.cnblogs.com/jiangyuzhen/p/11064408.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/jiangyuzhen/p/11064408.html</a><br><a href=\"https://www.ruphi.cn/archives/350/\" target=\"_blank\" rel=\"noopener\">https://www.ruphi.cn/archives/350/</a></p>\n<h2 id=\"异步一般是指：\"><a href=\"#异步一般是指：\" class=\"headerlink\" title=\"异步一般是指：\"></a>异步一般是指：</h2><p>网络请求<br>计时器<br>DOM 事件监听</p>\n<h2 id=\"setTimeout\"><a href=\"#setTimeout\" class=\"headerlink\" title=\"setTimeout\"></a>setTimeout</h2><p><strong>setTimeout(fn,0)的含义是，指定某个任务在主线程最早可得的空闲时间执行，也就是说，尽可能早得执行。它在”任务队列”的尾部添加一个事件，因此要等到同步任务和”任务队列”现有的事件都处理完，才会得到执行。</strong></p>\n<p>HTML5 标准规定了 setTimeout()的第二个参数的最小值（最短间隔），不得低于 4 毫秒，如果低于这个值，就会自动增加。在此之前，老版本的浏览器都将最短间隔设为 10 毫秒。另外，对于那些 DOM 的变动（尤其是涉及页面重新渲染的部分），通常不会立即执行，而是每 16 毫秒执行一次。这时使用 requestAnimationFrame()的效果要好于 setTimeout()。</p>\n<p>需要注意的是，setTimeout()只是将事件插入了”任务队列”，必须等到当前代码（执行栈）执行完，主线程才会去执行它指定的回调函数。要是当前代码耗时很长，有可能要等很久，所以并没有办法保证，回调函数一定会在 setTimeout()指定的时间执行。</p>\n<h2 id=\"await-做了什么\"><a href=\"#await-做了什么\" class=\"headerlink\" title=\"await 做了什么\"></a>await 做了什么</h2><p>从字面意思上看 await 就是等待，await 等待的是一个表达式，这个表达式的返回值可以是一个 promise 对象也可以是其他值。</p>\n<p>很多人以为 await 会一直等待之后的表达式执行完之后才会继续执行后面的代码，实际上 await 是一个让出线程的标志。await 后面的表达式会先执行一遍，将 await 后面的代码加入到 microtask 中，然后就会跳出整个 async 函数来执行后面的代码。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">async function async1() &#123;</span><br><span class=\"line\">\tconsole.log(&apos;async1 start&apos;);</span><br><span class=\"line\">\tawait async2();</span><br><span class=\"line\">\tconsole.log(&apos;async1 end&apos;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">async function async1() &#123;</span><br><span class=\"line\">\tconsole.log(&apos;async1 start&apos;);</span><br><span class=\"line\">\tPromise.resolve(async2()).then(() =&gt; &#123;</span><br><span class=\"line\">                console.log(&apos;async1 end&apos;);</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"相关阅读\"><a href=\"#相关阅读\" class=\"headerlink\" title=\"相关阅读\"></a>相关阅读</h2><p><a href=\"https://segmentfault.com/a/1190000020400736\" target=\"_blank\" rel=\"noopener\">事件轮训</a><br><a href=\"http://www.ruanyifeng.com/blog/2014/10/event-loop.html\" target=\"_blank\" rel=\"noopener\">http://www.ruanyifeng.com/blog/2014/10/event-loop.html</a><br><a href=\"https://www.jianshu.com/p/de7aba994523\" target=\"_blank\" rel=\"noopener\">event loop</a><br><a href=\"https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/7\" target=\"_blank\" rel=\"noopener\">https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/7</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"事件轮询\"><a href=\"#事件轮询\" class=\"headerlink\" title=\"事件轮询\"></a>事件轮询</h2><p>事件轮询的工作是监听调用堆栈，并确定调用堆栈是否为空。如果调用堆栈是空的，它将检查消息队列，看看是否有任何挂起的回调等待执行。</p>\n<p><strong>请记住 setTimeout 不是 JS 引擎的一部分，它是 Web Api 的一部分。 setTimeout、setInterval、Fetch、DOM Events</strong></p>\n<p><strong>事件轮询、web api 和消息队列不是 JavaScript 引擎的一部分，而是浏览器的 JavaScript 运行时环境或 Nodejs JavaScript 运行时环境的一部分(对于 Nodejs)。在 Nodejs 中，web api 被 c/c++ api 所替代。</strong></p>\n<ol>\n<li>JS 引擎线程会维护一个执行栈，同步代码会依次加入到执行栈中依次执行并出栈。</li>\n<li>JS 引擎线程遇到异步函数，会将异步函数交给相应的 Webapi，而继续执行后面的任务。</li>\n<li>Webapi 会在条件满足的时候，将<code>异步对应的回调</code>加入到消息队列中，等待执行。</li>\n<li>执行栈为空时，JS 引擎线程会去取消息队列中的回调函数（如果有的话），并加入到执行栈中执行。</li>\n<li>完成后出栈，执行栈再次为空，重复上面的操作，这就是事件循环(event loop)机制。</li>\n</ol>\n<p><img src=\"/images/eventLoop.webp\" alt></p>\n<h2 id=\"任务队列-消息队列\"><a href=\"#任务队列-消息队列\" class=\"headerlink\" title=\"任务队列 === 消息队列\"></a>任务队列 === 消息队列</h2><p>也称为消息队列，是一个先进先出的队列，它里面存放着各种消息，即<strong>异步操作的回调函数</strong>，<strong>异步操作会将相关回调添加到任务队列中</strong>，而不同的异步操作添加到任务队列的时机也不同，如 onclick，setTimeout，ajax 处理的方式都不同，这些异步操作都是由浏览器内核的不同模块来执行的：</p>\n<p>onclick 由浏览器内核的 DOM Binding 模块来处理，当事件触发的时候，回调函数会立即添加到任务队列中；<br>setTimeout 会由浏览器内核的 timer 模块来进行延时处理，当时间到达的时候，才会将回调函数添加到任务队列中；<br>ajax 会由浏览器内核的 network 模块来处理，在网络请求完成返回之后，才将回调添加到任务队列中;</p>\n<h2 id=\"异步执行的运行机制\"><a href=\"#异步执行的运行机制\" class=\"headerlink\" title=\"异步执行的运行机制\"></a>异步执行的运行机制</h2><ol>\n<li>所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。</li>\n<li>主线程之外，还存在一个”任务队列”（task queue）。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件。</li>\n<li>一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。</li>\n<li>主线程不断重复上面的第三步。</li>\n</ol>\n<h2 id=\"宏任务与微任务\"><a href=\"#宏任务与微任务\" class=\"headerlink\" title=\"宏任务与微任务\"></a>宏任务与微任务</h2><p>2 macro-task(宏任务)、micro-task(微任务)</p>\n<p>除了广义的同步任务和异步任务，其实对异步任务还有更细致的划分</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">macro-task(宏任务)：setTimeout，setInterval</span><br><span class=\"line\">micro-task(微任务)：Promise，process.nextTick</span><br></pre></td></tr></table></figure>\n\n<p>macro-task(宏任务)和 microtask（微任务）属于对异步任务的分类，不同的 API 注册的异步任务会依次进入自身对应的队列中，然后等待 Event Loop 将它们依次压入执行栈中执行。</p>\n<p>js 事件循环机制，决定了代码执行顺序。<br>第一步：js 解释器识别所有 js 代码，将同步的代码放到主线程执行；异步的代码放到 Event Table 执行。这也是第一次宏任务执行完毕！<br>第二步：接下来执行所有的微任务</p>\n<p>Js 中，有两类任务队列：宏任务队列（macro tasks）和微任务队列（micro tasks）。宏任务队列可以有多个，微任务队列只有一个。那么什么任务，会分到哪个队列呢？</p>\n<p>宏任务：script（全局任务）, setTimeout, setInterval, setImmediate, I/O, UI rendering.<br>微任务：process.nextTick, Promise, Object.observer, MutationObserver.</p>\n<p>优先级：主代码块 &gt; setImmediate &gt; MessageChannel &gt; setTimeout / setInterval</p>\n<p>比如：setImmediate 指定的回调函数，总是排在 setTimeout 前面</p>\n<p>优先级：process.nextTick &gt; Promise &gt; MutationObserver</p>\n<p>异步任务之间并不是完全等同的，它们存在一个执行优先级。按照执行优先级，可区分为两类任务：微任务和宏任务，即：</p>\n<p>微任务：promise、Object.observe、MutationObserver<br>宏任务：script、setTimeout、setInterval、I/O、UI rendering<br>在一次事件循环中，异步事件返回的结果会被放入到一个任务队列中，但是根据异步事件的类型，需要把事件放入到对应的微任务队列或宏任务队列中。<br>当主线程空闲时（执行栈为空），主线程会先查看微任务队列，执行清空后再查看宏任务队列，并执行清空，如此反复循环<br>总结而言，浏览器中事件循环就一句话：当前执行栈执行完成时，立即优先处理微任务，再去处理宏任务，同一次事件循环中，微任务先于宏任务执行，</p>\n<p><a href=\"https://github.com/gauseen/blog/issues/6\" target=\"_blank\" rel=\"noopener\">https://github.com/gauseen/blog/issues/6</a></p>\n<p><a href=\"https://www.cnblogs.com/jiangyuzhen/p/11064408.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/jiangyuzhen/p/11064408.html</a><br><a href=\"https://www.ruphi.cn/archives/350/\" target=\"_blank\" rel=\"noopener\">https://www.ruphi.cn/archives/350/</a></p>\n<h2 id=\"异步一般是指：\"><a href=\"#异步一般是指：\" class=\"headerlink\" title=\"异步一般是指：\"></a>异步一般是指：</h2><p>网络请求<br>计时器<br>DOM 事件监听</p>\n<h2 id=\"setTimeout\"><a href=\"#setTimeout\" class=\"headerlink\" title=\"setTimeout\"></a>setTimeout</h2><p><strong>setTimeout(fn,0)的含义是，指定某个任务在主线程最早可得的空闲时间执行，也就是说，尽可能早得执行。它在”任务队列”的尾部添加一个事件，因此要等到同步任务和”任务队列”现有的事件都处理完，才会得到执行。</strong></p>\n<p>HTML5 标准规定了 setTimeout()的第二个参数的最小值（最短间隔），不得低于 4 毫秒，如果低于这个值，就会自动增加。在此之前，老版本的浏览器都将最短间隔设为 10 毫秒。另外，对于那些 DOM 的变动（尤其是涉及页面重新渲染的部分），通常不会立即执行，而是每 16 毫秒执行一次。这时使用 requestAnimationFrame()的效果要好于 setTimeout()。</p>\n<p>需要注意的是，setTimeout()只是将事件插入了”任务队列”，必须等到当前代码（执行栈）执行完，主线程才会去执行它指定的回调函数。要是当前代码耗时很长，有可能要等很久，所以并没有办法保证，回调函数一定会在 setTimeout()指定的时间执行。</p>\n<h2 id=\"await-做了什么\"><a href=\"#await-做了什么\" class=\"headerlink\" title=\"await 做了什么\"></a>await 做了什么</h2><p>从字面意思上看 await 就是等待，await 等待的是一个表达式，这个表达式的返回值可以是一个 promise 对象也可以是其他值。</p>\n<p>很多人以为 await 会一直等待之后的表达式执行完之后才会继续执行后面的代码，实际上 await 是一个让出线程的标志。await 后面的表达式会先执行一遍，将 await 后面的代码加入到 microtask 中，然后就会跳出整个 async 函数来执行后面的代码。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">async function async1() &#123;</span><br><span class=\"line\">\tconsole.log(&apos;async1 start&apos;);</span><br><span class=\"line\">\tawait async2();</span><br><span class=\"line\">\tconsole.log(&apos;async1 end&apos;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">async function async1() &#123;</span><br><span class=\"line\">\tconsole.log(&apos;async1 start&apos;);</span><br><span class=\"line\">\tPromise.resolve(async2()).then(() =&gt; &#123;</span><br><span class=\"line\">                console.log(&apos;async1 end&apos;);</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"相关阅读\"><a href=\"#相关阅读\" class=\"headerlink\" title=\"相关阅读\"></a>相关阅读</h2><p><a href=\"https://segmentfault.com/a/1190000020400736\" target=\"_blank\" rel=\"noopener\">事件轮训</a><br><a href=\"http://www.ruanyifeng.com/blog/2014/10/event-loop.html\" target=\"_blank\" rel=\"noopener\">http://www.ruanyifeng.com/blog/2014/10/event-loop.html</a><br><a href=\"https://www.jianshu.com/p/de7aba994523\" target=\"_blank\" rel=\"noopener\">event loop</a><br><a href=\"https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/7\" target=\"_blank\" rel=\"noopener\">https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/7</a></p>\n"},{"title":"前端调试","_content":"\n关键词：\n`charles`、`thor`、`vconsole`、``\n","source":"_drafts/前端debug.md","raw":"---\ntitle: 前端调试\ncategories:\n  - 前端\ntags:\n  - debug\n---\n\n关键词：\n`charles`、`thor`、`vconsole`、``\n","slug":"前端debug","published":0,"date":"2019-08-26T15:44:20.045Z","updated":"2020-05-21T07:08:14.709Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckb1z4dfp00129n94gqv4ge4a","content":"<p>关键词：<br><code>charles</code>、<code>thor</code>、<code>vconsole</code>、``</p>\n","site":{"data":{}},"excerpt":"","more":"<p>关键词：<br><code>charles</code>、<code>thor</code>、<code>vconsole</code>、``</p>\n"},{"title":"内存相关知识","_content":"\n**JS 内存空间分为栈(stack)、堆(heap)、池(一般也会归类为栈中)。 其中栈存放变量，堆存放复杂对象，池存放常量。**\n\n内存中的堆栈和数据结构堆栈不是一个概念，可以说内存中的堆栈是真实存在的物理区，数据结构中的堆栈是抽象的数据存储结构。\n\n- 全部变量存储在静态区中，程序运行开始时为其分配内存，程序运行结束后该内存才被释放。局部变量存储在栈中，随程序调用被申请和释放。\n\n## 内存中的堆栈\n\n内存空间在逻辑上分为三部分：代码区、静态数据区和动态数据区，动态数据区又分为栈区和堆区。\n\n1. 代码区：存储方法体的二进制代码。高级调度（作业调度）、中级调度（内存调度）、低级调度（进程调度）控制代码区执行代码的切换。\n2. 静态数据区：存储全局变量、静态变量、常量，常量包括 final 修饰的常量和 String 常量。系统自动分配和回收。\n3. 栈区：存储运行方法的形参、局部变量、返回值。由系统自动分配和回收。\n\n例如 int method(int a){int b;}栈中存储参数 a、局部变量 b、返回值 temp。\n堆区：new 一个对象的引用或地址存储在栈区，指向该对象存储在堆区中的真实数据。由程序员分配和回收（Java 中由 JVM 虚拟机的垃圾回收机制自动回收）。\n例如 Class Student{int num; int age;} main 方法中 Student stu = new Student()；分配堆区空间中存储的该对象的 num、age，变量 stu 存储在栈中，里面的值是对应堆区空间的引用或地址。\n\n## 数据结构中的堆栈\n\n1. 栈：是一种连续存储的数据结构，特点是存储的数据先进后出。\n2. 堆：是一棵完全二叉树结构，特点是父节点的值大于（小于）两个子节点的值（分别称为大顶堆和小顶堆）。它常用于管理算法执行过程中的信息，应用场景包括堆排序，优先队列等。\n\n## JS 环境中分配的内存一般有如下生命周期：\n\n内存分配：当我们申明变量、函数、对象的时候，系统会自动为他 们分配内存\n内存使用：即读写内存，也就是使用变量、函数等\n内存回收：使用完毕，由垃圾回收机制自动回收不再使用的内存\n\n相关阅读：\n[https://www.zhihu.com/question/57658008](https://www.zhihu.com/question/57658008)\n[https://blog.csdn.net/u010425776/article/details/53617292](https://blog.csdn.net/u010425776/article/details/53617292)\n[http://blog.konghy.cn/2016/01/05/js-var/](http://blog.konghy.cn/2016/01/05/js-var/)\n[https://github.com/zhansingsong/js-leakage-patterns/blob/master/JavaScript%E5%86%85%E5%AD%98%E9%82%A3%E7%82%B9%E4%BA%8B/JavaScript%E5%86%85%E5%AD%98%E9%82%A3%E7%82%B9%E4%BA%8B.md](https://github.com/zhansingsong/js-leakage-patterns/blob/master/JavaScript%E5%86%85%E5%AD%98%E9%82%A3%E7%82%B9%E4%BA%8B/JavaScript%E5%86%85%E5%AD%98%E9%82%A3%E7%82%B9%E4%BA%8B.md)\n[https://zhuanlan.zhihu.com/p/50206683](https://zhuanlan.zhihu.com/p/50206683)\n","source":"_drafts/内存相关知识.md","raw":"---\ntitle: 内存相关知识\ncategories:\ntags:\n---\n\n**JS 内存空间分为栈(stack)、堆(heap)、池(一般也会归类为栈中)。 其中栈存放变量，堆存放复杂对象，池存放常量。**\n\n内存中的堆栈和数据结构堆栈不是一个概念，可以说内存中的堆栈是真实存在的物理区，数据结构中的堆栈是抽象的数据存储结构。\n\n- 全部变量存储在静态区中，程序运行开始时为其分配内存，程序运行结束后该内存才被释放。局部变量存储在栈中，随程序调用被申请和释放。\n\n## 内存中的堆栈\n\n内存空间在逻辑上分为三部分：代码区、静态数据区和动态数据区，动态数据区又分为栈区和堆区。\n\n1. 代码区：存储方法体的二进制代码。高级调度（作业调度）、中级调度（内存调度）、低级调度（进程调度）控制代码区执行代码的切换。\n2. 静态数据区：存储全局变量、静态变量、常量，常量包括 final 修饰的常量和 String 常量。系统自动分配和回收。\n3. 栈区：存储运行方法的形参、局部变量、返回值。由系统自动分配和回收。\n\n例如 int method(int a){int b;}栈中存储参数 a、局部变量 b、返回值 temp。\n堆区：new 一个对象的引用或地址存储在栈区，指向该对象存储在堆区中的真实数据。由程序员分配和回收（Java 中由 JVM 虚拟机的垃圾回收机制自动回收）。\n例如 Class Student{int num; int age;} main 方法中 Student stu = new Student()；分配堆区空间中存储的该对象的 num、age，变量 stu 存储在栈中，里面的值是对应堆区空间的引用或地址。\n\n## 数据结构中的堆栈\n\n1. 栈：是一种连续存储的数据结构，特点是存储的数据先进后出。\n2. 堆：是一棵完全二叉树结构，特点是父节点的值大于（小于）两个子节点的值（分别称为大顶堆和小顶堆）。它常用于管理算法执行过程中的信息，应用场景包括堆排序，优先队列等。\n\n## JS 环境中分配的内存一般有如下生命周期：\n\n内存分配：当我们申明变量、函数、对象的时候，系统会自动为他 们分配内存\n内存使用：即读写内存，也就是使用变量、函数等\n内存回收：使用完毕，由垃圾回收机制自动回收不再使用的内存\n\n相关阅读：\n[https://www.zhihu.com/question/57658008](https://www.zhihu.com/question/57658008)\n[https://blog.csdn.net/u010425776/article/details/53617292](https://blog.csdn.net/u010425776/article/details/53617292)\n[http://blog.konghy.cn/2016/01/05/js-var/](http://blog.konghy.cn/2016/01/05/js-var/)\n[https://github.com/zhansingsong/js-leakage-patterns/blob/master/JavaScript%E5%86%85%E5%AD%98%E9%82%A3%E7%82%B9%E4%BA%8B/JavaScript%E5%86%85%E5%AD%98%E9%82%A3%E7%82%B9%E4%BA%8B.md](https://github.com/zhansingsong/js-leakage-patterns/blob/master/JavaScript%E5%86%85%E5%AD%98%E9%82%A3%E7%82%B9%E4%BA%8B/JavaScript%E5%86%85%E5%AD%98%E9%82%A3%E7%82%B9%E4%BA%8B.md)\n[https://zhuanlan.zhihu.com/p/50206683](https://zhuanlan.zhihu.com/p/50206683)\n","slug":"内存相关知识","published":0,"date":"2019-08-27T01:56:52.958Z","updated":"2019-10-19T10:48:01.943Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckb1z4dfq00159n9468mt1ys4","content":"<p><strong>JS 内存空间分为栈(stack)、堆(heap)、池(一般也会归类为栈中)。 其中栈存放变量，堆存放复杂对象，池存放常量。</strong></p>\n<p>内存中的堆栈和数据结构堆栈不是一个概念，可以说内存中的堆栈是真实存在的物理区，数据结构中的堆栈是抽象的数据存储结构。</p>\n<ul>\n<li>全部变量存储在静态区中，程序运行开始时为其分配内存，程序运行结束后该内存才被释放。局部变量存储在栈中，随程序调用被申请和释放。</li>\n</ul>\n<h2 id=\"内存中的堆栈\"><a href=\"#内存中的堆栈\" class=\"headerlink\" title=\"内存中的堆栈\"></a>内存中的堆栈</h2><p>内存空间在逻辑上分为三部分：代码区、静态数据区和动态数据区，动态数据区又分为栈区和堆区。</p>\n<ol>\n<li>代码区：存储方法体的二进制代码。高级调度（作业调度）、中级调度（内存调度）、低级调度（进程调度）控制代码区执行代码的切换。</li>\n<li>静态数据区：存储全局变量、静态变量、常量，常量包括 final 修饰的常量和 String 常量。系统自动分配和回收。</li>\n<li>栈区：存储运行方法的形参、局部变量、返回值。由系统自动分配和回收。</li>\n</ol>\n<p>例如 int method(int a){int b;}栈中存储参数 a、局部变量 b、返回值 temp。<br>堆区：new 一个对象的引用或地址存储在栈区，指向该对象存储在堆区中的真实数据。由程序员分配和回收（Java 中由 JVM 虚拟机的垃圾回收机制自动回收）。<br>例如 Class Student{int num; int age;} main 方法中 Student stu = new Student()；分配堆区空间中存储的该对象的 num、age，变量 stu 存储在栈中，里面的值是对应堆区空间的引用或地址。</p>\n<h2 id=\"数据结构中的堆栈\"><a href=\"#数据结构中的堆栈\" class=\"headerlink\" title=\"数据结构中的堆栈\"></a>数据结构中的堆栈</h2><ol>\n<li>栈：是一种连续存储的数据结构，特点是存储的数据先进后出。</li>\n<li>堆：是一棵完全二叉树结构，特点是父节点的值大于（小于）两个子节点的值（分别称为大顶堆和小顶堆）。它常用于管理算法执行过程中的信息，应用场景包括堆排序，优先队列等。</li>\n</ol>\n<h2 id=\"JS-环境中分配的内存一般有如下生命周期：\"><a href=\"#JS-环境中分配的内存一般有如下生命周期：\" class=\"headerlink\" title=\"JS 环境中分配的内存一般有如下生命周期：\"></a>JS 环境中分配的内存一般有如下生命周期：</h2><p>内存分配：当我们申明变量、函数、对象的时候，系统会自动为他 们分配内存<br>内存使用：即读写内存，也就是使用变量、函数等<br>内存回收：使用完毕，由垃圾回收机制自动回收不再使用的内存</p>\n<p>相关阅读：<br><a href=\"https://www.zhihu.com/question/57658008\" target=\"_blank\" rel=\"noopener\">https://www.zhihu.com/question/57658008</a><br><a href=\"https://blog.csdn.net/u010425776/article/details/53617292\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/u010425776/article/details/53617292</a><br><a href=\"http://blog.konghy.cn/2016/01/05/js-var/\" target=\"_blank\" rel=\"noopener\">http://blog.konghy.cn/2016/01/05/js-var/</a><br><a href=\"https://github.com/zhansingsong/js-leakage-patterns/blob/master/JavaScript%E5%86%85%E5%AD%98%E9%82%A3%E7%82%B9%E4%BA%8B/JavaScript%E5%86%85%E5%AD%98%E9%82%A3%E7%82%B9%E4%BA%8B.md\" target=\"_blank\" rel=\"noopener\">https://github.com/zhansingsong/js-leakage-patterns/blob/master/JavaScript%E5%86%85%E5%AD%98%E9%82%A3%E7%82%B9%E4%BA%8B/JavaScript%E5%86%85%E5%AD%98%E9%82%A3%E7%82%B9%E4%BA%8B.md</a><br><a href=\"https://zhuanlan.zhihu.com/p/50206683\" target=\"_blank\" rel=\"noopener\">https://zhuanlan.zhihu.com/p/50206683</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p><strong>JS 内存空间分为栈(stack)、堆(heap)、池(一般也会归类为栈中)。 其中栈存放变量，堆存放复杂对象，池存放常量。</strong></p>\n<p>内存中的堆栈和数据结构堆栈不是一个概念，可以说内存中的堆栈是真实存在的物理区，数据结构中的堆栈是抽象的数据存储结构。</p>\n<ul>\n<li>全部变量存储在静态区中，程序运行开始时为其分配内存，程序运行结束后该内存才被释放。局部变量存储在栈中，随程序调用被申请和释放。</li>\n</ul>\n<h2 id=\"内存中的堆栈\"><a href=\"#内存中的堆栈\" class=\"headerlink\" title=\"内存中的堆栈\"></a>内存中的堆栈</h2><p>内存空间在逻辑上分为三部分：代码区、静态数据区和动态数据区，动态数据区又分为栈区和堆区。</p>\n<ol>\n<li>代码区：存储方法体的二进制代码。高级调度（作业调度）、中级调度（内存调度）、低级调度（进程调度）控制代码区执行代码的切换。</li>\n<li>静态数据区：存储全局变量、静态变量、常量，常量包括 final 修饰的常量和 String 常量。系统自动分配和回收。</li>\n<li>栈区：存储运行方法的形参、局部变量、返回值。由系统自动分配和回收。</li>\n</ol>\n<p>例如 int method(int a){int b;}栈中存储参数 a、局部变量 b、返回值 temp。<br>堆区：new 一个对象的引用或地址存储在栈区，指向该对象存储在堆区中的真实数据。由程序员分配和回收（Java 中由 JVM 虚拟机的垃圾回收机制自动回收）。<br>例如 Class Student{int num; int age;} main 方法中 Student stu = new Student()；分配堆区空间中存储的该对象的 num、age，变量 stu 存储在栈中，里面的值是对应堆区空间的引用或地址。</p>\n<h2 id=\"数据结构中的堆栈\"><a href=\"#数据结构中的堆栈\" class=\"headerlink\" title=\"数据结构中的堆栈\"></a>数据结构中的堆栈</h2><ol>\n<li>栈：是一种连续存储的数据结构，特点是存储的数据先进后出。</li>\n<li>堆：是一棵完全二叉树结构，特点是父节点的值大于（小于）两个子节点的值（分别称为大顶堆和小顶堆）。它常用于管理算法执行过程中的信息，应用场景包括堆排序，优先队列等。</li>\n</ol>\n<h2 id=\"JS-环境中分配的内存一般有如下生命周期：\"><a href=\"#JS-环境中分配的内存一般有如下生命周期：\" class=\"headerlink\" title=\"JS 环境中分配的内存一般有如下生命周期：\"></a>JS 环境中分配的内存一般有如下生命周期：</h2><p>内存分配：当我们申明变量、函数、对象的时候，系统会自动为他 们分配内存<br>内存使用：即读写内存，也就是使用变量、函数等<br>内存回收：使用完毕，由垃圾回收机制自动回收不再使用的内存</p>\n<p>相关阅读：<br><a href=\"https://www.zhihu.com/question/57658008\" target=\"_blank\" rel=\"noopener\">https://www.zhihu.com/question/57658008</a><br><a href=\"https://blog.csdn.net/u010425776/article/details/53617292\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/u010425776/article/details/53617292</a><br><a href=\"http://blog.konghy.cn/2016/01/05/js-var/\" target=\"_blank\" rel=\"noopener\">http://blog.konghy.cn/2016/01/05/js-var/</a><br><a href=\"https://github.com/zhansingsong/js-leakage-patterns/blob/master/JavaScript%E5%86%85%E5%AD%98%E9%82%A3%E7%82%B9%E4%BA%8B/JavaScript%E5%86%85%E5%AD%98%E9%82%A3%E7%82%B9%E4%BA%8B.md\" target=\"_blank\" rel=\"noopener\">https://github.com/zhansingsong/js-leakage-patterns/blob/master/JavaScript%E5%86%85%E5%AD%98%E9%82%A3%E7%82%B9%E4%BA%8B/JavaScript%E5%86%85%E5%AD%98%E9%82%A3%E7%82%B9%E4%BA%8B.md</a><br><a href=\"https://zhuanlan.zhihu.com/p/50206683\" target=\"_blank\" rel=\"noopener\">https://zhuanlan.zhihu.com/p/50206683</a></p>\n"},{"title":"函数","_content":"\n## 函数的类型\n\n在 ECMAScript 中有三种函数类型：`函数声明`，`函数表达式`和`函数构造器创建的函数`。每一种都有自己的特点。\n\n## 函数申明优先变量申明\n\n```\nvar a; // 声明一个变量，标识符为a\nfunction a() { // 声明一个函数，标示符也为a\n}\nalert(typeof a)\n\n// 互换位置\nfunction a() {\n}\nvar a;\nalert(typeof a);\n```\n\n```\nfunction a() {\n}\nvar a = 1; // 注意此处\nalert(typeof a);\n\n// 互换位置\nvar a = 1; // 注意此处\nfunction a() {\n}\nalert(typeof a);\n\n```\n\n相当于\n\n```\nfunction a() {\n}\nvar a;\na = 1; // 注意此处\nalert(typeof a);\n```\n\n## 函数的参数问题\n\n重点：参数的类型问题，是基本数据类型还是引用类型\n\n```\nvar a=[1,2,3];\nfunction foo(i){\n    i=[4,5,6];\n}\nfoo(a);\nconsole.log(a);\n```\n\n```\nvar a=[1,2,3];\nfunction foo(i){\n    i.push(4);\n}\nfoo(a);\nconsole.log(a);\n```\n\n```\nfunction changeObjProperty(o) {\n  o.siteUrl = \"http://www.baidu.com\"\n  o = new Object()\n  o.siteUrl = \"http://www.google.com\"\n}\nlet webSite = new Object();\nchangeObjProperty(webSite);\nconsole.log(webSite.siteUrl);\n\n```\n\n## 非匿名自执行函数，函数名只读\n\n```\nvar b = 10;\n(function b() {\n   // 内部作用域，会先去查找是有已有变量b的声明，有就直接赋值20，确实有了呀。发现了具名函数 function b(){}，拿此b做赋值；\n   // IIFE的函数无法进行赋值（内部机制，类似const定义的常量），所以无效。\n  // （这里说的“内部机制”，想搞清楚，需要去查阅一些资料，弄明白IIFE在JS引擎的工作方式，堆栈存储IIFE的方式等）\n    b = 20;\n    console.log(b); // [Function b]\n    console.log(window.b); // 10，不是20\n})();\n```\n\n函数表达式与函数声明不同，函数名只在该函数内部有效，并且此绑定是常量绑定。\n对于一个常量进行赋值，在 strict 模式下会报错，非 strict 模式下静默失败。\nIIFE 中的函数是函数表达式，而不是函数声明。\n\n```\nconst foo = function () {\n\tfoo = 10;\n\tconsole.log(foo)\n}\n(foo)() // Uncaught TypeError: Assignment to constant variable.\n```\n\n## IIFE (Immediately-Invoked Function Expression)\n\n**javascript 引擎规定，如果 function 关键字出现在行首，一律解释成函数声明语句；而函数声明后面是不能跟圆括号的（匿名函数是函数声明的一种）。然而，函数表达式的后面可以跟圆括号。所以可以将函数声明转换成函数表达式。**\n\n所以，解决方法就是不要让 function 出现在行首，让引擎将其理解成一个表达式\n\n最常用的两种办法：\n\n```\n(function(){\n    console.log(123);\n}());\n\n(function(){\n    console.log(123);\n })();\n\n(function waq() {\n    console.log(123);\n})()\n```\n\n总结 IFEE 的优点：\n\n1. 创建块级（私有）作用域，避免了向全局作用域中添加变量和函数，因此也避免了多人开发中全局变量和函数的命名冲突；\n2. IIFE 中定义的任何变量和函数，都会在执行结束时被销毁。这种做法可以减少闭包占用的内存问题，因为没有指向匿名函数的引用。只要函数执行完毕，就可以立即销毁其作用域链了；\n\n相关阅读：\n[https://www.zhihu.com/question/27114726](https://www.zhihu.com/question/27114726)\n[https://blog.csdn.net/love2016hy/article/details/77619491](https://blog.csdn.net/love2016hy/article/details/77619491)\n[https://stackoverflow.com/questions/518000/is-javascript-a-pass-by-reference-or-pass-by-value-language?lq=1](https://stackoverflow.com/questions/518000/is-javascript-a-pass-by-reference-or-pass-by-value-language?lq=1)\n[https://juejin.im/post/5c2f4c8a518825255d2957d1](https://juejin.im/post/5c2f4c8a518825255d2957d1)\n[https://www.zhihu.com/question/60063924](https://www.zhihu.com/question/60063924)\n[https://www.cnblogs.com/TomXu/archive/2012/01/30/2326372.html](https://www.cnblogs.com/TomXu/archive/2012/01/30/2326372.html)\n[函数内定义申明一个和形参名字一样的变量](https://www.cnblogs.com/liyan-web/p/5911295.html)\n[函数内的参数](https://blog.csdn.net/flqbestboy/article/details/77007807)\n","source":"_drafts/函数.md","raw":"---\ntitle: 函数\ncategories:\ntags:\n---\n\n## 函数的类型\n\n在 ECMAScript 中有三种函数类型：`函数声明`，`函数表达式`和`函数构造器创建的函数`。每一种都有自己的特点。\n\n## 函数申明优先变量申明\n\n```\nvar a; // 声明一个变量，标识符为a\nfunction a() { // 声明一个函数，标示符也为a\n}\nalert(typeof a)\n\n// 互换位置\nfunction a() {\n}\nvar a;\nalert(typeof a);\n```\n\n```\nfunction a() {\n}\nvar a = 1; // 注意此处\nalert(typeof a);\n\n// 互换位置\nvar a = 1; // 注意此处\nfunction a() {\n}\nalert(typeof a);\n\n```\n\n相当于\n\n```\nfunction a() {\n}\nvar a;\na = 1; // 注意此处\nalert(typeof a);\n```\n\n## 函数的参数问题\n\n重点：参数的类型问题，是基本数据类型还是引用类型\n\n```\nvar a=[1,2,3];\nfunction foo(i){\n    i=[4,5,6];\n}\nfoo(a);\nconsole.log(a);\n```\n\n```\nvar a=[1,2,3];\nfunction foo(i){\n    i.push(4);\n}\nfoo(a);\nconsole.log(a);\n```\n\n```\nfunction changeObjProperty(o) {\n  o.siteUrl = \"http://www.baidu.com\"\n  o = new Object()\n  o.siteUrl = \"http://www.google.com\"\n}\nlet webSite = new Object();\nchangeObjProperty(webSite);\nconsole.log(webSite.siteUrl);\n\n```\n\n## 非匿名自执行函数，函数名只读\n\n```\nvar b = 10;\n(function b() {\n   // 内部作用域，会先去查找是有已有变量b的声明，有就直接赋值20，确实有了呀。发现了具名函数 function b(){}，拿此b做赋值；\n   // IIFE的函数无法进行赋值（内部机制，类似const定义的常量），所以无效。\n  // （这里说的“内部机制”，想搞清楚，需要去查阅一些资料，弄明白IIFE在JS引擎的工作方式，堆栈存储IIFE的方式等）\n    b = 20;\n    console.log(b); // [Function b]\n    console.log(window.b); // 10，不是20\n})();\n```\n\n函数表达式与函数声明不同，函数名只在该函数内部有效，并且此绑定是常量绑定。\n对于一个常量进行赋值，在 strict 模式下会报错，非 strict 模式下静默失败。\nIIFE 中的函数是函数表达式，而不是函数声明。\n\n```\nconst foo = function () {\n\tfoo = 10;\n\tconsole.log(foo)\n}\n(foo)() // Uncaught TypeError: Assignment to constant variable.\n```\n\n## IIFE (Immediately-Invoked Function Expression)\n\n**javascript 引擎规定，如果 function 关键字出现在行首，一律解释成函数声明语句；而函数声明后面是不能跟圆括号的（匿名函数是函数声明的一种）。然而，函数表达式的后面可以跟圆括号。所以可以将函数声明转换成函数表达式。**\n\n所以，解决方法就是不要让 function 出现在行首，让引擎将其理解成一个表达式\n\n最常用的两种办法：\n\n```\n(function(){\n    console.log(123);\n}());\n\n(function(){\n    console.log(123);\n })();\n\n(function waq() {\n    console.log(123);\n})()\n```\n\n总结 IFEE 的优点：\n\n1. 创建块级（私有）作用域，避免了向全局作用域中添加变量和函数，因此也避免了多人开发中全局变量和函数的命名冲突；\n2. IIFE 中定义的任何变量和函数，都会在执行结束时被销毁。这种做法可以减少闭包占用的内存问题，因为没有指向匿名函数的引用。只要函数执行完毕，就可以立即销毁其作用域链了；\n\n相关阅读：\n[https://www.zhihu.com/question/27114726](https://www.zhihu.com/question/27114726)\n[https://blog.csdn.net/love2016hy/article/details/77619491](https://blog.csdn.net/love2016hy/article/details/77619491)\n[https://stackoverflow.com/questions/518000/is-javascript-a-pass-by-reference-or-pass-by-value-language?lq=1](https://stackoverflow.com/questions/518000/is-javascript-a-pass-by-reference-or-pass-by-value-language?lq=1)\n[https://juejin.im/post/5c2f4c8a518825255d2957d1](https://juejin.im/post/5c2f4c8a518825255d2957d1)\n[https://www.zhihu.com/question/60063924](https://www.zhihu.com/question/60063924)\n[https://www.cnblogs.com/TomXu/archive/2012/01/30/2326372.html](https://www.cnblogs.com/TomXu/archive/2012/01/30/2326372.html)\n[函数内定义申明一个和形参名字一样的变量](https://www.cnblogs.com/liyan-web/p/5911295.html)\n[函数内的参数](https://blog.csdn.net/flqbestboy/article/details/77007807)\n","slug":"函数","published":0,"date":"2019-10-14T07:05:49.236Z","updated":"2019-10-23T08:05:57.876Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckb1z4dfq00169n94ijkko50x","content":"<h2 id=\"函数的类型\"><a href=\"#函数的类型\" class=\"headerlink\" title=\"函数的类型\"></a>函数的类型</h2><p>在 ECMAScript 中有三种函数类型：<code>函数声明</code>，<code>函数表达式</code>和<code>函数构造器创建的函数</code>。每一种都有自己的特点。</p>\n<h2 id=\"函数申明优先变量申明\"><a href=\"#函数申明优先变量申明\" class=\"headerlink\" title=\"函数申明优先变量申明\"></a>函数申明优先变量申明</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a; // 声明一个变量，标识符为a</span><br><span class=\"line\">function a() &#123; // 声明一个函数，标示符也为a</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">alert(typeof a)</span><br><span class=\"line\"></span><br><span class=\"line\">// 互换位置</span><br><span class=\"line\">function a() &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var a;</span><br><span class=\"line\">alert(typeof a);</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function a() &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var a = 1; // 注意此处</span><br><span class=\"line\">alert(typeof a);</span><br><span class=\"line\"></span><br><span class=\"line\">// 互换位置</span><br><span class=\"line\">var a = 1; // 注意此处</span><br><span class=\"line\">function a() &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">alert(typeof a);</span><br></pre></td></tr></table></figure>\n\n<p>相当于</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function a() &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var a;</span><br><span class=\"line\">a = 1; // 注意此处</span><br><span class=\"line\">alert(typeof a);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"函数的参数问题\"><a href=\"#函数的参数问题\" class=\"headerlink\" title=\"函数的参数问题\"></a>函数的参数问题</h2><p>重点：参数的类型问题，是基本数据类型还是引用类型</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a=[1,2,3];</span><br><span class=\"line\">function foo(i)&#123;</span><br><span class=\"line\">    i=[4,5,6];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">foo(a);</span><br><span class=\"line\">console.log(a);</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a=[1,2,3];</span><br><span class=\"line\">function foo(i)&#123;</span><br><span class=\"line\">    i.push(4);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">foo(a);</span><br><span class=\"line\">console.log(a);</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function changeObjProperty(o) &#123;</span><br><span class=\"line\">  o.siteUrl = &quot;http://www.baidu.com&quot;</span><br><span class=\"line\">  o = new Object()</span><br><span class=\"line\">  o.siteUrl = &quot;http://www.google.com&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let webSite = new Object();</span><br><span class=\"line\">changeObjProperty(webSite);</span><br><span class=\"line\">console.log(webSite.siteUrl);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"非匿名自执行函数，函数名只读\"><a href=\"#非匿名自执行函数，函数名只读\" class=\"headerlink\" title=\"非匿名自执行函数，函数名只读\"></a>非匿名自执行函数，函数名只读</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var b = 10;</span><br><span class=\"line\">(function b() &#123;</span><br><span class=\"line\">   // 内部作用域，会先去查找是有已有变量b的声明，有就直接赋值20，确实有了呀。发现了具名函数 function b()&#123;&#125;，拿此b做赋值；</span><br><span class=\"line\">   // IIFE的函数无法进行赋值（内部机制，类似const定义的常量），所以无效。</span><br><span class=\"line\">  // （这里说的“内部机制”，想搞清楚，需要去查阅一些资料，弄明白IIFE在JS引擎的工作方式，堆栈存储IIFE的方式等）</span><br><span class=\"line\">    b = 20;</span><br><span class=\"line\">    console.log(b); // [Function b]</span><br><span class=\"line\">    console.log(window.b); // 10，不是20</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n\n<p>函数表达式与函数声明不同，函数名只在该函数内部有效，并且此绑定是常量绑定。<br>对于一个常量进行赋值，在 strict 模式下会报错，非 strict 模式下静默失败。<br>IIFE 中的函数是函数表达式，而不是函数声明。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const foo = function () &#123;</span><br><span class=\"line\">\tfoo = 10;</span><br><span class=\"line\">\tconsole.log(foo)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">(foo)() // Uncaught TypeError: Assignment to constant variable.</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"IIFE-Immediately-Invoked-Function-Expression\"><a href=\"#IIFE-Immediately-Invoked-Function-Expression\" class=\"headerlink\" title=\"IIFE (Immediately-Invoked Function Expression)\"></a>IIFE (Immediately-Invoked Function Expression)</h2><p><strong>javascript 引擎规定，如果 function 关键字出现在行首，一律解释成函数声明语句；而函数声明后面是不能跟圆括号的（匿名函数是函数声明的一种）。然而，函数表达式的后面可以跟圆括号。所以可以将函数声明转换成函数表达式。</strong></p>\n<p>所以，解决方法就是不要让 function 出现在行首，让引擎将其理解成一个表达式</p>\n<p>最常用的两种办法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(function()&#123;</span><br><span class=\"line\">    console.log(123);</span><br><span class=\"line\">&#125;());</span><br><span class=\"line\"></span><br><span class=\"line\">(function()&#123;</span><br><span class=\"line\">    console.log(123);</span><br><span class=\"line\"> &#125;)();</span><br><span class=\"line\"></span><br><span class=\"line\">(function waq() &#123;</span><br><span class=\"line\">    console.log(123);</span><br><span class=\"line\">&#125;)()</span><br></pre></td></tr></table></figure>\n\n<p>总结 IFEE 的优点：</p>\n<ol>\n<li>创建块级（私有）作用域，避免了向全局作用域中添加变量和函数，因此也避免了多人开发中全局变量和函数的命名冲突；</li>\n<li>IIFE 中定义的任何变量和函数，都会在执行结束时被销毁。这种做法可以减少闭包占用的内存问题，因为没有指向匿名函数的引用。只要函数执行完毕，就可以立即销毁其作用域链了；</li>\n</ol>\n<p>相关阅读：<br><a href=\"https://www.zhihu.com/question/27114726\" target=\"_blank\" rel=\"noopener\">https://www.zhihu.com/question/27114726</a><br><a href=\"https://blog.csdn.net/love2016hy/article/details/77619491\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/love2016hy/article/details/77619491</a><br><a href=\"https://stackoverflow.com/questions/518000/is-javascript-a-pass-by-reference-or-pass-by-value-language?lq=1\" target=\"_blank\" rel=\"noopener\">https://stackoverflow.com/questions/518000/is-javascript-a-pass-by-reference-or-pass-by-value-language?lq=1</a><br><a href=\"https://juejin.im/post/5c2f4c8a518825255d2957d1\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/5c2f4c8a518825255d2957d1</a><br><a href=\"https://www.zhihu.com/question/60063924\" target=\"_blank\" rel=\"noopener\">https://www.zhihu.com/question/60063924</a><br><a href=\"https://www.cnblogs.com/TomXu/archive/2012/01/30/2326372.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/TomXu/archive/2012/01/30/2326372.html</a><br><a href=\"https://www.cnblogs.com/liyan-web/p/5911295.html\" target=\"_blank\" rel=\"noopener\">函数内定义申明一个和形参名字一样的变量</a><br><a href=\"https://blog.csdn.net/flqbestboy/article/details/77007807\" target=\"_blank\" rel=\"noopener\">函数内的参数</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"函数的类型\"><a href=\"#函数的类型\" class=\"headerlink\" title=\"函数的类型\"></a>函数的类型</h2><p>在 ECMAScript 中有三种函数类型：<code>函数声明</code>，<code>函数表达式</code>和<code>函数构造器创建的函数</code>。每一种都有自己的特点。</p>\n<h2 id=\"函数申明优先变量申明\"><a href=\"#函数申明优先变量申明\" class=\"headerlink\" title=\"函数申明优先变量申明\"></a>函数申明优先变量申明</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a; // 声明一个变量，标识符为a</span><br><span class=\"line\">function a() &#123; // 声明一个函数，标示符也为a</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">alert(typeof a)</span><br><span class=\"line\"></span><br><span class=\"line\">// 互换位置</span><br><span class=\"line\">function a() &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var a;</span><br><span class=\"line\">alert(typeof a);</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function a() &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var a = 1; // 注意此处</span><br><span class=\"line\">alert(typeof a);</span><br><span class=\"line\"></span><br><span class=\"line\">// 互换位置</span><br><span class=\"line\">var a = 1; // 注意此处</span><br><span class=\"line\">function a() &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">alert(typeof a);</span><br></pre></td></tr></table></figure>\n\n<p>相当于</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function a() &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var a;</span><br><span class=\"line\">a = 1; // 注意此处</span><br><span class=\"line\">alert(typeof a);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"函数的参数问题\"><a href=\"#函数的参数问题\" class=\"headerlink\" title=\"函数的参数问题\"></a>函数的参数问题</h2><p>重点：参数的类型问题，是基本数据类型还是引用类型</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a=[1,2,3];</span><br><span class=\"line\">function foo(i)&#123;</span><br><span class=\"line\">    i=[4,5,6];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">foo(a);</span><br><span class=\"line\">console.log(a);</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a=[1,2,3];</span><br><span class=\"line\">function foo(i)&#123;</span><br><span class=\"line\">    i.push(4);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">foo(a);</span><br><span class=\"line\">console.log(a);</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function changeObjProperty(o) &#123;</span><br><span class=\"line\">  o.siteUrl = &quot;http://www.baidu.com&quot;</span><br><span class=\"line\">  o = new Object()</span><br><span class=\"line\">  o.siteUrl = &quot;http://www.google.com&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let webSite = new Object();</span><br><span class=\"line\">changeObjProperty(webSite);</span><br><span class=\"line\">console.log(webSite.siteUrl);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"非匿名自执行函数，函数名只读\"><a href=\"#非匿名自执行函数，函数名只读\" class=\"headerlink\" title=\"非匿名自执行函数，函数名只读\"></a>非匿名自执行函数，函数名只读</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var b = 10;</span><br><span class=\"line\">(function b() &#123;</span><br><span class=\"line\">   // 内部作用域，会先去查找是有已有变量b的声明，有就直接赋值20，确实有了呀。发现了具名函数 function b()&#123;&#125;，拿此b做赋值；</span><br><span class=\"line\">   // IIFE的函数无法进行赋值（内部机制，类似const定义的常量），所以无效。</span><br><span class=\"line\">  // （这里说的“内部机制”，想搞清楚，需要去查阅一些资料，弄明白IIFE在JS引擎的工作方式，堆栈存储IIFE的方式等）</span><br><span class=\"line\">    b = 20;</span><br><span class=\"line\">    console.log(b); // [Function b]</span><br><span class=\"line\">    console.log(window.b); // 10，不是20</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n\n<p>函数表达式与函数声明不同，函数名只在该函数内部有效，并且此绑定是常量绑定。<br>对于一个常量进行赋值，在 strict 模式下会报错，非 strict 模式下静默失败。<br>IIFE 中的函数是函数表达式，而不是函数声明。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const foo = function () &#123;</span><br><span class=\"line\">\tfoo = 10;</span><br><span class=\"line\">\tconsole.log(foo)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">(foo)() // Uncaught TypeError: Assignment to constant variable.</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"IIFE-Immediately-Invoked-Function-Expression\"><a href=\"#IIFE-Immediately-Invoked-Function-Expression\" class=\"headerlink\" title=\"IIFE (Immediately-Invoked Function Expression)\"></a>IIFE (Immediately-Invoked Function Expression)</h2><p><strong>javascript 引擎规定，如果 function 关键字出现在行首，一律解释成函数声明语句；而函数声明后面是不能跟圆括号的（匿名函数是函数声明的一种）。然而，函数表达式的后面可以跟圆括号。所以可以将函数声明转换成函数表达式。</strong></p>\n<p>所以，解决方法就是不要让 function 出现在行首，让引擎将其理解成一个表达式</p>\n<p>最常用的两种办法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(function()&#123;</span><br><span class=\"line\">    console.log(123);</span><br><span class=\"line\">&#125;());</span><br><span class=\"line\"></span><br><span class=\"line\">(function()&#123;</span><br><span class=\"line\">    console.log(123);</span><br><span class=\"line\"> &#125;)();</span><br><span class=\"line\"></span><br><span class=\"line\">(function waq() &#123;</span><br><span class=\"line\">    console.log(123);</span><br><span class=\"line\">&#125;)()</span><br></pre></td></tr></table></figure>\n\n<p>总结 IFEE 的优点：</p>\n<ol>\n<li>创建块级（私有）作用域，避免了向全局作用域中添加变量和函数，因此也避免了多人开发中全局变量和函数的命名冲突；</li>\n<li>IIFE 中定义的任何变量和函数，都会在执行结束时被销毁。这种做法可以减少闭包占用的内存问题，因为没有指向匿名函数的引用。只要函数执行完毕，就可以立即销毁其作用域链了；</li>\n</ol>\n<p>相关阅读：<br><a href=\"https://www.zhihu.com/question/27114726\" target=\"_blank\" rel=\"noopener\">https://www.zhihu.com/question/27114726</a><br><a href=\"https://blog.csdn.net/love2016hy/article/details/77619491\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/love2016hy/article/details/77619491</a><br><a href=\"https://stackoverflow.com/questions/518000/is-javascript-a-pass-by-reference-or-pass-by-value-language?lq=1\" target=\"_blank\" rel=\"noopener\">https://stackoverflow.com/questions/518000/is-javascript-a-pass-by-reference-or-pass-by-value-language?lq=1</a><br><a href=\"https://juejin.im/post/5c2f4c8a518825255d2957d1\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/5c2f4c8a518825255d2957d1</a><br><a href=\"https://www.zhihu.com/question/60063924\" target=\"_blank\" rel=\"noopener\">https://www.zhihu.com/question/60063924</a><br><a href=\"https://www.cnblogs.com/TomXu/archive/2012/01/30/2326372.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/TomXu/archive/2012/01/30/2326372.html</a><br><a href=\"https://www.cnblogs.com/liyan-web/p/5911295.html\" target=\"_blank\" rel=\"noopener\">函数内定义申明一个和形参名字一样的变量</a><br><a href=\"https://blog.csdn.net/flqbestboy/article/details/77007807\" target=\"_blank\" rel=\"noopener\">函数内的参数</a></p>\n"},{"title":"多变的this","_content":"\n**重要的事情说三遍: 谁调用就指向谁！！！**\n**重要的事情说三遍: 谁调用就指向谁！！！**\n**重要的事情说三遍: 谁调用就指向谁！！！**\n\nthis 是在函数运行时产生，全局的 this 指向 window。\n\n其实 this 指向问题并不是特别复杂，我们把所有的情况列举出来，实践中遇到就一清二楚了。\n\n#### 全局调用\n\n#### 作为对象的属性\n","source":"_drafts/多变的this.md","raw":"---\ntitle: 多变的this\ncategories:\ntags:\n---\n\n**重要的事情说三遍: 谁调用就指向谁！！！**\n**重要的事情说三遍: 谁调用就指向谁！！！**\n**重要的事情说三遍: 谁调用就指向谁！！！**\n\nthis 是在函数运行时产生，全局的 this 指向 window。\n\n其实 this 指向问题并不是特别复杂，我们把所有的情况列举出来，实践中遇到就一清二楚了。\n\n#### 全局调用\n\n#### 作为对象的属性\n","slug":"多变的this","published":0,"date":"2019-08-27T01:56:25.650Z","updated":"2020-05-12T02:11:51.017Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckb1z4dft00189n948kwbyn7h","content":"<p><strong>重要的事情说三遍: 谁调用就指向谁！！！</strong><br><strong>重要的事情说三遍: 谁调用就指向谁！！！</strong><br><strong>重要的事情说三遍: 谁调用就指向谁！！！</strong></p>\n<p>this 是在函数运行时产生，全局的 this 指向 window。</p>\n<p>其实 this 指向问题并不是特别复杂，我们把所有的情况列举出来，实践中遇到就一清二楚了。</p>\n<h4 id=\"全局调用\"><a href=\"#全局调用\" class=\"headerlink\" title=\"全局调用\"></a>全局调用</h4><h4 id=\"作为对象的属性\"><a href=\"#作为对象的属性\" class=\"headerlink\" title=\"作为对象的属性\"></a>作为对象的属性</h4>","site":{"data":{}},"excerpt":"","more":"<p><strong>重要的事情说三遍: 谁调用就指向谁！！！</strong><br><strong>重要的事情说三遍: 谁调用就指向谁！！！</strong><br><strong>重要的事情说三遍: 谁调用就指向谁！！！</strong></p>\n<p>this 是在函数运行时产生，全局的 this 指向 window。</p>\n<p>其实 this 指向问题并不是特别复杂，我们把所有的情况列举出来，实践中遇到就一清二楚了。</p>\n<h4 id=\"全局调用\"><a href=\"#全局调用\" class=\"headerlink\" title=\"全局调用\"></a>全局调用</h4><h4 id=\"作为对象的属性\"><a href=\"#作为对象的属性\" class=\"headerlink\" title=\"作为对象的属性\"></a>作为对象的属性</h4>"},{"title":"前端安全","_content":"\n## XSS （跨站脚本攻击）\n\nCross-Site Scripting（跨站脚本攻击）简称 XSS，是一种代码注入攻击。攻击者通过在目标网站上注入恶意脚本，使之在用户的浏览器上运行。利用这些恶意脚本，攻击者可获取用户的敏感信息如 Cookie、SessionID 等，进而危害数据安全。\n\n为了和 CSS 区分，这里把攻击的第一个字母改成了 X，于是叫做 XSS。\n\nXSS 的本质是：恶意代码未经过滤，与网站正常的代码混在一起；浏览器无法分辨哪些脚本是可信的，导致恶意脚本被执行。\n\n而由于直接在用户的终端执行，恶意代码能够直接获取用户的信息，或者利用这些信息冒充用户向网站发起攻击者定义的请求。\n\n在部分情况下，由于输入的限制，注入的恶意脚本比较短。但可以通过引入外部的脚本，并由浏览器执行，来完成比较复杂的攻击策略。\n\n## XSS 分类\n\n根据攻击的来源，XSS 攻击可分为存储型、反射型和 DOM 型三种\n\n**存储型 XSS**\n\n存储型 XSS 的攻击步骤：\n\n1. 攻击者将恶意代码提交到目标网站的数据库中。\n2. 用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器。\n3. 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。\n4. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。\n\n这种攻击常见于带有用户保存数据的网站功能，如论坛发帖、商品评论、用户私信等。\n\n**反射型 XSS**\n\n反射型 XSS 的攻击步骤：\n\n1. 攻击者构造出特殊的 URL，其中包含恶意代码。\n2. 用户打开带有恶意代码的 URL 时，网站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。\n3. 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。\n4. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。\n\n反射型 XSS 跟存储型 XSS 的区别是：存储型 XSS 的恶意代码存在数据库里，反射型 XSS 的恶意代码存在 URL 里。\n反射型 XSS 漏洞常见于通过 URL 传递参数的功能，如网站搜索、跳转等。\n由于需要用户主动打开恶意的 URL 才能生效，攻击者往往会结合多种手段诱导用户点击。\nPOST 的内容也可以触发反射型 XSS，只不过其触发条件比较苛刻（需要构造表单提交页面，并引导用户点击），所以非常少见。\n\n**DOM 型 XSS**\n\nDOM 型 XSS 的攻击步骤：\n\n1. 攻击者构造出特殊的 URL，其中包含恶意代码。\n2. 用户打开带有恶意代码的 URL。\n3. 用户浏览器接收到响应后解析执行，前端 JavaScript 取出 URL 中的恶意代码并执行。\n4. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。\n\nDOM 型 XSS 跟前两种 XSS 的区别：DOM 型 XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞，而其他两种 XSS 都属于服务端的安全漏洞。\n\n## 预防 DOM 型 XSS 攻击\n\n**DOM 型 XSS 攻击，实际上就是网站前端 JavaScript 代码本身不够严谨，把不可信的数据当作代码执行了。**\n在使用 .innerHTML、.outerHTML、document.write() 时要特别小心，不要把不可信的数据作为 HTML 插到页面上，而应尽量使用 .textContent、.setAttribute() 等。\n如果用 Vue/React 技术栈，并且不使用 v-html/dangerouslySetInnerHTML 功能，就在前端 render 阶段避免 innerHTML、outerHTML 的 XSS 隐患。\nDOM 中的内联事件监听器，如 location、onclick、onerror、onload、onmouseover 等，<a> 标签的 href 属性，JavaScript 的 eval()、setTimeout()、setInterval() 等，都能把字符串作为代码运行。如果不可信的数据拼接到字符串中传递给这些 API，很容易产生安全隐患，请务必避免。\n\n```\ninput: 前端过滤，入库，后端过滤\noutput: 后端过滤，输出，前端过滤\n```\n\n## CSRF(Cross-site request forgery) （跨站请求伪造）\n\nCSRF（Cross-site request forgery）跨站请求伪造，也被称为“One Click Attack”或者 Session Riding，通常缩写为 CSRF 或者 XSRF，是一种对网站的恶意利用。尽管听起来像跨站脚本，但它与 XSS 非常不同，XSS 利用站点内的信任用户，而 CSRF 则通过伪装成受信任用户的请求来利用受信任的网站。攻击通过在授权用户访问的页面中包含链接或者脚本的方式工作\n\nCSRF 攻击\n一个典型的 CSRF 攻击流程大概如下:\n\n用户登录 a.com 并保留登录信息\n攻击者引诱用户访问了 b.com\nb.com 在用户不知情的情况下向 a.com 发送请求并携带用户的登录信息\na.com 接收请求验证登录信息通过执行某些恶意操作\n攻击者在用户不知情的情况下冒充用户的身份完成了攻击.\n攻击方式:\n\n攻击者的网站\n有文件上传漏洞的网站\n第三方论坛,博客等网站\n目标网站自身的漏洞\n相对 XSS 攻击,CSRF 攻击不太一样\n\n一般攻击发起点不在目标网站,而是被引导到第三方网站再发起攻击,这样目标网站就无法防止\n攻击者不能获取到用户 Cookies,包括子域名,而是利用 Cookies 的特性冒充用户身份进行攻击\n通常是跨域攻击,因为攻击者更容易掌握第三方网站而不是只能利用目标网站自身漏洞\n攻击方式包括图片,URL,CORS,表单,甚至直接嵌入第三方论坛,文章等等,难以追踪\n\n相关阅读：\n[XSS](https://juejin.im/post/5bad9140e51d450e935c6d64)\n[CSRF](https://lequ7.com/2019/08/06/javascript/qian-duan-an-quan-xi-lie-CSRF-pian/)\n","source":"_drafts/前端安全.md","raw":"---\ntitle: 前端安全\ncategories:\ntags:\n  - 前端\n---\n\n## XSS （跨站脚本攻击）\n\nCross-Site Scripting（跨站脚本攻击）简称 XSS，是一种代码注入攻击。攻击者通过在目标网站上注入恶意脚本，使之在用户的浏览器上运行。利用这些恶意脚本，攻击者可获取用户的敏感信息如 Cookie、SessionID 等，进而危害数据安全。\n\n为了和 CSS 区分，这里把攻击的第一个字母改成了 X，于是叫做 XSS。\n\nXSS 的本质是：恶意代码未经过滤，与网站正常的代码混在一起；浏览器无法分辨哪些脚本是可信的，导致恶意脚本被执行。\n\n而由于直接在用户的终端执行，恶意代码能够直接获取用户的信息，或者利用这些信息冒充用户向网站发起攻击者定义的请求。\n\n在部分情况下，由于输入的限制，注入的恶意脚本比较短。但可以通过引入外部的脚本，并由浏览器执行，来完成比较复杂的攻击策略。\n\n## XSS 分类\n\n根据攻击的来源，XSS 攻击可分为存储型、反射型和 DOM 型三种\n\n**存储型 XSS**\n\n存储型 XSS 的攻击步骤：\n\n1. 攻击者将恶意代码提交到目标网站的数据库中。\n2. 用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器。\n3. 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。\n4. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。\n\n这种攻击常见于带有用户保存数据的网站功能，如论坛发帖、商品评论、用户私信等。\n\n**反射型 XSS**\n\n反射型 XSS 的攻击步骤：\n\n1. 攻击者构造出特殊的 URL，其中包含恶意代码。\n2. 用户打开带有恶意代码的 URL 时，网站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。\n3. 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。\n4. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。\n\n反射型 XSS 跟存储型 XSS 的区别是：存储型 XSS 的恶意代码存在数据库里，反射型 XSS 的恶意代码存在 URL 里。\n反射型 XSS 漏洞常见于通过 URL 传递参数的功能，如网站搜索、跳转等。\n由于需要用户主动打开恶意的 URL 才能生效，攻击者往往会结合多种手段诱导用户点击。\nPOST 的内容也可以触发反射型 XSS，只不过其触发条件比较苛刻（需要构造表单提交页面，并引导用户点击），所以非常少见。\n\n**DOM 型 XSS**\n\nDOM 型 XSS 的攻击步骤：\n\n1. 攻击者构造出特殊的 URL，其中包含恶意代码。\n2. 用户打开带有恶意代码的 URL。\n3. 用户浏览器接收到响应后解析执行，前端 JavaScript 取出 URL 中的恶意代码并执行。\n4. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。\n\nDOM 型 XSS 跟前两种 XSS 的区别：DOM 型 XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞，而其他两种 XSS 都属于服务端的安全漏洞。\n\n## 预防 DOM 型 XSS 攻击\n\n**DOM 型 XSS 攻击，实际上就是网站前端 JavaScript 代码本身不够严谨，把不可信的数据当作代码执行了。**\n在使用 .innerHTML、.outerHTML、document.write() 时要特别小心，不要把不可信的数据作为 HTML 插到页面上，而应尽量使用 .textContent、.setAttribute() 等。\n如果用 Vue/React 技术栈，并且不使用 v-html/dangerouslySetInnerHTML 功能，就在前端 render 阶段避免 innerHTML、outerHTML 的 XSS 隐患。\nDOM 中的内联事件监听器，如 location、onclick、onerror、onload、onmouseover 等，<a> 标签的 href 属性，JavaScript 的 eval()、setTimeout()、setInterval() 等，都能把字符串作为代码运行。如果不可信的数据拼接到字符串中传递给这些 API，很容易产生安全隐患，请务必避免。\n\n```\ninput: 前端过滤，入库，后端过滤\noutput: 后端过滤，输出，前端过滤\n```\n\n## CSRF(Cross-site request forgery) （跨站请求伪造）\n\nCSRF（Cross-site request forgery）跨站请求伪造，也被称为“One Click Attack”或者 Session Riding，通常缩写为 CSRF 或者 XSRF，是一种对网站的恶意利用。尽管听起来像跨站脚本，但它与 XSS 非常不同，XSS 利用站点内的信任用户，而 CSRF 则通过伪装成受信任用户的请求来利用受信任的网站。攻击通过在授权用户访问的页面中包含链接或者脚本的方式工作\n\nCSRF 攻击\n一个典型的 CSRF 攻击流程大概如下:\n\n用户登录 a.com 并保留登录信息\n攻击者引诱用户访问了 b.com\nb.com 在用户不知情的情况下向 a.com 发送请求并携带用户的登录信息\na.com 接收请求验证登录信息通过执行某些恶意操作\n攻击者在用户不知情的情况下冒充用户的身份完成了攻击.\n攻击方式:\n\n攻击者的网站\n有文件上传漏洞的网站\n第三方论坛,博客等网站\n目标网站自身的漏洞\n相对 XSS 攻击,CSRF 攻击不太一样\n\n一般攻击发起点不在目标网站,而是被引导到第三方网站再发起攻击,这样目标网站就无法防止\n攻击者不能获取到用户 Cookies,包括子域名,而是利用 Cookies 的特性冒充用户身份进行攻击\n通常是跨域攻击,因为攻击者更容易掌握第三方网站而不是只能利用目标网站自身漏洞\n攻击方式包括图片,URL,CORS,表单,甚至直接嵌入第三方论坛,文章等等,难以追踪\n\n相关阅读：\n[XSS](https://juejin.im/post/5bad9140e51d450e935c6d64)\n[CSRF](https://lequ7.com/2019/08/06/javascript/qian-duan-an-quan-xi-lie-CSRF-pian/)\n","slug":"前端安全","published":0,"date":"2019-10-08T01:39:12.287Z","updated":"2020-05-21T07:09:01.674Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckb1z4dfu001b9n94fbrfxjdt","content":"<h2 id=\"XSS-（跨站脚本攻击）\"><a href=\"#XSS-（跨站脚本攻击）\" class=\"headerlink\" title=\"XSS （跨站脚本攻击）\"></a>XSS （跨站脚本攻击）</h2><p>Cross-Site Scripting（跨站脚本攻击）简称 XSS，是一种代码注入攻击。攻击者通过在目标网站上注入恶意脚本，使之在用户的浏览器上运行。利用这些恶意脚本，攻击者可获取用户的敏感信息如 Cookie、SessionID 等，进而危害数据安全。</p>\n<p>为了和 CSS 区分，这里把攻击的第一个字母改成了 X，于是叫做 XSS。</p>\n<p>XSS 的本质是：恶意代码未经过滤，与网站正常的代码混在一起；浏览器无法分辨哪些脚本是可信的，导致恶意脚本被执行。</p>\n<p>而由于直接在用户的终端执行，恶意代码能够直接获取用户的信息，或者利用这些信息冒充用户向网站发起攻击者定义的请求。</p>\n<p>在部分情况下，由于输入的限制，注入的恶意脚本比较短。但可以通过引入外部的脚本，并由浏览器执行，来完成比较复杂的攻击策略。</p>\n<h2 id=\"XSS-分类\"><a href=\"#XSS-分类\" class=\"headerlink\" title=\"XSS 分类\"></a>XSS 分类</h2><p>根据攻击的来源，XSS 攻击可分为存储型、反射型和 DOM 型三种</p>\n<p><strong>存储型 XSS</strong></p>\n<p>存储型 XSS 的攻击步骤：</p>\n<ol>\n<li>攻击者将恶意代码提交到目标网站的数据库中。</li>\n<li>用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器。</li>\n<li>用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。</li>\n<li>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。</li>\n</ol>\n<p>这种攻击常见于带有用户保存数据的网站功能，如论坛发帖、商品评论、用户私信等。</p>\n<p><strong>反射型 XSS</strong></p>\n<p>反射型 XSS 的攻击步骤：</p>\n<ol>\n<li>攻击者构造出特殊的 URL，其中包含恶意代码。</li>\n<li>用户打开带有恶意代码的 URL 时，网站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。</li>\n<li>用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。</li>\n<li>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。</li>\n</ol>\n<p>反射型 XSS 跟存储型 XSS 的区别是：存储型 XSS 的恶意代码存在数据库里，反射型 XSS 的恶意代码存在 URL 里。<br>反射型 XSS 漏洞常见于通过 URL 传递参数的功能，如网站搜索、跳转等。<br>由于需要用户主动打开恶意的 URL 才能生效，攻击者往往会结合多种手段诱导用户点击。<br>POST 的内容也可以触发反射型 XSS，只不过其触发条件比较苛刻（需要构造表单提交页面，并引导用户点击），所以非常少见。</p>\n<p><strong>DOM 型 XSS</strong></p>\n<p>DOM 型 XSS 的攻击步骤：</p>\n<ol>\n<li>攻击者构造出特殊的 URL，其中包含恶意代码。</li>\n<li>用户打开带有恶意代码的 URL。</li>\n<li>用户浏览器接收到响应后解析执行，前端 JavaScript 取出 URL 中的恶意代码并执行。</li>\n<li>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。</li>\n</ol>\n<p>DOM 型 XSS 跟前两种 XSS 的区别：DOM 型 XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞，而其他两种 XSS 都属于服务端的安全漏洞。</p>\n<h2 id=\"预防-DOM-型-XSS-攻击\"><a href=\"#预防-DOM-型-XSS-攻击\" class=\"headerlink\" title=\"预防 DOM 型 XSS 攻击\"></a>预防 DOM 型 XSS 攻击</h2><p><strong>DOM 型 XSS 攻击，实际上就是网站前端 JavaScript 代码本身不够严谨，把不可信的数据当作代码执行了。</strong><br>在使用 .innerHTML、.outerHTML、document.write() 时要特别小心，不要把不可信的数据作为 HTML 插到页面上，而应尽量使用 .textContent、.setAttribute() 等。<br>如果用 Vue/React 技术栈，并且不使用 v-html/dangerouslySetInnerHTML 功能，就在前端 render 阶段避免 innerHTML、outerHTML 的 XSS 隐患。<br>DOM 中的内联事件监听器，如 location、onclick、onerror、onload、onmouseover 等，<a> 标签的 href 属性，JavaScript 的 eval()、setTimeout()、setInterval() 等，都能把字符串作为代码运行。如果不可信的数据拼接到字符串中传递给这些 API，很容易产生安全隐患，请务必避免。</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">input: 前端过滤，入库，后端过滤</span><br><span class=\"line\">output: 后端过滤，输出，前端过滤</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"CSRF-Cross-site-request-forgery-（跨站请求伪造）\"><a href=\"#CSRF-Cross-site-request-forgery-（跨站请求伪造）\" class=\"headerlink\" title=\"CSRF(Cross-site request forgery) （跨站请求伪造）\"></a>CSRF(Cross-site request forgery) （跨站请求伪造）</h2><p>CSRF（Cross-site request forgery）跨站请求伪造，也被称为“One Click Attack”或者 Session Riding，通常缩写为 CSRF 或者 XSRF，是一种对网站的恶意利用。尽管听起来像跨站脚本，但它与 XSS 非常不同，XSS 利用站点内的信任用户，而 CSRF 则通过伪装成受信任用户的请求来利用受信任的网站。攻击通过在授权用户访问的页面中包含链接或者脚本的方式工作</p>\n<p>CSRF 攻击<br>一个典型的 CSRF 攻击流程大概如下:</p>\n<p>用户登录 a.com 并保留登录信息<br>攻击者引诱用户访问了 b.com<br>b.com 在用户不知情的情况下向 a.com 发送请求并携带用户的登录信息<br>a.com 接收请求验证登录信息通过执行某些恶意操作<br>攻击者在用户不知情的情况下冒充用户的身份完成了攻击.<br>攻击方式:</p>\n<p>攻击者的网站<br>有文件上传漏洞的网站<br>第三方论坛,博客等网站<br>目标网站自身的漏洞<br>相对 XSS 攻击,CSRF 攻击不太一样</p>\n<p>一般攻击发起点不在目标网站,而是被引导到第三方网站再发起攻击,这样目标网站就无法防止<br>攻击者不能获取到用户 Cookies,包括子域名,而是利用 Cookies 的特性冒充用户身份进行攻击<br>通常是跨域攻击,因为攻击者更容易掌握第三方网站而不是只能利用目标网站自身漏洞<br>攻击方式包括图片,URL,CORS,表单,甚至直接嵌入第三方论坛,文章等等,难以追踪</p>\n<p>相关阅读：<br><a href=\"https://juejin.im/post/5bad9140e51d450e935c6d64\" target=\"_blank\" rel=\"noopener\">XSS</a><br><a href=\"https://lequ7.com/2019/08/06/javascript/qian-duan-an-quan-xi-lie-CSRF-pian/\" target=\"_blank\" rel=\"noopener\">CSRF</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"XSS-（跨站脚本攻击）\"><a href=\"#XSS-（跨站脚本攻击）\" class=\"headerlink\" title=\"XSS （跨站脚本攻击）\"></a>XSS （跨站脚本攻击）</h2><p>Cross-Site Scripting（跨站脚本攻击）简称 XSS，是一种代码注入攻击。攻击者通过在目标网站上注入恶意脚本，使之在用户的浏览器上运行。利用这些恶意脚本，攻击者可获取用户的敏感信息如 Cookie、SessionID 等，进而危害数据安全。</p>\n<p>为了和 CSS 区分，这里把攻击的第一个字母改成了 X，于是叫做 XSS。</p>\n<p>XSS 的本质是：恶意代码未经过滤，与网站正常的代码混在一起；浏览器无法分辨哪些脚本是可信的，导致恶意脚本被执行。</p>\n<p>而由于直接在用户的终端执行，恶意代码能够直接获取用户的信息，或者利用这些信息冒充用户向网站发起攻击者定义的请求。</p>\n<p>在部分情况下，由于输入的限制，注入的恶意脚本比较短。但可以通过引入外部的脚本，并由浏览器执行，来完成比较复杂的攻击策略。</p>\n<h2 id=\"XSS-分类\"><a href=\"#XSS-分类\" class=\"headerlink\" title=\"XSS 分类\"></a>XSS 分类</h2><p>根据攻击的来源，XSS 攻击可分为存储型、反射型和 DOM 型三种</p>\n<p><strong>存储型 XSS</strong></p>\n<p>存储型 XSS 的攻击步骤：</p>\n<ol>\n<li>攻击者将恶意代码提交到目标网站的数据库中。</li>\n<li>用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器。</li>\n<li>用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。</li>\n<li>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。</li>\n</ol>\n<p>这种攻击常见于带有用户保存数据的网站功能，如论坛发帖、商品评论、用户私信等。</p>\n<p><strong>反射型 XSS</strong></p>\n<p>反射型 XSS 的攻击步骤：</p>\n<ol>\n<li>攻击者构造出特殊的 URL，其中包含恶意代码。</li>\n<li>用户打开带有恶意代码的 URL 时，网站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。</li>\n<li>用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。</li>\n<li>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。</li>\n</ol>\n<p>反射型 XSS 跟存储型 XSS 的区别是：存储型 XSS 的恶意代码存在数据库里，反射型 XSS 的恶意代码存在 URL 里。<br>反射型 XSS 漏洞常见于通过 URL 传递参数的功能，如网站搜索、跳转等。<br>由于需要用户主动打开恶意的 URL 才能生效，攻击者往往会结合多种手段诱导用户点击。<br>POST 的内容也可以触发反射型 XSS，只不过其触发条件比较苛刻（需要构造表单提交页面，并引导用户点击），所以非常少见。</p>\n<p><strong>DOM 型 XSS</strong></p>\n<p>DOM 型 XSS 的攻击步骤：</p>\n<ol>\n<li>攻击者构造出特殊的 URL，其中包含恶意代码。</li>\n<li>用户打开带有恶意代码的 URL。</li>\n<li>用户浏览器接收到响应后解析执行，前端 JavaScript 取出 URL 中的恶意代码并执行。</li>\n<li>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。</li>\n</ol>\n<p>DOM 型 XSS 跟前两种 XSS 的区别：DOM 型 XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞，而其他两种 XSS 都属于服务端的安全漏洞。</p>\n<h2 id=\"预防-DOM-型-XSS-攻击\"><a href=\"#预防-DOM-型-XSS-攻击\" class=\"headerlink\" title=\"预防 DOM 型 XSS 攻击\"></a>预防 DOM 型 XSS 攻击</h2><p><strong>DOM 型 XSS 攻击，实际上就是网站前端 JavaScript 代码本身不够严谨，把不可信的数据当作代码执行了。</strong><br>在使用 .innerHTML、.outerHTML、document.write() 时要特别小心，不要把不可信的数据作为 HTML 插到页面上，而应尽量使用 .textContent、.setAttribute() 等。<br>如果用 Vue/React 技术栈，并且不使用 v-html/dangerouslySetInnerHTML 功能，就在前端 render 阶段避免 innerHTML、outerHTML 的 XSS 隐患。<br>DOM 中的内联事件监听器，如 location、onclick、onerror、onload、onmouseover 等，<a> 标签的 href 属性，JavaScript 的 eval()、setTimeout()、setInterval() 等，都能把字符串作为代码运行。如果不可信的数据拼接到字符串中传递给这些 API，很容易产生安全隐患，请务必避免。</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">input: 前端过滤，入库，后端过滤</span><br><span class=\"line\">output: 后端过滤，输出，前端过滤</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"CSRF-Cross-site-request-forgery-（跨站请求伪造）\"><a href=\"#CSRF-Cross-site-request-forgery-（跨站请求伪造）\" class=\"headerlink\" title=\"CSRF(Cross-site request forgery) （跨站请求伪造）\"></a>CSRF(Cross-site request forgery) （跨站请求伪造）</h2><p>CSRF（Cross-site request forgery）跨站请求伪造，也被称为“One Click Attack”或者 Session Riding，通常缩写为 CSRF 或者 XSRF，是一种对网站的恶意利用。尽管听起来像跨站脚本，但它与 XSS 非常不同，XSS 利用站点内的信任用户，而 CSRF 则通过伪装成受信任用户的请求来利用受信任的网站。攻击通过在授权用户访问的页面中包含链接或者脚本的方式工作</p>\n<p>CSRF 攻击<br>一个典型的 CSRF 攻击流程大概如下:</p>\n<p>用户登录 a.com 并保留登录信息<br>攻击者引诱用户访问了 b.com<br>b.com 在用户不知情的情况下向 a.com 发送请求并携带用户的登录信息<br>a.com 接收请求验证登录信息通过执行某些恶意操作<br>攻击者在用户不知情的情况下冒充用户的身份完成了攻击.<br>攻击方式:</p>\n<p>攻击者的网站<br>有文件上传漏洞的网站<br>第三方论坛,博客等网站<br>目标网站自身的漏洞<br>相对 XSS 攻击,CSRF 攻击不太一样</p>\n<p>一般攻击发起点不在目标网站,而是被引导到第三方网站再发起攻击,这样目标网站就无法防止<br>攻击者不能获取到用户 Cookies,包括子域名,而是利用 Cookies 的特性冒充用户身份进行攻击<br>通常是跨域攻击,因为攻击者更容易掌握第三方网站而不是只能利用目标网站自身漏洞<br>攻击方式包括图片,URL,CORS,表单,甚至直接嵌入第三方论坛,文章等等,难以追踪</p>\n<p>相关阅读：<br><a href=\"https://juejin.im/post/5bad9140e51d450e935c6d64\" target=\"_blank\" rel=\"noopener\">XSS</a><br><a href=\"https://lequ7.com/2019/08/06/javascript/qian-duan-an-quan-xi-lie-CSRF-pian/\" target=\"_blank\" rel=\"noopener\">CSRF</a></p>\n"},{"title":"实用的函数","_content":"\n## 安全获取深层数据\n\n```\nfunction safeGate(){\n\n}\n```\n","source":"_drafts/实用的函数.md","raw":"---\ntitle: 实用的函数\ncategories:\ntags:\n---\n\n## 安全获取深层数据\n\n```\nfunction safeGate(){\n\n}\n```\n","slug":"实用的函数","published":0,"date":"2019-08-27T03:29:22.956Z","updated":"2020-03-03T06:40:49.922Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckb1z4dfv001e9n94847ep2lb","content":"<h2 id=\"安全获取深层数据\"><a href=\"#安全获取深层数据\" class=\"headerlink\" title=\"安全获取深层数据\"></a>安全获取深层数据</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function safeGate()&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"安全获取深层数据\"><a href=\"#安全获取深层数据\" class=\"headerlink\" title=\"安全获取深层数据\"></a>安全获取深层数据</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function safeGate()&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n"},{"title":"原型链","_content":"\n#### 自我总结\n\n**原型链 === 原型构成的一条链**\n\n#### 原型和原型对象是什么？\n\n原型 === 原型对象\n\n原型就是一个对象，所以原型就是原型对象。\n\n#### 原型对象的产生？\n\n定义构造函数的时候，系统会为它创建原型对象，并且，把构造函数的 prototype 属性指向原型对象，同时原型对象的 contrustor 属性指向构造函数。\n\n[Object.prototype](https://www.zhihu.com/question/60447787)\n","source":"_drafts/原型链.md","raw":"---\ntitle: 原型链\ncategories:\n  - 前端\ntags:\n  - javascript\n---\n\n#### 自我总结\n\n**原型链 === 原型构成的一条链**\n\n#### 原型和原型对象是什么？\n\n原型 === 原型对象\n\n原型就是一个对象，所以原型就是原型对象。\n\n#### 原型对象的产生？\n\n定义构造函数的时候，系统会为它创建原型对象，并且，把构造函数的 prototype 属性指向原型对象，同时原型对象的 contrustor 属性指向构造函数。\n\n[Object.prototype](https://www.zhihu.com/question/60447787)\n","slug":"原型链","published":0,"date":"2020-05-04T02:27:55.889Z","updated":"2020-05-21T07:09:24.037Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckb1z4dfw001f9n94if1nac2j","content":"<h4 id=\"自我总结\"><a href=\"#自我总结\" class=\"headerlink\" title=\"自我总结\"></a>自我总结</h4><p><strong>原型链 === 原型构成的一条链</strong></p>\n<h4 id=\"原型和原型对象是什么？\"><a href=\"#原型和原型对象是什么？\" class=\"headerlink\" title=\"原型和原型对象是什么？\"></a>原型和原型对象是什么？</h4><p>原型 === 原型对象</p>\n<p>原型就是一个对象，所以原型就是原型对象。</p>\n<h4 id=\"原型对象的产生？\"><a href=\"#原型对象的产生？\" class=\"headerlink\" title=\"原型对象的产生？\"></a>原型对象的产生？</h4><p>定义构造函数的时候，系统会为它创建原型对象，并且，把构造函数的 prototype 属性指向原型对象，同时原型对象的 contrustor 属性指向构造函数。</p>\n<p><a href=\"https://www.zhihu.com/question/60447787\" target=\"_blank\" rel=\"noopener\">Object.prototype</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"自我总结\"><a href=\"#自我总结\" class=\"headerlink\" title=\"自我总结\"></a>自我总结</h4><p><strong>原型链 === 原型构成的一条链</strong></p>\n<h4 id=\"原型和原型对象是什么？\"><a href=\"#原型和原型对象是什么？\" class=\"headerlink\" title=\"原型和原型对象是什么？\"></a>原型和原型对象是什么？</h4><p>原型 === 原型对象</p>\n<p>原型就是一个对象，所以原型就是原型对象。</p>\n<h4 id=\"原型对象的产生？\"><a href=\"#原型对象的产生？\" class=\"headerlink\" title=\"原型对象的产生？\"></a>原型对象的产生？</h4><p>定义构造函数的时候，系统会为它创建原型对象，并且，把构造函数的 prototype 属性指向原型对象，同时原型对象的 contrustor 属性指向构造函数。</p>\n<p><a href=\"https://www.zhihu.com/question/60447787\" target=\"_blank\" rel=\"noopener\">Object.prototype</a></p>\n"},{"title":"富文本编辑器","_content":"\n可编辑区域的实现方式有两种:\n\n1. 设置文档为设计模式，嵌入空页面的 iframe，设置 designMode 属性值为“on”，这样整个文档就变得可以编辑。\n\n```\n<iframe name=\"richtext\" src=\"blank.html\"></iframe>\n\nwindow.addEventListener(\"load\"，function ()｛\n frames(\"richtext\").document.designMode = \"on\"\n})\n\n```\n\n2. 使用 contenteditable 属性\n\n```\n <div  id=\"richtext\" contenteditable>\n    <p></p>\n </>\n```\n","source":"_drafts/富文本编辑器.md","raw":"---\ntitle: 富文本编辑器\ncategories:\ntags:\n---\n\n可编辑区域的实现方式有两种:\n\n1. 设置文档为设计模式，嵌入空页面的 iframe，设置 designMode 属性值为“on”，这样整个文档就变得可以编辑。\n\n```\n<iframe name=\"richtext\" src=\"blank.html\"></iframe>\n\nwindow.addEventListener(\"load\"，function ()｛\n frames(\"richtext\").document.designMode = \"on\"\n})\n\n```\n\n2. 使用 contenteditable 属性\n\n```\n <div  id=\"richtext\" contenteditable>\n    <p></p>\n </>\n```\n","slug":"富文本编辑器","published":0,"date":"2020-04-07T01:59:21.888Z","updated":"2020-04-07T02:03:29.905Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckb1z4dfx001h9n94p3vhwo93","content":"<p>可编辑区域的实现方式有两种:</p>\n<ol>\n<li>设置文档为设计模式，嵌入空页面的 iframe，设置 designMode 属性值为“on”，这样整个文档就变得可以编辑。</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;iframe name=&quot;richtext&quot; src=&quot;blank.html&quot;&gt;&lt;/iframe&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">window.addEventListener(&quot;load&quot;，function ()｛</span><br><span class=\"line\"> frames(&quot;richtext&quot;).document.designMode = &quot;on&quot;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>使用 contenteditable 属性</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div  id=&quot;richtext&quot; contenteditable&gt;</span><br><span class=\"line\">   &lt;p&gt;&lt;/p&gt;</span><br><span class=\"line\">&lt;/&gt;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<p>可编辑区域的实现方式有两种:</p>\n<ol>\n<li>设置文档为设计模式，嵌入空页面的 iframe，设置 designMode 属性值为“on”，这样整个文档就变得可以编辑。</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;iframe name=&quot;richtext&quot; src=&quot;blank.html&quot;&gt;&lt;/iframe&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">window.addEventListener(&quot;load&quot;，function ()｛</span><br><span class=\"line\"> frames(&quot;richtext&quot;).document.designMode = &quot;on&quot;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>使用 contenteditable 属性</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div  id=&quot;richtext&quot; contenteditable&gt;</span><br><span class=\"line\">   &lt;p&gt;&lt;/p&gt;</span><br><span class=\"line\">&lt;/&gt;</span><br></pre></td></tr></table></figure>\n\n"},{"title":"循环","_content":"\n## 所有关于循环的\n\n`for`、`while` 、 `do while`、`switch` 、`for in`、 `for of`、 `forEach`、 `map`、 `reduce`\n\n## for\n\n```\n// 先判断后执行\nfor(var i=0;i<100;i++){\n    console.log(i)\n}\n\n()中的i，相当于全局变量，除非用let\n```\n\n## while\n\n// 先判断后执行\n\n```\nwhile (条件) 语句;\n\n//举例：\nvar i = 0;\nwhile (i < 100) {\n    console.log('i=' + i);\n    i++;\n}\n```\n\n## do while\n\n// 先执行，后判断 至少执行一次\n\n```\ndo {\n    语句\n}while(条件)\n\nlet i = 0\ndo{\n    console.log(i);\n    i++\n}where(i<100)\n```\n\n## switch\n\n```\nswitch (new Date().getDay()) {\n    case 0:\n        day = \"星期天\";\n        break;\n    case 1:\n        day = \"星期一\";\n         break;\n    case 2:\n        day = \"星期二\";\n         break;\n    case 3:\n        day = \"星期三\";\n         break;\n    case 4:\n        day = \"星期四\";\n         break;\n    case 5:\n        day = \"星期五\";\n         break;\n    case 6:\n        day = \"星期六\";\n}\n```\n\n## for in\n\nfor..in 是 es5 新增的循环方法 。\n遍历对象的 key 值，访问对象的可枚举属性。有点类似于 Object.keys()\n\n```\n\n```\n\n## for of\n\nfor..of 是 es6 新增的循环方法。\nes6 引入了新的 iterable(迭代)类型，Array,Map,Set 都属于 iterable 类型。\n具有 iterable 类型的集合可以通过 for..of 循环来遍历\n\n```\n\n```\n\n## forEach\n\nforEach 是 ES5 新增的循环方法\n\nforEach 不会改变原数组，也会返回任何值\n\nforEach，让数组每个元素经过函数处理(做一件事情)\nvar arr = [1,2,3,4,5]\nconst a = ''\n\narr.forEach(item => {\n\n})\n\n```\n\n```\n\n## map\n\nmap 是 es5 新增的循环方法\nmap 不会改变原数组，会返回一个新的数组\n\nmap ，让数组每个元素经过函数处理，并返回一个新数组\n\n```\nvar arry = [1,2,3,4,5]\nconst newArry = arry.map(item => {\n    item = item+1\n    return item\n})\nconsole.log(newArry) [2,3,4,5,6]\n```\n\n## filter\n\n筛选出符合条件的元素，组成新数组返回\n\n```\nconst array = [0,1,2,3,4,5];\n// 返回大于2的数据\nconst dayu2 = arr.filter(item => item > 2)\nconsole.log(dayu2) // [3.4.5]\n```\n\n## reduce\n\n让数组中的前后项做某种计算，并累计最终值\n\n```\narr.reduce(callback(accumulator, currentValue[, index[, array]])[, initialValue])\n\n// 判断空指针\nconst safeGet = (data,str)=>{\n    try{\n        contst arr = str.split(',');\n        return arr.reduce((item,i)=>{\n           return item[i] || null\n        },data)\n    }catch(err){\n        return null\n    }\n}\n```\n\n## every\n\n## some\n\n## 总结：\n\nwhile 循环特点：先判断后执行；\ndo-while 循环特点：先执行再判断，即使初始条件不成立，do-while 循环至少执行一次，也就是说 do-while 循环比 while 循环多执行一次。\n","source":"_drafts/循环.md","raw":"---\ntitle: 循环\ncategories:\ntags:\n---\n\n## 所有关于循环的\n\n`for`、`while` 、 `do while`、`switch` 、`for in`、 `for of`、 `forEach`、 `map`、 `reduce`\n\n## for\n\n```\n// 先判断后执行\nfor(var i=0;i<100;i++){\n    console.log(i)\n}\n\n()中的i，相当于全局变量，除非用let\n```\n\n## while\n\n// 先判断后执行\n\n```\nwhile (条件) 语句;\n\n//举例：\nvar i = 0;\nwhile (i < 100) {\n    console.log('i=' + i);\n    i++;\n}\n```\n\n## do while\n\n// 先执行，后判断 至少执行一次\n\n```\ndo {\n    语句\n}while(条件)\n\nlet i = 0\ndo{\n    console.log(i);\n    i++\n}where(i<100)\n```\n\n## switch\n\n```\nswitch (new Date().getDay()) {\n    case 0:\n        day = \"星期天\";\n        break;\n    case 1:\n        day = \"星期一\";\n         break;\n    case 2:\n        day = \"星期二\";\n         break;\n    case 3:\n        day = \"星期三\";\n         break;\n    case 4:\n        day = \"星期四\";\n         break;\n    case 5:\n        day = \"星期五\";\n         break;\n    case 6:\n        day = \"星期六\";\n}\n```\n\n## for in\n\nfor..in 是 es5 新增的循环方法 。\n遍历对象的 key 值，访问对象的可枚举属性。有点类似于 Object.keys()\n\n```\n\n```\n\n## for of\n\nfor..of 是 es6 新增的循环方法。\nes6 引入了新的 iterable(迭代)类型，Array,Map,Set 都属于 iterable 类型。\n具有 iterable 类型的集合可以通过 for..of 循环来遍历\n\n```\n\n```\n\n## forEach\n\nforEach 是 ES5 新增的循环方法\n\nforEach 不会改变原数组，也会返回任何值\n\nforEach，让数组每个元素经过函数处理(做一件事情)\nvar arr = [1,2,3,4,5]\nconst a = ''\n\narr.forEach(item => {\n\n})\n\n```\n\n```\n\n## map\n\nmap 是 es5 新增的循环方法\nmap 不会改变原数组，会返回一个新的数组\n\nmap ，让数组每个元素经过函数处理，并返回一个新数组\n\n```\nvar arry = [1,2,3,4,5]\nconst newArry = arry.map(item => {\n    item = item+1\n    return item\n})\nconsole.log(newArry) [2,3,4,5,6]\n```\n\n## filter\n\n筛选出符合条件的元素，组成新数组返回\n\n```\nconst array = [0,1,2,3,4,5];\n// 返回大于2的数据\nconst dayu2 = arr.filter(item => item > 2)\nconsole.log(dayu2) // [3.4.5]\n```\n\n## reduce\n\n让数组中的前后项做某种计算，并累计最终值\n\n```\narr.reduce(callback(accumulator, currentValue[, index[, array]])[, initialValue])\n\n// 判断空指针\nconst safeGet = (data,str)=>{\n    try{\n        contst arr = str.split(',');\n        return arr.reduce((item,i)=>{\n           return item[i] || null\n        },data)\n    }catch(err){\n        return null\n    }\n}\n```\n\n## every\n\n## some\n\n## 总结：\n\nwhile 循环特点：先判断后执行；\ndo-while 循环特点：先执行再判断，即使初始条件不成立，do-while 循环至少执行一次，也就是说 do-while 循环比 while 循环多执行一次。\n","slug":"循环","published":0,"date":"2020-05-22T06:30:30.010Z","updated":"2020-06-05T07:26:06.606Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckb1z4dfy001j9n94plrhvq8h","content":"<h2 id=\"所有关于循环的\"><a href=\"#所有关于循环的\" class=\"headerlink\" title=\"所有关于循环的\"></a>所有关于循环的</h2><p><code>for</code>、<code>while</code> 、 <code>do while</code>、<code>switch</code> 、<code>for in</code>、 <code>for of</code>、 <code>forEach</code>、 <code>map</code>、 <code>reduce</code></p>\n<h2 id=\"for\"><a href=\"#for\" class=\"headerlink\" title=\"for\"></a>for</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 先判断后执行</span><br><span class=\"line\">for(var i=0;i&lt;100;i++)&#123;</span><br><span class=\"line\">    console.log(i)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">()中的i，相当于全局变量，除非用let</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"while\"><a href=\"#while\" class=\"headerlink\" title=\"while\"></a>while</h2><p>// 先判断后执行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">while (条件) 语句;</span><br><span class=\"line\"></span><br><span class=\"line\">//举例：</span><br><span class=\"line\">var i = 0;</span><br><span class=\"line\">while (i &lt; 100) &#123;</span><br><span class=\"line\">    console.log(&apos;i=&apos; + i);</span><br><span class=\"line\">    i++;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"do-while\"><a href=\"#do-while\" class=\"headerlink\" title=\"do while\"></a>do while</h2><p>// 先执行，后判断 至少执行一次</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">do &#123;</span><br><span class=\"line\">    语句</span><br><span class=\"line\">&#125;while(条件)</span><br><span class=\"line\"></span><br><span class=\"line\">let i = 0</span><br><span class=\"line\">do&#123;</span><br><span class=\"line\">    console.log(i);</span><br><span class=\"line\">    i++</span><br><span class=\"line\">&#125;where(i&lt;100)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"switch\"><a href=\"#switch\" class=\"headerlink\" title=\"switch\"></a>switch</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">switch (new Date().getDay()) &#123;</span><br><span class=\"line\">    case 0:</span><br><span class=\"line\">        day = &quot;星期天&quot;;</span><br><span class=\"line\">        break;</span><br><span class=\"line\">    case 1:</span><br><span class=\"line\">        day = &quot;星期一&quot;;</span><br><span class=\"line\">         break;</span><br><span class=\"line\">    case 2:</span><br><span class=\"line\">        day = &quot;星期二&quot;;</span><br><span class=\"line\">         break;</span><br><span class=\"line\">    case 3:</span><br><span class=\"line\">        day = &quot;星期三&quot;;</span><br><span class=\"line\">         break;</span><br><span class=\"line\">    case 4:</span><br><span class=\"line\">        day = &quot;星期四&quot;;</span><br><span class=\"line\">         break;</span><br><span class=\"line\">    case 5:</span><br><span class=\"line\">        day = &quot;星期五&quot;;</span><br><span class=\"line\">         break;</span><br><span class=\"line\">    case 6:</span><br><span class=\"line\">        day = &quot;星期六&quot;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"for-in\"><a href=\"#for-in\" class=\"headerlink\" title=\"for in\"></a>for in</h2><p>for..in 是 es5 新增的循环方法 。<br>遍历对象的 key 值，访问对象的可枚举属性。有点类似于 Object.keys()</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"for-of\"><a href=\"#for-of\" class=\"headerlink\" title=\"for of\"></a>for of</h2><p>for..of 是 es6 新增的循环方法。<br>es6 引入了新的 iterable(迭代)类型，Array,Map,Set 都属于 iterable 类型。<br>具有 iterable 类型的集合可以通过 for..of 循环来遍历</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"forEach\"><a href=\"#forEach\" class=\"headerlink\" title=\"forEach\"></a>forEach</h2><p>forEach 是 ES5 新增的循环方法</p>\n<p>forEach 不会改变原数组，也会返回任何值</p>\n<p>forEach，让数组每个元素经过函数处理(做一件事情)<br>var arr = [1,2,3,4,5]<br>const a = ‘’</p>\n<p>arr.forEach(item =&gt; {</p>\n<p>})</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"map\"><a href=\"#map\" class=\"headerlink\" title=\"map\"></a>map</h2><p>map 是 es5 新增的循环方法<br>map 不会改变原数组，会返回一个新的数组</p>\n<p>map ，让数组每个元素经过函数处理，并返回一个新数组</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var arry = [1,2,3,4,5]</span><br><span class=\"line\">const newArry = arry.map(item =&gt; &#123;</span><br><span class=\"line\">    item = item+1</span><br><span class=\"line\">    return item</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">console.log(newArry) [2,3,4,5,6]</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"filter\"><a href=\"#filter\" class=\"headerlink\" title=\"filter\"></a>filter</h2><p>筛选出符合条件的元素，组成新数组返回</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const array = [0,1,2,3,4,5];</span><br><span class=\"line\">// 返回大于2的数据</span><br><span class=\"line\">const dayu2 = arr.filter(item =&gt; item &gt; 2)</span><br><span class=\"line\">console.log(dayu2) // [3.4.5]</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"reduce\"><a href=\"#reduce\" class=\"headerlink\" title=\"reduce\"></a>reduce</h2><p>让数组中的前后项做某种计算，并累计最终值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">arr.reduce(callback(accumulator, currentValue[, index[, array]])[, initialValue])</span><br><span class=\"line\"></span><br><span class=\"line\">// 判断空指针</span><br><span class=\"line\">const safeGet = (data,str)=&gt;&#123;</span><br><span class=\"line\">    try&#123;</span><br><span class=\"line\">        contst arr = str.split(&apos;,&apos;);</span><br><span class=\"line\">        return arr.reduce((item,i)=&gt;&#123;</span><br><span class=\"line\">           return item[i] || null</span><br><span class=\"line\">        &#125;,data)</span><br><span class=\"line\">    &#125;catch(err)&#123;</span><br><span class=\"line\">        return null</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"every\"><a href=\"#every\" class=\"headerlink\" title=\"every\"></a>every</h2><h2 id=\"some\"><a href=\"#some\" class=\"headerlink\" title=\"some\"></a>some</h2><h2 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h2><p>while 循环特点：先判断后执行；<br>do-while 循环特点：先执行再判断，即使初始条件不成立，do-while 循环至少执行一次，也就是说 do-while 循环比 while 循环多执行一次。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"所有关于循环的\"><a href=\"#所有关于循环的\" class=\"headerlink\" title=\"所有关于循环的\"></a>所有关于循环的</h2><p><code>for</code>、<code>while</code> 、 <code>do while</code>、<code>switch</code> 、<code>for in</code>、 <code>for of</code>、 <code>forEach</code>、 <code>map</code>、 <code>reduce</code></p>\n<h2 id=\"for\"><a href=\"#for\" class=\"headerlink\" title=\"for\"></a>for</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 先判断后执行</span><br><span class=\"line\">for(var i=0;i&lt;100;i++)&#123;</span><br><span class=\"line\">    console.log(i)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">()中的i，相当于全局变量，除非用let</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"while\"><a href=\"#while\" class=\"headerlink\" title=\"while\"></a>while</h2><p>// 先判断后执行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">while (条件) 语句;</span><br><span class=\"line\"></span><br><span class=\"line\">//举例：</span><br><span class=\"line\">var i = 0;</span><br><span class=\"line\">while (i &lt; 100) &#123;</span><br><span class=\"line\">    console.log(&apos;i=&apos; + i);</span><br><span class=\"line\">    i++;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"do-while\"><a href=\"#do-while\" class=\"headerlink\" title=\"do while\"></a>do while</h2><p>// 先执行，后判断 至少执行一次</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">do &#123;</span><br><span class=\"line\">    语句</span><br><span class=\"line\">&#125;while(条件)</span><br><span class=\"line\"></span><br><span class=\"line\">let i = 0</span><br><span class=\"line\">do&#123;</span><br><span class=\"line\">    console.log(i);</span><br><span class=\"line\">    i++</span><br><span class=\"line\">&#125;where(i&lt;100)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"switch\"><a href=\"#switch\" class=\"headerlink\" title=\"switch\"></a>switch</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">switch (new Date().getDay()) &#123;</span><br><span class=\"line\">    case 0:</span><br><span class=\"line\">        day = &quot;星期天&quot;;</span><br><span class=\"line\">        break;</span><br><span class=\"line\">    case 1:</span><br><span class=\"line\">        day = &quot;星期一&quot;;</span><br><span class=\"line\">         break;</span><br><span class=\"line\">    case 2:</span><br><span class=\"line\">        day = &quot;星期二&quot;;</span><br><span class=\"line\">         break;</span><br><span class=\"line\">    case 3:</span><br><span class=\"line\">        day = &quot;星期三&quot;;</span><br><span class=\"line\">         break;</span><br><span class=\"line\">    case 4:</span><br><span class=\"line\">        day = &quot;星期四&quot;;</span><br><span class=\"line\">         break;</span><br><span class=\"line\">    case 5:</span><br><span class=\"line\">        day = &quot;星期五&quot;;</span><br><span class=\"line\">         break;</span><br><span class=\"line\">    case 6:</span><br><span class=\"line\">        day = &quot;星期六&quot;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"for-in\"><a href=\"#for-in\" class=\"headerlink\" title=\"for in\"></a>for in</h2><p>for..in 是 es5 新增的循环方法 。<br>遍历对象的 key 值，访问对象的可枚举属性。有点类似于 Object.keys()</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"for-of\"><a href=\"#for-of\" class=\"headerlink\" title=\"for of\"></a>for of</h2><p>for..of 是 es6 新增的循环方法。<br>es6 引入了新的 iterable(迭代)类型，Array,Map,Set 都属于 iterable 类型。<br>具有 iterable 类型的集合可以通过 for..of 循环来遍历</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"forEach\"><a href=\"#forEach\" class=\"headerlink\" title=\"forEach\"></a>forEach</h2><p>forEach 是 ES5 新增的循环方法</p>\n<p>forEach 不会改变原数组，也会返回任何值</p>\n<p>forEach，让数组每个元素经过函数处理(做一件事情)<br>var arr = [1,2,3,4,5]<br>const a = ‘’</p>\n<p>arr.forEach(item =&gt; {</p>\n<p>})</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"map\"><a href=\"#map\" class=\"headerlink\" title=\"map\"></a>map</h2><p>map 是 es5 新增的循环方法<br>map 不会改变原数组，会返回一个新的数组</p>\n<p>map ，让数组每个元素经过函数处理，并返回一个新数组</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var arry = [1,2,3,4,5]</span><br><span class=\"line\">const newArry = arry.map(item =&gt; &#123;</span><br><span class=\"line\">    item = item+1</span><br><span class=\"line\">    return item</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">console.log(newArry) [2,3,4,5,6]</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"filter\"><a href=\"#filter\" class=\"headerlink\" title=\"filter\"></a>filter</h2><p>筛选出符合条件的元素，组成新数组返回</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const array = [0,1,2,3,4,5];</span><br><span class=\"line\">// 返回大于2的数据</span><br><span class=\"line\">const dayu2 = arr.filter(item =&gt; item &gt; 2)</span><br><span class=\"line\">console.log(dayu2) // [3.4.5]</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"reduce\"><a href=\"#reduce\" class=\"headerlink\" title=\"reduce\"></a>reduce</h2><p>让数组中的前后项做某种计算，并累计最终值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">arr.reduce(callback(accumulator, currentValue[, index[, array]])[, initialValue])</span><br><span class=\"line\"></span><br><span class=\"line\">// 判断空指针</span><br><span class=\"line\">const safeGet = (data,str)=&gt;&#123;</span><br><span class=\"line\">    try&#123;</span><br><span class=\"line\">        contst arr = str.split(&apos;,&apos;);</span><br><span class=\"line\">        return arr.reduce((item,i)=&gt;&#123;</span><br><span class=\"line\">           return item[i] || null</span><br><span class=\"line\">        &#125;,data)</span><br><span class=\"line\">    &#125;catch(err)&#123;</span><br><span class=\"line\">        return null</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"every\"><a href=\"#every\" class=\"headerlink\" title=\"every\"></a>every</h2><h2 id=\"some\"><a href=\"#some\" class=\"headerlink\" title=\"some\"></a>some</h2><h2 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h2><p>while 循环特点：先判断后执行；<br>do-while 循环特点：先执行再判断，即使初始条件不成立，do-while 循环至少执行一次，也就是说 do-while 循环比 while 循环多执行一次。</p>\n"},{"title":"浏览器渲染原理","_content":"\n## 浏览器渲染页面的过程\n\n从耗时的角度，浏览器请求、加载、渲染一个页面，时间花在下面五件事情上：\n\n1. DNS 查询\n2. TCP 连接\n3. HTTP 请求即响应\n4. 服务器响应\n5. 客户端渲染\n\n## 客户端渲染\n\n浏览器对内容的渲染，这一部分（渲染树构建、布局及绘制），又可以分为下面五个步骤：\n\n1. 处理 HTML 标记并构建 DOM 树。\n2. 处理 CSS 标记并构建 CSSOM 树。\n3. 将 DOM 与 CSSOM 合并成一个渲染树。\n4. 根据渲染树来布局，以计算每个节点的几何信息。\n5. 将各个节点绘制到屏幕上。\n\n需要明白，这五个步骤并不一定一次性顺序完成。如果 DOM 或 CSSOM 被修改，以上过程需要重复执行，这样才能计算出哪些像素需要在屏幕上进行重新渲染。实际页面中，CSS 与 JavaScript 往往会多次修改 DOM 和 CSSOM，下面就来看看它们的影响方式。\n","source":"_drafts/浏览器渲染过程.md","raw":"---\ntitle: 浏览器渲染原理\ncategories:\ntags:\n---\n\n## 浏览器渲染页面的过程\n\n从耗时的角度，浏览器请求、加载、渲染一个页面，时间花在下面五件事情上：\n\n1. DNS 查询\n2. TCP 连接\n3. HTTP 请求即响应\n4. 服务器响应\n5. 客户端渲染\n\n## 客户端渲染\n\n浏览器对内容的渲染，这一部分（渲染树构建、布局及绘制），又可以分为下面五个步骤：\n\n1. 处理 HTML 标记并构建 DOM 树。\n2. 处理 CSS 标记并构建 CSSOM 树。\n3. 将 DOM 与 CSSOM 合并成一个渲染树。\n4. 根据渲染树来布局，以计算每个节点的几何信息。\n5. 将各个节点绘制到屏幕上。\n\n需要明白，这五个步骤并不一定一次性顺序完成。如果 DOM 或 CSSOM 被修改，以上过程需要重复执行，这样才能计算出哪些像素需要在屏幕上进行重新渲染。实际页面中，CSS 与 JavaScript 往往会多次修改 DOM 和 CSSOM，下面就来看看它们的影响方式。\n","slug":"浏览器渲染过程","published":0,"date":"2019-11-09T07:39:11.674Z","updated":"2020-06-05T07:34:59.903Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckb1z4dfz001m9n94902a608p","content":"<h2 id=\"浏览器渲染页面的过程\"><a href=\"#浏览器渲染页面的过程\" class=\"headerlink\" title=\"浏览器渲染页面的过程\"></a>浏览器渲染页面的过程</h2><p>从耗时的角度，浏览器请求、加载、渲染一个页面，时间花在下面五件事情上：</p>\n<ol>\n<li>DNS 查询</li>\n<li>TCP 连接</li>\n<li>HTTP 请求即响应</li>\n<li>服务器响应</li>\n<li>客户端渲染</li>\n</ol>\n<h2 id=\"客户端渲染\"><a href=\"#客户端渲染\" class=\"headerlink\" title=\"客户端渲染\"></a>客户端渲染</h2><p>浏览器对内容的渲染，这一部分（渲染树构建、布局及绘制），又可以分为下面五个步骤：</p>\n<ol>\n<li>处理 HTML 标记并构建 DOM 树。</li>\n<li>处理 CSS 标记并构建 CSSOM 树。</li>\n<li>将 DOM 与 CSSOM 合并成一个渲染树。</li>\n<li>根据渲染树来布局，以计算每个节点的几何信息。</li>\n<li>将各个节点绘制到屏幕上。</li>\n</ol>\n<p>需要明白，这五个步骤并不一定一次性顺序完成。如果 DOM 或 CSSOM 被修改，以上过程需要重复执行，这样才能计算出哪些像素需要在屏幕上进行重新渲染。实际页面中，CSS 与 JavaScript 往往会多次修改 DOM 和 CSSOM，下面就来看看它们的影响方式。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"浏览器渲染页面的过程\"><a href=\"#浏览器渲染页面的过程\" class=\"headerlink\" title=\"浏览器渲染页面的过程\"></a>浏览器渲染页面的过程</h2><p>从耗时的角度，浏览器请求、加载、渲染一个页面，时间花在下面五件事情上：</p>\n<ol>\n<li>DNS 查询</li>\n<li>TCP 连接</li>\n<li>HTTP 请求即响应</li>\n<li>服务器响应</li>\n<li>客户端渲染</li>\n</ol>\n<h2 id=\"客户端渲染\"><a href=\"#客户端渲染\" class=\"headerlink\" title=\"客户端渲染\"></a>客户端渲染</h2><p>浏览器对内容的渲染，这一部分（渲染树构建、布局及绘制），又可以分为下面五个步骤：</p>\n<ol>\n<li>处理 HTML 标记并构建 DOM 树。</li>\n<li>处理 CSS 标记并构建 CSSOM 树。</li>\n<li>将 DOM 与 CSSOM 合并成一个渲染树。</li>\n<li>根据渲染树来布局，以计算每个节点的几何信息。</li>\n<li>将各个节点绘制到屏幕上。</li>\n</ol>\n<p>需要明白，这五个步骤并不一定一次性顺序完成。如果 DOM 或 CSSOM 被修改，以上过程需要重复执行，这样才能计算出哪些像素需要在屏幕上进行重新渲染。实际页面中，CSS 与 JavaScript 往往会多次修改 DOM 和 CSSOM，下面就来看看它们的影响方式。</p>\n"},{"title":"数组","_content":"\n[https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array)\n\n### reduce\n\n> arr.reduce(callback(accumulator, currentValue[, index[, array]])[, initialValue])\n\ncallback 函数接收 4 个参数\n\n1. Accumulator (acc) (累计器)\n2. Current Value (cur) (当前值)\n3. Current Index (idx) (当前索引)\n4. Source Array (src) (源数组)\n\nreduce 应用：\n\n#### 判断空指针\n\n```\nfunction safeGet(data,str){\n  try{\n    const arr = str.split(\".\")\n    return  arr.reduce((item,i)=>{ return item[i]},data)\n  }catch(err){\n    return null\n  }\n}\n```\n\n#### 实现 A instance of B\n\n```\nfunction instanceOf(A,B){\n  let aPrototy = A.__proto__\n  let bCons = B.prototype\n  while(true){\n    if(aPrototy === null){\n      return false\n    }\n    if(aPrototy === bCons){\n      return true\n    }\n    aPrototy = aPrototy.__proto__\n  }\n}\n```\n","source":"_drafts/数组.md","raw":"---\ntitle: 数组\ncategories:\ntags:\n---\n\n[https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array)\n\n### reduce\n\n> arr.reduce(callback(accumulator, currentValue[, index[, array]])[, initialValue])\n\ncallback 函数接收 4 个参数\n\n1. Accumulator (acc) (累计器)\n2. Current Value (cur) (当前值)\n3. Current Index (idx) (当前索引)\n4. Source Array (src) (源数组)\n\nreduce 应用：\n\n#### 判断空指针\n\n```\nfunction safeGet(data,str){\n  try{\n    const arr = str.split(\".\")\n    return  arr.reduce((item,i)=>{ return item[i]},data)\n  }catch(err){\n    return null\n  }\n}\n```\n\n#### 实现 A instance of B\n\n```\nfunction instanceOf(A,B){\n  let aPrototy = A.__proto__\n  let bCons = B.prototype\n  while(true){\n    if(aPrototy === null){\n      return false\n    }\n    if(aPrototy === bCons){\n      return true\n    }\n    aPrototy = aPrototy.__proto__\n  }\n}\n```\n","slug":"数组","published":0,"date":"2019-09-03T06:49:03.221Z","updated":"2020-05-21T07:10:22.760Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckb1z4dg0001p9n946bwadb01","content":"<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array\" target=\"_blank\" rel=\"noopener\">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array</a></p>\n<h3 id=\"reduce\"><a href=\"#reduce\" class=\"headerlink\" title=\"reduce\"></a>reduce</h3><blockquote>\n<p>arr.reduce(callback(accumulator, currentValue[, index[, array]])[, initialValue])</p>\n</blockquote>\n<p>callback 函数接收 4 个参数</p>\n<ol>\n<li>Accumulator (acc) (累计器)</li>\n<li>Current Value (cur) (当前值)</li>\n<li>Current Index (idx) (当前索引)</li>\n<li>Source Array (src) (源数组)</li>\n</ol>\n<p>reduce 应用：</p>\n<h4 id=\"判断空指针\"><a href=\"#判断空指针\" class=\"headerlink\" title=\"判断空指针\"></a>判断空指针</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function safeGet(data,str)&#123;</span><br><span class=\"line\">  try&#123;</span><br><span class=\"line\">    const arr = str.split(&quot;.&quot;)</span><br><span class=\"line\">    return  arr.reduce((item,i)=&gt;&#123; return item[i]&#125;,data)</span><br><span class=\"line\">  &#125;catch(err)&#123;</span><br><span class=\"line\">    return null</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"实现-A-instance-of-B\"><a href=\"#实现-A-instance-of-B\" class=\"headerlink\" title=\"实现 A instance of B\"></a>实现 A instance of B</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function instanceOf(A,B)&#123;</span><br><span class=\"line\">  let aPrototy = A.__proto__</span><br><span class=\"line\">  let bCons = B.prototype</span><br><span class=\"line\">  while(true)&#123;</span><br><span class=\"line\">    if(aPrototy === null)&#123;</span><br><span class=\"line\">      return false</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if(aPrototy === bCons)&#123;</span><br><span class=\"line\">      return true</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    aPrototy = aPrototy.__proto__</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array\" target=\"_blank\" rel=\"noopener\">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array</a></p>\n<h3 id=\"reduce\"><a href=\"#reduce\" class=\"headerlink\" title=\"reduce\"></a>reduce</h3><blockquote>\n<p>arr.reduce(callback(accumulator, currentValue[, index[, array]])[, initialValue])</p>\n</blockquote>\n<p>callback 函数接收 4 个参数</p>\n<ol>\n<li>Accumulator (acc) (累计器)</li>\n<li>Current Value (cur) (当前值)</li>\n<li>Current Index (idx) (当前索引)</li>\n<li>Source Array (src) (源数组)</li>\n</ol>\n<p>reduce 应用：</p>\n<h4 id=\"判断空指针\"><a href=\"#判断空指针\" class=\"headerlink\" title=\"判断空指针\"></a>判断空指针</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function safeGet(data,str)&#123;</span><br><span class=\"line\">  try&#123;</span><br><span class=\"line\">    const arr = str.split(&quot;.&quot;)</span><br><span class=\"line\">    return  arr.reduce((item,i)=&gt;&#123; return item[i]&#125;,data)</span><br><span class=\"line\">  &#125;catch(err)&#123;</span><br><span class=\"line\">    return null</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"实现-A-instance-of-B\"><a href=\"#实现-A-instance-of-B\" class=\"headerlink\" title=\"实现 A instance of B\"></a>实现 A instance of B</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function instanceOf(A,B)&#123;</span><br><span class=\"line\">  let aPrototy = A.__proto__</span><br><span class=\"line\">  let bCons = B.prototype</span><br><span class=\"line\">  while(true)&#123;</span><br><span class=\"line\">    if(aPrototy === null)&#123;</span><br><span class=\"line\">      return false</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if(aPrototy === bCons)&#123;</span><br><span class=\"line\">      return true</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    aPrototy = aPrototy.__proto__</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n"},{"title":"数据结构","_content":"\n## Stack 栈\n\n**Stack 的特点是先进后出 或者说后进先出（last in first out）。**\n\nStack 一般具备以下方法：\n\n1. push：将一个元素推入栈顶\n2. pop：移除栈顶元素，并返回被移除的元素\n3. peek：返回栈顶元素\n4. length：返回栈中元素的个数\n\n## Queue（队列）\n\n**Queue 的特点是先进先出**\n\nQueue 一般具有以下常见方法：\n\n1. enqueue：入列，向队列尾部增加一个元素\n2. dequeue：出列，移除队列头部的一个元素并返回被移除的元素\n3. front：获取队列的第一个元素\n4. isEmpty：判断队列是否为空\n5. size：获取队列中元素的个数\n\n## Linked List（链表）\n\n![](/images/linkedList.png)\n\n**顾名思义，链表是一种链式数据结构，链上的每个节点包含两种信息：节点本身的数据和指向下一个节点的指针。链表和传统的数组都是线性的数据结构，存储的都是一个序列的数据，但也有很多区别，如下表：**\n\n```\n比较维度\t    数组\t                        链表\n内存分配      静态内存分配，编译时分配且连续    动态内存分配，运行时分配且不连续\n元素获取      通过Index获取，速度较快         通过遍历顺序访问，速度较慢\n添加删除元素   因为内存位置连续且固定，速度较慢  因为内存分配灵活，只有一个开销步骤，速度更快\n空间结构      可以是一维或者多维数组           可以是单向、双向或者循环链表\n```\n\n一个单向链表通常具有以下方法：\n\n1. size：返回链表中节点的个数\n2. head：返回链表中的头部元素\n3. add：向链表尾部增加一个节点\n4. remove：删除某个节点\n5. indexOf：返回某个节点的 index\n6. elementAt：返回某个 index 处的节点\n7. addAt：在某个 index 处插入一个节点\n8. removeAt：删除某个 index 处的节点\n\n## Set（集合）\n\n![](/images/set.png)\n\n**集合是数学中的一个基本概念，表示具有某种特性的对象汇总成的集体。在 ES6 中也引入了集合类型 Set，Set 和 Array 有一定程度的相似，不同的是 Set 中不允许出现重复的元素而且是无序的。**\n\n一个典型的 Set 应该具有以下方法：\n\n1. values：返回集合中的所有元素\n2. size：返回集合中元素的个数\n3. has：判断集合中是否存在某个元素\n4. add：向集合中添加元素\n5. remove：从集合中移除某个元素\n6. union：返回两个集合的并集\n7. intersection：返回两个集合的交集\n8. difference：返回两个集合的差集\n9. subset：判断一个集合是否为另一个集合的子集\n\n## Hash Table（哈希表/散列表）\n\n**Hash Table 是一种用于存储键值对（key value pair）的数据结构，因为 Hash Table 根据 key 查询 value 的速度很快，所以它常用于实现 Map、Dictinary、Object 等数据结构。如上图所示，Hash Table 内部使用一个 hash 函数将传入的键转换成一串数字，而这串数字将作为键值对实际的 key，通过这个 key 查询对应的 value 非常快，时间复杂度将达到 O(1)。Hash 函数要求相同输入对应的输出必须相等，而不同输入对应的输出必须不等，相当于对每对数据打上唯一的指纹。**\n\n一个 Hash Table 通常具有下列方法：\n\n1. add：增加一组键值对\n2. remove：删除一组键值对\n3. lookup：查找一个键对应的值\n\n## tree\n\n**顾名思义，Tree 的数据结构和自然界中的树极其相似，有根、树枝、叶子，如上图所示。Tree 是一种多层数据结构，与 Array、Stack、Queue 相比是一种非线性的数据结构，在进行插入和搜索操作时很高效。**\n在描述一个 Tree 时经常会用到下列概念：\n\n1. Root（根）：代表树的根节点，根节点没有父节点\n2. Parent Node（父节点）：一个节点的直接上级节点，只有一个\n3. Child Node（子节点）：一个节点的直接下级节点，可能有多个\n4. Siblings（兄弟节点）：具有相同父节点的节点\n5. Leaf（叶节点）：没有子节点的节点\n6. Edge（边）：两个节点之间的连接线\n7. Path（路径）：从源节点到目标节点的连续边\n8. Height of Node（节点的高度）：表示节点与叶节点之间的最长路径上边的个数\n9. Height of Tree（树的高度）：即根节点的高度\n10. Depth of Node（节点的深度）：表示从根节点到该节点的边的个数\n11. Degree of Node（节点的度）：表示子节点的个数\n\n一个二叉查找树应该具有以下常用方法：\n\n1. add：向树中插入一个节点\n2. findMin：查找树中最小的节点\n3. findMax：查找树中最大的节点\n4. find：查找树中的某个节点\n5. isPresent：判断某个节点在树中是否存在\n6. remove：移除树中的某个节点\n\n相关阅读：\n[数据结构](https://mp.weixin.qq.com/s/mMDlxNhm8pc8lccH_8Baxw)\n","source":"_drafts/数据结构.md","raw":"---\ntitle: 数据结构\ncategories:\ntags:\n  - javascript\n---\n\n## Stack 栈\n\n**Stack 的特点是先进后出 或者说后进先出（last in first out）。**\n\nStack 一般具备以下方法：\n\n1. push：将一个元素推入栈顶\n2. pop：移除栈顶元素，并返回被移除的元素\n3. peek：返回栈顶元素\n4. length：返回栈中元素的个数\n\n## Queue（队列）\n\n**Queue 的特点是先进先出**\n\nQueue 一般具有以下常见方法：\n\n1. enqueue：入列，向队列尾部增加一个元素\n2. dequeue：出列，移除队列头部的一个元素并返回被移除的元素\n3. front：获取队列的第一个元素\n4. isEmpty：判断队列是否为空\n5. size：获取队列中元素的个数\n\n## Linked List（链表）\n\n![](/images/linkedList.png)\n\n**顾名思义，链表是一种链式数据结构，链上的每个节点包含两种信息：节点本身的数据和指向下一个节点的指针。链表和传统的数组都是线性的数据结构，存储的都是一个序列的数据，但也有很多区别，如下表：**\n\n```\n比较维度\t    数组\t                        链表\n内存分配      静态内存分配，编译时分配且连续    动态内存分配，运行时分配且不连续\n元素获取      通过Index获取，速度较快         通过遍历顺序访问，速度较慢\n添加删除元素   因为内存位置连续且固定，速度较慢  因为内存分配灵活，只有一个开销步骤，速度更快\n空间结构      可以是一维或者多维数组           可以是单向、双向或者循环链表\n```\n\n一个单向链表通常具有以下方法：\n\n1. size：返回链表中节点的个数\n2. head：返回链表中的头部元素\n3. add：向链表尾部增加一个节点\n4. remove：删除某个节点\n5. indexOf：返回某个节点的 index\n6. elementAt：返回某个 index 处的节点\n7. addAt：在某个 index 处插入一个节点\n8. removeAt：删除某个 index 处的节点\n\n## Set（集合）\n\n![](/images/set.png)\n\n**集合是数学中的一个基本概念，表示具有某种特性的对象汇总成的集体。在 ES6 中也引入了集合类型 Set，Set 和 Array 有一定程度的相似，不同的是 Set 中不允许出现重复的元素而且是无序的。**\n\n一个典型的 Set 应该具有以下方法：\n\n1. values：返回集合中的所有元素\n2. size：返回集合中元素的个数\n3. has：判断集合中是否存在某个元素\n4. add：向集合中添加元素\n5. remove：从集合中移除某个元素\n6. union：返回两个集合的并集\n7. intersection：返回两个集合的交集\n8. difference：返回两个集合的差集\n9. subset：判断一个集合是否为另一个集合的子集\n\n## Hash Table（哈希表/散列表）\n\n**Hash Table 是一种用于存储键值对（key value pair）的数据结构，因为 Hash Table 根据 key 查询 value 的速度很快，所以它常用于实现 Map、Dictinary、Object 等数据结构。如上图所示，Hash Table 内部使用一个 hash 函数将传入的键转换成一串数字，而这串数字将作为键值对实际的 key，通过这个 key 查询对应的 value 非常快，时间复杂度将达到 O(1)。Hash 函数要求相同输入对应的输出必须相等，而不同输入对应的输出必须不等，相当于对每对数据打上唯一的指纹。**\n\n一个 Hash Table 通常具有下列方法：\n\n1. add：增加一组键值对\n2. remove：删除一组键值对\n3. lookup：查找一个键对应的值\n\n## tree\n\n**顾名思义，Tree 的数据结构和自然界中的树极其相似，有根、树枝、叶子，如上图所示。Tree 是一种多层数据结构，与 Array、Stack、Queue 相比是一种非线性的数据结构，在进行插入和搜索操作时很高效。**\n在描述一个 Tree 时经常会用到下列概念：\n\n1. Root（根）：代表树的根节点，根节点没有父节点\n2. Parent Node（父节点）：一个节点的直接上级节点，只有一个\n3. Child Node（子节点）：一个节点的直接下级节点，可能有多个\n4. Siblings（兄弟节点）：具有相同父节点的节点\n5. Leaf（叶节点）：没有子节点的节点\n6. Edge（边）：两个节点之间的连接线\n7. Path（路径）：从源节点到目标节点的连续边\n8. Height of Node（节点的高度）：表示节点与叶节点之间的最长路径上边的个数\n9. Height of Tree（树的高度）：即根节点的高度\n10. Depth of Node（节点的深度）：表示从根节点到该节点的边的个数\n11. Degree of Node（节点的度）：表示子节点的个数\n\n一个二叉查找树应该具有以下常用方法：\n\n1. add：向树中插入一个节点\n2. findMin：查找树中最小的节点\n3. findMax：查找树中最大的节点\n4. find：查找树中的某个节点\n5. isPresent：判断某个节点在树中是否存在\n6. remove：移除树中的某个节点\n\n相关阅读：\n[数据结构](https://mp.weixin.qq.com/s/mMDlxNhm8pc8lccH_8Baxw)\n","slug":"数据结构","published":0,"date":"2019-10-09T07:09:40.819Z","updated":"2020-05-21T07:10:16.376Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckb1z4dg1001r9n94b68il3om","content":"<h2 id=\"Stack-栈\"><a href=\"#Stack-栈\" class=\"headerlink\" title=\"Stack 栈\"></a>Stack 栈</h2><p><strong>Stack 的特点是先进后出 或者说后进先出（last in first out）。</strong></p>\n<p>Stack 一般具备以下方法：</p>\n<ol>\n<li>push：将一个元素推入栈顶</li>\n<li>pop：移除栈顶元素，并返回被移除的元素</li>\n<li>peek：返回栈顶元素</li>\n<li>length：返回栈中元素的个数</li>\n</ol>\n<h2 id=\"Queue（队列）\"><a href=\"#Queue（队列）\" class=\"headerlink\" title=\"Queue（队列）\"></a>Queue（队列）</h2><p><strong>Queue 的特点是先进先出</strong></p>\n<p>Queue 一般具有以下常见方法：</p>\n<ol>\n<li>enqueue：入列，向队列尾部增加一个元素</li>\n<li>dequeue：出列，移除队列头部的一个元素并返回被移除的元素</li>\n<li>front：获取队列的第一个元素</li>\n<li>isEmpty：判断队列是否为空</li>\n<li>size：获取队列中元素的个数</li>\n</ol>\n<h2 id=\"Linked-List（链表）\"><a href=\"#Linked-List（链表）\" class=\"headerlink\" title=\"Linked List（链表）\"></a>Linked List（链表）</h2><p><img src=\"/images/linkedList.png\" alt></p>\n<p><strong>顾名思义，链表是一种链式数据结构，链上的每个节点包含两种信息：节点本身的数据和指向下一个节点的指针。链表和传统的数组都是线性的数据结构，存储的都是一个序列的数据，但也有很多区别，如下表：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">比较维度\t    数组\t                        链表</span><br><span class=\"line\">内存分配      静态内存分配，编译时分配且连续    动态内存分配，运行时分配且不连续</span><br><span class=\"line\">元素获取      通过Index获取，速度较快         通过遍历顺序访问，速度较慢</span><br><span class=\"line\">添加删除元素   因为内存位置连续且固定，速度较慢  因为内存分配灵活，只有一个开销步骤，速度更快</span><br><span class=\"line\">空间结构      可以是一维或者多维数组           可以是单向、双向或者循环链表</span><br></pre></td></tr></table></figure>\n\n<p>一个单向链表通常具有以下方法：</p>\n<ol>\n<li>size：返回链表中节点的个数</li>\n<li>head：返回链表中的头部元素</li>\n<li>add：向链表尾部增加一个节点</li>\n<li>remove：删除某个节点</li>\n<li>indexOf：返回某个节点的 index</li>\n<li>elementAt：返回某个 index 处的节点</li>\n<li>addAt：在某个 index 处插入一个节点</li>\n<li>removeAt：删除某个 index 处的节点</li>\n</ol>\n<h2 id=\"Set（集合）\"><a href=\"#Set（集合）\" class=\"headerlink\" title=\"Set（集合）\"></a>Set（集合）</h2><p><img src=\"/images/set.png\" alt></p>\n<p><strong>集合是数学中的一个基本概念，表示具有某种特性的对象汇总成的集体。在 ES6 中也引入了集合类型 Set，Set 和 Array 有一定程度的相似，不同的是 Set 中不允许出现重复的元素而且是无序的。</strong></p>\n<p>一个典型的 Set 应该具有以下方法：</p>\n<ol>\n<li>values：返回集合中的所有元素</li>\n<li>size：返回集合中元素的个数</li>\n<li>has：判断集合中是否存在某个元素</li>\n<li>add：向集合中添加元素</li>\n<li>remove：从集合中移除某个元素</li>\n<li>union：返回两个集合的并集</li>\n<li>intersection：返回两个集合的交集</li>\n<li>difference：返回两个集合的差集</li>\n<li>subset：判断一个集合是否为另一个集合的子集</li>\n</ol>\n<h2 id=\"Hash-Table（哈希表-散列表）\"><a href=\"#Hash-Table（哈希表-散列表）\" class=\"headerlink\" title=\"Hash Table（哈希表/散列表）\"></a>Hash Table（哈希表/散列表）</h2><p><strong>Hash Table 是一种用于存储键值对（key value pair）的数据结构，因为 Hash Table 根据 key 查询 value 的速度很快，所以它常用于实现 Map、Dictinary、Object 等数据结构。如上图所示，Hash Table 内部使用一个 hash 函数将传入的键转换成一串数字，而这串数字将作为键值对实际的 key，通过这个 key 查询对应的 value 非常快，时间复杂度将达到 O(1)。Hash 函数要求相同输入对应的输出必须相等，而不同输入对应的输出必须不等，相当于对每对数据打上唯一的指纹。</strong></p>\n<p>一个 Hash Table 通常具有下列方法：</p>\n<ol>\n<li>add：增加一组键值对</li>\n<li>remove：删除一组键值对</li>\n<li>lookup：查找一个键对应的值</li>\n</ol>\n<h2 id=\"tree\"><a href=\"#tree\" class=\"headerlink\" title=\"tree\"></a>tree</h2><p><strong>顾名思义，Tree 的数据结构和自然界中的树极其相似，有根、树枝、叶子，如上图所示。Tree 是一种多层数据结构，与 Array、Stack、Queue 相比是一种非线性的数据结构，在进行插入和搜索操作时很高效。</strong><br>在描述一个 Tree 时经常会用到下列概念：</p>\n<ol>\n<li>Root（根）：代表树的根节点，根节点没有父节点</li>\n<li>Parent Node（父节点）：一个节点的直接上级节点，只有一个</li>\n<li>Child Node（子节点）：一个节点的直接下级节点，可能有多个</li>\n<li>Siblings（兄弟节点）：具有相同父节点的节点</li>\n<li>Leaf（叶节点）：没有子节点的节点</li>\n<li>Edge（边）：两个节点之间的连接线</li>\n<li>Path（路径）：从源节点到目标节点的连续边</li>\n<li>Height of Node（节点的高度）：表示节点与叶节点之间的最长路径上边的个数</li>\n<li>Height of Tree（树的高度）：即根节点的高度</li>\n<li>Depth of Node（节点的深度）：表示从根节点到该节点的边的个数</li>\n<li>Degree of Node（节点的度）：表示子节点的个数</li>\n</ol>\n<p>一个二叉查找树应该具有以下常用方法：</p>\n<ol>\n<li>add：向树中插入一个节点</li>\n<li>findMin：查找树中最小的节点</li>\n<li>findMax：查找树中最大的节点</li>\n<li>find：查找树中的某个节点</li>\n<li>isPresent：判断某个节点在树中是否存在</li>\n<li>remove：移除树中的某个节点</li>\n</ol>\n<p>相关阅读：<br><a href=\"https://mp.weixin.qq.com/s/mMDlxNhm8pc8lccH_8Baxw\" target=\"_blank\" rel=\"noopener\">数据结构</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Stack-栈\"><a href=\"#Stack-栈\" class=\"headerlink\" title=\"Stack 栈\"></a>Stack 栈</h2><p><strong>Stack 的特点是先进后出 或者说后进先出（last in first out）。</strong></p>\n<p>Stack 一般具备以下方法：</p>\n<ol>\n<li>push：将一个元素推入栈顶</li>\n<li>pop：移除栈顶元素，并返回被移除的元素</li>\n<li>peek：返回栈顶元素</li>\n<li>length：返回栈中元素的个数</li>\n</ol>\n<h2 id=\"Queue（队列）\"><a href=\"#Queue（队列）\" class=\"headerlink\" title=\"Queue（队列）\"></a>Queue（队列）</h2><p><strong>Queue 的特点是先进先出</strong></p>\n<p>Queue 一般具有以下常见方法：</p>\n<ol>\n<li>enqueue：入列，向队列尾部增加一个元素</li>\n<li>dequeue：出列，移除队列头部的一个元素并返回被移除的元素</li>\n<li>front：获取队列的第一个元素</li>\n<li>isEmpty：判断队列是否为空</li>\n<li>size：获取队列中元素的个数</li>\n</ol>\n<h2 id=\"Linked-List（链表）\"><a href=\"#Linked-List（链表）\" class=\"headerlink\" title=\"Linked List（链表）\"></a>Linked List（链表）</h2><p><img src=\"/images/linkedList.png\" alt></p>\n<p><strong>顾名思义，链表是一种链式数据结构，链上的每个节点包含两种信息：节点本身的数据和指向下一个节点的指针。链表和传统的数组都是线性的数据结构，存储的都是一个序列的数据，但也有很多区别，如下表：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">比较维度\t    数组\t                        链表</span><br><span class=\"line\">内存分配      静态内存分配，编译时分配且连续    动态内存分配，运行时分配且不连续</span><br><span class=\"line\">元素获取      通过Index获取，速度较快         通过遍历顺序访问，速度较慢</span><br><span class=\"line\">添加删除元素   因为内存位置连续且固定，速度较慢  因为内存分配灵活，只有一个开销步骤，速度更快</span><br><span class=\"line\">空间结构      可以是一维或者多维数组           可以是单向、双向或者循环链表</span><br></pre></td></tr></table></figure>\n\n<p>一个单向链表通常具有以下方法：</p>\n<ol>\n<li>size：返回链表中节点的个数</li>\n<li>head：返回链表中的头部元素</li>\n<li>add：向链表尾部增加一个节点</li>\n<li>remove：删除某个节点</li>\n<li>indexOf：返回某个节点的 index</li>\n<li>elementAt：返回某个 index 处的节点</li>\n<li>addAt：在某个 index 处插入一个节点</li>\n<li>removeAt：删除某个 index 处的节点</li>\n</ol>\n<h2 id=\"Set（集合）\"><a href=\"#Set（集合）\" class=\"headerlink\" title=\"Set（集合）\"></a>Set（集合）</h2><p><img src=\"/images/set.png\" alt></p>\n<p><strong>集合是数学中的一个基本概念，表示具有某种特性的对象汇总成的集体。在 ES6 中也引入了集合类型 Set，Set 和 Array 有一定程度的相似，不同的是 Set 中不允许出现重复的元素而且是无序的。</strong></p>\n<p>一个典型的 Set 应该具有以下方法：</p>\n<ol>\n<li>values：返回集合中的所有元素</li>\n<li>size：返回集合中元素的个数</li>\n<li>has：判断集合中是否存在某个元素</li>\n<li>add：向集合中添加元素</li>\n<li>remove：从集合中移除某个元素</li>\n<li>union：返回两个集合的并集</li>\n<li>intersection：返回两个集合的交集</li>\n<li>difference：返回两个集合的差集</li>\n<li>subset：判断一个集合是否为另一个集合的子集</li>\n</ol>\n<h2 id=\"Hash-Table（哈希表-散列表）\"><a href=\"#Hash-Table（哈希表-散列表）\" class=\"headerlink\" title=\"Hash Table（哈希表/散列表）\"></a>Hash Table（哈希表/散列表）</h2><p><strong>Hash Table 是一种用于存储键值对（key value pair）的数据结构，因为 Hash Table 根据 key 查询 value 的速度很快，所以它常用于实现 Map、Dictinary、Object 等数据结构。如上图所示，Hash Table 内部使用一个 hash 函数将传入的键转换成一串数字，而这串数字将作为键值对实际的 key，通过这个 key 查询对应的 value 非常快，时间复杂度将达到 O(1)。Hash 函数要求相同输入对应的输出必须相等，而不同输入对应的输出必须不等，相当于对每对数据打上唯一的指纹。</strong></p>\n<p>一个 Hash Table 通常具有下列方法：</p>\n<ol>\n<li>add：增加一组键值对</li>\n<li>remove：删除一组键值对</li>\n<li>lookup：查找一个键对应的值</li>\n</ol>\n<h2 id=\"tree\"><a href=\"#tree\" class=\"headerlink\" title=\"tree\"></a>tree</h2><p><strong>顾名思义，Tree 的数据结构和自然界中的树极其相似，有根、树枝、叶子，如上图所示。Tree 是一种多层数据结构，与 Array、Stack、Queue 相比是一种非线性的数据结构，在进行插入和搜索操作时很高效。</strong><br>在描述一个 Tree 时经常会用到下列概念：</p>\n<ol>\n<li>Root（根）：代表树的根节点，根节点没有父节点</li>\n<li>Parent Node（父节点）：一个节点的直接上级节点，只有一个</li>\n<li>Child Node（子节点）：一个节点的直接下级节点，可能有多个</li>\n<li>Siblings（兄弟节点）：具有相同父节点的节点</li>\n<li>Leaf（叶节点）：没有子节点的节点</li>\n<li>Edge（边）：两个节点之间的连接线</li>\n<li>Path（路径）：从源节点到目标节点的连续边</li>\n<li>Height of Node（节点的高度）：表示节点与叶节点之间的最长路径上边的个数</li>\n<li>Height of Tree（树的高度）：即根节点的高度</li>\n<li>Depth of Node（节点的深度）：表示从根节点到该节点的边的个数</li>\n<li>Degree of Node（节点的度）：表示子节点的个数</li>\n</ol>\n<p>一个二叉查找树应该具有以下常用方法：</p>\n<ol>\n<li>add：向树中插入一个节点</li>\n<li>findMin：查找树中最小的节点</li>\n<li>findMax：查找树中最大的节点</li>\n<li>find：查找树中的某个节点</li>\n<li>isPresent：判断某个节点在树中是否存在</li>\n<li>remove：移除树中的某个节点</li>\n</ol>\n<p>相关阅读：<br><a href=\"https://mp.weixin.qq.com/s/mMDlxNhm8pc8lccH_8Baxw\" target=\"_blank\" rel=\"noopener\">数据结构</a></p>\n"},{"title":"移动端适配","_content":"\n相关阅读：\n[hotcss](https://github.com/imochen/hotcss/blob/master/README.md)\n","source":"_drafts/移动端适配.md","raw":"---\ntitle: 移动端适配\ncategories:\ntags:\n  - 移动端\n---\n\n相关阅读：\n[hotcss](https://github.com/imochen/hotcss/blob/master/README.md)\n","slug":"移动端适配","published":0,"date":"2019-10-09T07:13:52.805Z","updated":"2019-10-09T07:14:17.736Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckb1z4dg2001t9n949z99pmz1","content":"<p>相关阅读：<br><a href=\"https://github.com/imochen/hotcss/blob/master/README.md\" target=\"_blank\" rel=\"noopener\">hotcss</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>相关阅读：<br><a href=\"https://github.com/imochen/hotcss/blob/master/README.md\" target=\"_blank\" rel=\"noopener\">hotcss</a></p>\n"},{"title":"移动端开发技巧","_content":"\n相关阅读：\n[https://juejin.im/post/5d6e1899e51d453b1e478b29](https://juejin.im/post/5d6e1899e51d453b1e478b29)\n","source":"_drafts/移动端开发技巧.md","raw":"---\ntitle: 移动端开发技巧\ncategories:\ntags:\n---\n\n相关阅读：\n[https://juejin.im/post/5d6e1899e51d453b1e478b29](https://juejin.im/post/5d6e1899e51d453b1e478b29)\n","slug":"移动端开发技巧","published":0,"date":"2019-10-14T03:07:01.042Z","updated":"2019-10-14T03:07:20.081Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckb1z4dg3001v9n94nlkqlqh0","content":"<p>相关阅读：<br><a href=\"https://juejin.im/post/5d6e1899e51d453b1e478b29\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/5d6e1899e51d453b1e478b29</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>相关阅读：<br><a href=\"https://juejin.im/post/5d6e1899e51d453b1e478b29\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/5d6e1899e51d453b1e478b29</a></p>\n"},{"title":"设计模式","_content":"\n\n设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。代表了最佳的实践， 使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样","source":"_drafts/设计模式.md","raw":"---\ntitle: 设计模式\ncategories:\ntags:\n---\n\n\n设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。代表了最佳的实践， 使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样","slug":"设计模式","published":0,"date":"2020-05-22T06:30:30.014Z","updated":"2020-05-22T06:30:30.014Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckb1z4dg4001x9n94k7mz6eug","content":"<p>设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。代表了最佳的实践， 使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样</p>\n","site":{"data":{}},"excerpt":"","more":"<p>设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。代表了最佳的实践， 使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样</p>\n"},{"title":"缓存","_content":"","source":"_drafts/缓存.md","raw":"---\ntitle: 缓存\ncategories:\ntags:\n---\n","slug":"缓存","published":0,"date":"2019-10-14T03:11:09.011Z","updated":"2019-10-14T03:11:09.011Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckb1z4dg5001y9n94wcz4ddxu","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"闭包","_content":"\n```\n　　function f1(){\n\n　　var n=999;\n\n　　function f2(){\n　　　　alert(n);\n　　}\n\n　　return f2;\n\n}\n\nvar result=f1();\n\nresult(); // 999\n\n\n```\n\n## 闭包的概念\n\n上一节代码中的 f2 函数，就是闭包。\n\n闭包就是能够读取其他函数内部变量的函数。\n\n由于在 Javascript 语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成\"定义在一个函数内部的函数\"。\n\n闭包的最大用处有两个，一个是可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。\n\n## 闭包的应用场景\n","source":"_drafts/闭包.md","raw":"---\ntitle: 闭包\ncategories:\n  - 前端\ntags:\n  - javascript\n---\n\n```\n　　function f1(){\n\n　　var n=999;\n\n　　function f2(){\n　　　　alert(n);\n　　}\n\n　　return f2;\n\n}\n\nvar result=f1();\n\nresult(); // 999\n\n\n```\n\n## 闭包的概念\n\n上一节代码中的 f2 函数，就是闭包。\n\n闭包就是能够读取其他函数内部变量的函数。\n\n由于在 Javascript 语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成\"定义在一个函数内部的函数\"。\n\n闭包的最大用处有两个，一个是可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。\n\n## 闭包的应用场景\n","slug":"闭包","published":0,"date":"2019-10-03T01:35:40.926Z","updated":"2020-05-21T09:03:01.431Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckb1z4dg5001z9n94bmiaayzz","content":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">　　function f1()&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">　　var n=999;</span><br><span class=\"line\"></span><br><span class=\"line\">　　function f2()&#123;</span><br><span class=\"line\">　　　　alert(n);</span><br><span class=\"line\">　　&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">　　return f2;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var result=f1();</span><br><span class=\"line\"></span><br><span class=\"line\">result(); // 999</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"闭包的概念\"><a href=\"#闭包的概念\" class=\"headerlink\" title=\"闭包的概念\"></a>闭包的概念</h2><p>上一节代码中的 f2 函数，就是闭包。</p>\n<p>闭包就是能够读取其他函数内部变量的函数。</p>\n<p>由于在 Javascript 语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成”定义在一个函数内部的函数”。</p>\n<p>闭包的最大用处有两个，一个是可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。</p>\n<h2 id=\"闭包的应用场景\"><a href=\"#闭包的应用场景\" class=\"headerlink\" title=\"闭包的应用场景\"></a>闭包的应用场景</h2>","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">　　function f1()&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">　　var n=999;</span><br><span class=\"line\"></span><br><span class=\"line\">　　function f2()&#123;</span><br><span class=\"line\">　　　　alert(n);</span><br><span class=\"line\">　　&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">　　return f2;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var result=f1();</span><br><span class=\"line\"></span><br><span class=\"line\">result(); // 999</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"闭包的概念\"><a href=\"#闭包的概念\" class=\"headerlink\" title=\"闭包的概念\"></a>闭包的概念</h2><p>上一节代码中的 f2 函数，就是闭包。</p>\n<p>闭包就是能够读取其他函数内部变量的函数。</p>\n<p>由于在 Javascript 语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成”定义在一个函数内部的函数”。</p>\n<p>闭包的最大用处有两个，一个是可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。</p>\n<h2 id=\"闭包的应用场景\"><a href=\"#闭包的应用场景\" class=\"headerlink\" title=\"闭包的应用场景\"></a>闭包的应用场景</h2>"},{"title":"算法","_content":"","source":"_drafts/算法.md","raw":"---\ntitle: 算法\ncategories:\ntags:\n---\n","slug":"算法","published":0,"date":"2020-03-02T01:03:01.000Z","updated":"2020-03-03T06:28:12.383Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckb1z4dg600219n949l47f6h2","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"防抖节流","_content":"\n## 防抖\n\n**防抖的原理就是：你尽管触发事件，但是我一定在事件触发 n 秒后才执行，如果你在一个事件触发的 n 秒内又触发了这个事件，那我就以新的事件的时间为准，n 秒后才执行，总之，就是要等你触发完事件 n 秒内不再触发事件，我才执行，真是任性呐!**\n\n```\n function debounce(func,time){\n   var timeout\n   return function(){\n     let self = this\n     clearTimeout(timeout)\n     timeout = setTimeout(func.call(null,self),time)\n   }\n }\n```\n\n## 节流\n\n相关阅读：\n","source":"_drafts/防抖节流.md","raw":"---\ntitle: 防抖节流\ncategories:\ntags:\n---\n\n## 防抖\n\n**防抖的原理就是：你尽管触发事件，但是我一定在事件触发 n 秒后才执行，如果你在一个事件触发的 n 秒内又触发了这个事件，那我就以新的事件的时间为准，n 秒后才执行，总之，就是要等你触发完事件 n 秒内不再触发事件，我才执行，真是任性呐!**\n\n```\n function debounce(func,time){\n   var timeout\n   return function(){\n     let self = this\n     clearTimeout(timeout)\n     timeout = setTimeout(func.call(null,self),time)\n   }\n }\n```\n\n## 节流\n\n相关阅读：\n","slug":"防抖节流","published":0,"date":"2019-10-03T02:00:14.300Z","updated":"2019-11-09T07:40:32.507Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckb1z4dg700239n94d8xqbsp6","content":"<h2 id=\"防抖\"><a href=\"#防抖\" class=\"headerlink\" title=\"防抖\"></a>防抖</h2><p><strong>防抖的原理就是：你尽管触发事件，但是我一定在事件触发 n 秒后才执行，如果你在一个事件触发的 n 秒内又触发了这个事件，那我就以新的事件的时间为准，n 秒后才执行，总之，就是要等你触发完事件 n 秒内不再触发事件，我才执行，真是任性呐!</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function debounce(func,time)&#123;</span><br><span class=\"line\">  var timeout</span><br><span class=\"line\">  return function()&#123;</span><br><span class=\"line\">    let self = this</span><br><span class=\"line\">    clearTimeout(timeout)</span><br><span class=\"line\">    timeout = setTimeout(func.call(null,self),time)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"节流\"><a href=\"#节流\" class=\"headerlink\" title=\"节流\"></a>节流</h2><p>相关阅读：</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"防抖\"><a href=\"#防抖\" class=\"headerlink\" title=\"防抖\"></a>防抖</h2><p><strong>防抖的原理就是：你尽管触发事件，但是我一定在事件触发 n 秒后才执行，如果你在一个事件触发的 n 秒内又触发了这个事件，那我就以新的事件的时间为准，n 秒后才执行，总之，就是要等你触发完事件 n 秒内不再触发事件，我才执行，真是任性呐!</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function debounce(func,time)&#123;</span><br><span class=\"line\">  var timeout</span><br><span class=\"line\">  return function()&#123;</span><br><span class=\"line\">    let self = this</span><br><span class=\"line\">    clearTimeout(timeout)</span><br><span class=\"line\">    timeout = setTimeout(func.call(null,self),time)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"节流\"><a href=\"#节流\" class=\"headerlink\" title=\"节流\"></a>节流</h2><p>相关阅读：</p>\n"},{"title":"对象","_content":"\n**所有对象都会从它的隐式原型上继承一个 constructor 属性**\n\n**值得注意的是原型对象也拥有一个属性——constructor 指向构造函数。**\n\n```\nvar o = {};\no.constructor === Object; // true\n\nvar o = new Object;\no.constructor === Object; // true\n\nvar a = [];\na.constructor === Array; // true\n\nvar a = new Array;\na.constructor === Array // true\n\nvar n = new Number(3);\nn.constructor === Number; // true\n```\n","source":"_drafts/对象.md","raw":"---\ntitle: 对象\ncategories:\ntags:\n  - javascript\n---\n\n**所有对象都会从它的隐式原型上继承一个 constructor 属性**\n\n**值得注意的是原型对象也拥有一个属性——constructor 指向构造函数。**\n\n```\nvar o = {};\no.constructor === Object; // true\n\nvar o = new Object;\no.constructor === Object; // true\n\nvar a = [];\na.constructor === Array; // true\n\nvar a = new Array;\na.constructor === Array // true\n\nvar n = new Number(3);\nn.constructor === Number; // true\n```\n","slug":"对象","published":0,"date":"2019-08-30T03:01:45.260Z","updated":"2020-05-04T03:31:39.224Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckb1z4dg800249n94jfj86104","content":"<p><strong>所有对象都会从它的隐式原型上继承一个 constructor 属性</strong></p>\n<p><strong>值得注意的是原型对象也拥有一个属性——constructor 指向构造函数。</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var o = &#123;&#125;;</span><br><span class=\"line\">o.constructor === Object; // true</span><br><span class=\"line\"></span><br><span class=\"line\">var o = new Object;</span><br><span class=\"line\">o.constructor === Object; // true</span><br><span class=\"line\"></span><br><span class=\"line\">var a = [];</span><br><span class=\"line\">a.constructor === Array; // true</span><br><span class=\"line\"></span><br><span class=\"line\">var a = new Array;</span><br><span class=\"line\">a.constructor === Array // true</span><br><span class=\"line\"></span><br><span class=\"line\">var n = new Number(3);</span><br><span class=\"line\">n.constructor === Number; // true</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<p><strong>所有对象都会从它的隐式原型上继承一个 constructor 属性</strong></p>\n<p><strong>值得注意的是原型对象也拥有一个属性——constructor 指向构造函数。</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var o = &#123;&#125;;</span><br><span class=\"line\">o.constructor === Object; // true</span><br><span class=\"line\"></span><br><span class=\"line\">var o = new Object;</span><br><span class=\"line\">o.constructor === Object; // true</span><br><span class=\"line\"></span><br><span class=\"line\">var a = [];</span><br><span class=\"line\">a.constructor === Array; // true</span><br><span class=\"line\"></span><br><span class=\"line\">var a = new Array;</span><br><span class=\"line\">a.constructor === Array // true</span><br><span class=\"line\"></span><br><span class=\"line\">var n = new Number(3);</span><br><span class=\"line\">n.constructor === Number; // true</span><br></pre></td></tr></table></figure>\n\n"},{"title":"浏览器","date":"2020-06-05T07:33:33.000Z","_content":"\n\n## 浏览器简介\n\n目前使用的主流浏览器有五个：Internet Explorer、Firefox、Safari、Chrome 浏览器和 Opera\n\n浏览器的主要功能就是向服务器发出请求，在浏览器窗口中展示您选择的网络资源。这里所说的资源一般是指 HTML 文档，也可以是 PDF、图片或其他的类型。资源的位置由用户使用 URI（统一资源标示符）指定。\n\n浏览器解释并显示 HTML 文件的方式是在 HTML 和 CSS 规范中指定的。这些规范由网络标准化组织 W3C（万维网联盟）进行维护\n\n## 浏览器构成\n\n**七个部分构成：**\n\n![](/images/browser.png)\n\n- **用户界面 （User Interface）**\n  包括地址栏、前进/后退按钮、书签菜单等。除了浏览器主窗口显示的您请求的页面外，其他显示的各个部分都属于用户界面\n  用户界面主要包括工具栏、地址栏、前进/后退按钮、书签菜单、可视化页面加载进度、智能下载处理、首选项、打印等。除了浏览器主窗口显示请求的页面之外，其他显示的部分都属于用户界面。\n  用户界面还可以与桌面环境集成，以提供浏览器会话管理或与其他桌面应用程序的通信。\n\n- **浏览器引擎 （Browser engine)**\n  在用户界面和呈现引擎之间传送指令\n  浏览器引擎是一个可嵌入的组件，其为渲染引擎提供高级接口。\n  浏览器引擎可以加载一个给定的 URI，并支持诸如：前进/后退/重新加载等浏览操作。\n  浏览器引擎提供查看浏览会话的各个方面的挂钩，例如：当前页面加载进度、JavaScript alert。\n  浏览器引擎还允许查询/修改渲染引擎设置。\n- **渲染引擎 （Rendering engine)**\n  负责显示请求的内容。如果请求的内容是 HTML，它就负责解析 HTML 和 CSS 内容，并将解析后的内容显示在屏幕上\n  渲染引擎为指定的 URI 生成可视化的表示。\n  渲染引擎能够显示 HTML 和 XML 文档，可选择 CSS 样式，以及嵌入式内容（如图片）。\n  渲染引擎能够准确计算页面布局，可使用“回流”算法逐步调整页面元素的位置。\n  渲染引擎内部包含 HTML 解析器。\n- **网络 （Networking）**\n  用于网络调用，比如 HTTP 请求。其接口与平台无关，并为所有平台提供底层实现。\n  网络系统实现 HTTP 和 FTP 等文件传输协议。 网络系统可以在不同的字符集之间进行转换，为文件解析 MIME 媒体类型。 网络系统可以实现最近检索资源的缓存功能。\n- **JavaScript 解释器 （Javascript interpreter)**\n  用于解析和执行 JavaScript 代码\n  JavaScript 解释器能够解释并执行嵌入在网页中的 JavaScript（又称 ECMAScript）代码。 为了安全起见，浏览器引擎或渲染引擎可能会禁用某些 JavaScript 功能，如弹出窗口的打开。\n- **用户界面后端（UI Backend)**\n  用于绘制基本的窗口小部件，比如组合框和窗口。其公开了与平台无关的通用接口，而在底层使用操作系统的用户界面方法。\n  显示后端提供绘图和窗口原语，包括：用户界面控件集合、字体集合。\n- **数据存储 （Data Persistence）**\n  这是持久层。浏览器需要在硬盘上保存各种数据，例如 Cookie。新的 HTML 规范 (HTML5) 定义了“网络数据库”，这是一个完整（但是轻便）的浏览器内数据库。\n\n数据持久层将与浏览会话相关联的各种数据存储在硬盘上。 这些数据可能是诸如：书签、工具栏设置等这样的高级数据，也可能是诸如：Cookie，安全证书、缓存等这样的低级数据。\n\n## 浏览器进程\n\n- 浏览器是多进程的\n- 浏览器之所以能够运行，是因为系统给它的进程分配了资源（cpu、内存）\n- 简单点理解，每打开一个 Tab 页，就相当于创建了一个独立的浏览器进程\n\n**浏览器包含四个进程：**\n\n1. Browser 进程：浏览器的主进程（负责协调、主控），只有一个。作用有\n\n   - 负责浏览器界面显示，与用户交互。如前进，后退等\n   - 负责各个页面的管理，创建和销毁其他进程\n   - 将 Renderer 进程得到的内存中的 Bitmap，绘制到用户界面上\n   - 网络资源的管理，下载等\n\n2. 第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建\n\n3. GPU 进程：最多一个，用于 3D 绘制等\n\n4. 浏览器渲染进程（浏览器内核）（Renderer 进程，内部是多线程的）：默认每个 Tab 页面一个进程，互不影响。主要作用为：\n\n   - 页面渲染，脚本执行，事件处理等\n\n**在浏览器中打开一个网页相当于新起了一个进程（进程内有自己的多线程),打开多个空白标签页后，会发现多个空白标签页被合并成了一个进程**\n\n## 浏览器内核\n\n浏览器的内核是分为两个部分的，一是渲染引擎，另一个是 JS 引擎。\n现在 JS 引擎比较独立，内核更加倾向于说渲染引擎。\n\n**常见的浏览器内核五种：**\n\n1. **Trident 内核：** 代表作品是 IE，因 IE 捆绑在 Windows 中，所以占有极高的份额，又称为 IE 内核或 MSHTML，此内核只能用于 Windows 平台，且不是开源的。\n   代表作品还有腾讯、Maxthon（遨游）、360 浏览器等。但由于市场份额比较大，曾经出现脱离了 W3C 标准的时候，同时 IE 版本比较多，存在很多的兼容性问题。\n\n2. **Gecko 内核：** 代表作品是 Firefox，即火狐浏览器。因火狐是最多的用户，故常被称为 firefox 内核它是开源的，最大优势是跨平台，在 Microsoft Windows、Linux、MacOs X 等主要操作系统中使用。Mozilla 是网景公司在第一次浏览器大战败给微软之后创建的。有兴趣的同学可以了解一下浏览器大战\n\n3. **Webkit 内核：** 代表作品是 Safari、曾经的 Chrome，是开源的项目。\n\n4. **Presto 内核：** 代表作品是 Opera，Presto 是由 Opera Software 开发的浏览器排版引擎，它是世界公认最快的渲染速度的引擎。在 13 年之后，Opera 宣布加入谷歌阵营，弃用了 Presto\n\n5. **Blink 内核：** 由 Google 和 Opera Software 开发的浏览器排版引擎，2013 年 4 月发布。现在 Chrome 内核是 Blink。谷歌还开发了自己的 JS 引擎，V8，使 JS 运行速度极大地提高了\n\n<!-- [原文链接](https://blog.csdn.net/u014753892/article/details/52713841) -->\n\n**浏览器 JS 引擎：**\n\n1. Mozilla: SpiderMonkey、TraceMonkey、JagerMonkey、Rhino\n2. Google: V8\n3. Microsoft: chakra、JScript\n4. Opera: Carakan\n5. Apple: javaScriptCore\n6. 其他: KJS、Narcissus、Tamarin、Nitro\n\n最近发布 QuickJS 与 Hermes 也是 JS 引擎，它们都超越了浏览器范畴.\n\n## 渲染进程及其线程\n\n可以这样理解，页面的渲染，JS 的执行，事件的循环，都在这个进程内进行。\n\n**渲染进程是多线程的，有五个线程构成：**\n\n1. GUI 渲染线程\n\n   - 负责渲染浏览器界面，解析 HTML，CSS，构建 DOM 树和 RenderObject 树，布局和绘制等。\n   - 当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行\n   - 注意，GUI 渲染线程与 JS 引擎线程是互斥的，当 JS 引擎执行时 GUI 线程会被挂起（相当于被冻结了），GUI 更新会被保存在一个队列中等到 JS 引擎空闲时立即执行。\n\n2. JS 引擎线程\n\n   - 也称为 JS 内核，负责处理 Javascript 脚本程序。（例如 V8 引擎）\n   - JS 引擎线程负责解析 Javascript 脚本，运行代码。\n   - JS 引擎一直等待着任务队列中任务的到来，然后加以处理，一个 Tab 页（renderer 进程）中无论什么时候都只有一个 JS 线程在运行 JS 程序\n   - 同样注意，GUI 渲染线程与 JS 引擎线程是互斥的，所以如果 JS 执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。\n\n3. 事件触发线程\n\n   - 归属于浏览器而不是 JS 引擎，用来控制事件循环（可以理解，JS 引擎自己都忙不过来，需要浏览器另开线程协助）\n   - 当 JS 引擎执行代码块如 setTimeOut 时（也可来自浏览器内核的其他线程,如鼠标点击、AJAX 异步请求等），会将对应任务添加到事件线程中\n   - 当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待 JS 引擎的处理\n   - 注意，由于 JS 的单线程关系，所以这些待处理队列中的事件都得排队等待 JS 引擎处理（当 JS 引擎空闲时才会去执行）\n\n4. 定时触发器线程\n\n   - 传说中的 setInterval 与 setTimeout 所在线程\n   - 浏览器定时计数器并不是由 JavaScript 引擎计数的,（因为 JavaScript 引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确）\n   - 因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待 JS 引擎空闲后执行）\n   - 注意，W3C 在 HTML 标准中规定，规定要求 setTimeout 中低于 4ms 的时间间隔算为 4ms。\n\n5. 异步 http 请求线程\n\n   - 在 XMLHttpRequest 在连接后是通过浏览器新开一个线程请求\n   - 将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由 JavaScript 引擎执行。\n\n## 相关阅读\n\n[浏览器进程](https://juejin.im/post/5a6547d0f265da3e283a1df7)\n","source":"_posts/2020/06/05/浏览器.md","raw":"---\ntitle: 浏览器\ncategories:\n  - 前端\ntags:\n  - 浏览器\ndate: 2020-06-05 15:33:33\n---\n\n\n## 浏览器简介\n\n目前使用的主流浏览器有五个：Internet Explorer、Firefox、Safari、Chrome 浏览器和 Opera\n\n浏览器的主要功能就是向服务器发出请求，在浏览器窗口中展示您选择的网络资源。这里所说的资源一般是指 HTML 文档，也可以是 PDF、图片或其他的类型。资源的位置由用户使用 URI（统一资源标示符）指定。\n\n浏览器解释并显示 HTML 文件的方式是在 HTML 和 CSS 规范中指定的。这些规范由网络标准化组织 W3C（万维网联盟）进行维护\n\n## 浏览器构成\n\n**七个部分构成：**\n\n![](/images/browser.png)\n\n- **用户界面 （User Interface）**\n  包括地址栏、前进/后退按钮、书签菜单等。除了浏览器主窗口显示的您请求的页面外，其他显示的各个部分都属于用户界面\n  用户界面主要包括工具栏、地址栏、前进/后退按钮、书签菜单、可视化页面加载进度、智能下载处理、首选项、打印等。除了浏览器主窗口显示请求的页面之外，其他显示的部分都属于用户界面。\n  用户界面还可以与桌面环境集成，以提供浏览器会话管理或与其他桌面应用程序的通信。\n\n- **浏览器引擎 （Browser engine)**\n  在用户界面和呈现引擎之间传送指令\n  浏览器引擎是一个可嵌入的组件，其为渲染引擎提供高级接口。\n  浏览器引擎可以加载一个给定的 URI，并支持诸如：前进/后退/重新加载等浏览操作。\n  浏览器引擎提供查看浏览会话的各个方面的挂钩，例如：当前页面加载进度、JavaScript alert。\n  浏览器引擎还允许查询/修改渲染引擎设置。\n- **渲染引擎 （Rendering engine)**\n  负责显示请求的内容。如果请求的内容是 HTML，它就负责解析 HTML 和 CSS 内容，并将解析后的内容显示在屏幕上\n  渲染引擎为指定的 URI 生成可视化的表示。\n  渲染引擎能够显示 HTML 和 XML 文档，可选择 CSS 样式，以及嵌入式内容（如图片）。\n  渲染引擎能够准确计算页面布局，可使用“回流”算法逐步调整页面元素的位置。\n  渲染引擎内部包含 HTML 解析器。\n- **网络 （Networking）**\n  用于网络调用，比如 HTTP 请求。其接口与平台无关，并为所有平台提供底层实现。\n  网络系统实现 HTTP 和 FTP 等文件传输协议。 网络系统可以在不同的字符集之间进行转换，为文件解析 MIME 媒体类型。 网络系统可以实现最近检索资源的缓存功能。\n- **JavaScript 解释器 （Javascript interpreter)**\n  用于解析和执行 JavaScript 代码\n  JavaScript 解释器能够解释并执行嵌入在网页中的 JavaScript（又称 ECMAScript）代码。 为了安全起见，浏览器引擎或渲染引擎可能会禁用某些 JavaScript 功能，如弹出窗口的打开。\n- **用户界面后端（UI Backend)**\n  用于绘制基本的窗口小部件，比如组合框和窗口。其公开了与平台无关的通用接口，而在底层使用操作系统的用户界面方法。\n  显示后端提供绘图和窗口原语，包括：用户界面控件集合、字体集合。\n- **数据存储 （Data Persistence）**\n  这是持久层。浏览器需要在硬盘上保存各种数据，例如 Cookie。新的 HTML 规范 (HTML5) 定义了“网络数据库”，这是一个完整（但是轻便）的浏览器内数据库。\n\n数据持久层将与浏览会话相关联的各种数据存储在硬盘上。 这些数据可能是诸如：书签、工具栏设置等这样的高级数据，也可能是诸如：Cookie，安全证书、缓存等这样的低级数据。\n\n## 浏览器进程\n\n- 浏览器是多进程的\n- 浏览器之所以能够运行，是因为系统给它的进程分配了资源（cpu、内存）\n- 简单点理解，每打开一个 Tab 页，就相当于创建了一个独立的浏览器进程\n\n**浏览器包含四个进程：**\n\n1. Browser 进程：浏览器的主进程（负责协调、主控），只有一个。作用有\n\n   - 负责浏览器界面显示，与用户交互。如前进，后退等\n   - 负责各个页面的管理，创建和销毁其他进程\n   - 将 Renderer 进程得到的内存中的 Bitmap，绘制到用户界面上\n   - 网络资源的管理，下载等\n\n2. 第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建\n\n3. GPU 进程：最多一个，用于 3D 绘制等\n\n4. 浏览器渲染进程（浏览器内核）（Renderer 进程，内部是多线程的）：默认每个 Tab 页面一个进程，互不影响。主要作用为：\n\n   - 页面渲染，脚本执行，事件处理等\n\n**在浏览器中打开一个网页相当于新起了一个进程（进程内有自己的多线程),打开多个空白标签页后，会发现多个空白标签页被合并成了一个进程**\n\n## 浏览器内核\n\n浏览器的内核是分为两个部分的，一是渲染引擎，另一个是 JS 引擎。\n现在 JS 引擎比较独立，内核更加倾向于说渲染引擎。\n\n**常见的浏览器内核五种：**\n\n1. **Trident 内核：** 代表作品是 IE，因 IE 捆绑在 Windows 中，所以占有极高的份额，又称为 IE 内核或 MSHTML，此内核只能用于 Windows 平台，且不是开源的。\n   代表作品还有腾讯、Maxthon（遨游）、360 浏览器等。但由于市场份额比较大，曾经出现脱离了 W3C 标准的时候，同时 IE 版本比较多，存在很多的兼容性问题。\n\n2. **Gecko 内核：** 代表作品是 Firefox，即火狐浏览器。因火狐是最多的用户，故常被称为 firefox 内核它是开源的，最大优势是跨平台，在 Microsoft Windows、Linux、MacOs X 等主要操作系统中使用。Mozilla 是网景公司在第一次浏览器大战败给微软之后创建的。有兴趣的同学可以了解一下浏览器大战\n\n3. **Webkit 内核：** 代表作品是 Safari、曾经的 Chrome，是开源的项目。\n\n4. **Presto 内核：** 代表作品是 Opera，Presto 是由 Opera Software 开发的浏览器排版引擎，它是世界公认最快的渲染速度的引擎。在 13 年之后，Opera 宣布加入谷歌阵营，弃用了 Presto\n\n5. **Blink 内核：** 由 Google 和 Opera Software 开发的浏览器排版引擎，2013 年 4 月发布。现在 Chrome 内核是 Blink。谷歌还开发了自己的 JS 引擎，V8，使 JS 运行速度极大地提高了\n\n<!-- [原文链接](https://blog.csdn.net/u014753892/article/details/52713841) -->\n\n**浏览器 JS 引擎：**\n\n1. Mozilla: SpiderMonkey、TraceMonkey、JagerMonkey、Rhino\n2. Google: V8\n3. Microsoft: chakra、JScript\n4. Opera: Carakan\n5. Apple: javaScriptCore\n6. 其他: KJS、Narcissus、Tamarin、Nitro\n\n最近发布 QuickJS 与 Hermes 也是 JS 引擎，它们都超越了浏览器范畴.\n\n## 渲染进程及其线程\n\n可以这样理解，页面的渲染，JS 的执行，事件的循环，都在这个进程内进行。\n\n**渲染进程是多线程的，有五个线程构成：**\n\n1. GUI 渲染线程\n\n   - 负责渲染浏览器界面，解析 HTML，CSS，构建 DOM 树和 RenderObject 树，布局和绘制等。\n   - 当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行\n   - 注意，GUI 渲染线程与 JS 引擎线程是互斥的，当 JS 引擎执行时 GUI 线程会被挂起（相当于被冻结了），GUI 更新会被保存在一个队列中等到 JS 引擎空闲时立即执行。\n\n2. JS 引擎线程\n\n   - 也称为 JS 内核，负责处理 Javascript 脚本程序。（例如 V8 引擎）\n   - JS 引擎线程负责解析 Javascript 脚本，运行代码。\n   - JS 引擎一直等待着任务队列中任务的到来，然后加以处理，一个 Tab 页（renderer 进程）中无论什么时候都只有一个 JS 线程在运行 JS 程序\n   - 同样注意，GUI 渲染线程与 JS 引擎线程是互斥的，所以如果 JS 执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。\n\n3. 事件触发线程\n\n   - 归属于浏览器而不是 JS 引擎，用来控制事件循环（可以理解，JS 引擎自己都忙不过来，需要浏览器另开线程协助）\n   - 当 JS 引擎执行代码块如 setTimeOut 时（也可来自浏览器内核的其他线程,如鼠标点击、AJAX 异步请求等），会将对应任务添加到事件线程中\n   - 当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待 JS 引擎的处理\n   - 注意，由于 JS 的单线程关系，所以这些待处理队列中的事件都得排队等待 JS 引擎处理（当 JS 引擎空闲时才会去执行）\n\n4. 定时触发器线程\n\n   - 传说中的 setInterval 与 setTimeout 所在线程\n   - 浏览器定时计数器并不是由 JavaScript 引擎计数的,（因为 JavaScript 引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确）\n   - 因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待 JS 引擎空闲后执行）\n   - 注意，W3C 在 HTML 标准中规定，规定要求 setTimeout 中低于 4ms 的时间间隔算为 4ms。\n\n5. 异步 http 请求线程\n\n   - 在 XMLHttpRequest 在连接后是通过浏览器新开一个线程请求\n   - 将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由 JavaScript 引擎执行。\n\n## 相关阅读\n\n[浏览器进程](https://juejin.im/post/5a6547d0f265da3e283a1df7)\n","slug":"浏览器","published":1,"updated":"2020-06-05T07:33:33.795Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckb1z4djc00279n94smdrxyr1","content":"<h2 id=\"浏览器简介\"><a href=\"#浏览器简介\" class=\"headerlink\" title=\"浏览器简介\"></a>浏览器简介</h2><p>目前使用的主流浏览器有五个：Internet Explorer、Firefox、Safari、Chrome 浏览器和 Opera</p>\n<p>浏览器的主要功能就是向服务器发出请求，在浏览器窗口中展示您选择的网络资源。这里所说的资源一般是指 HTML 文档，也可以是 PDF、图片或其他的类型。资源的位置由用户使用 URI（统一资源标示符）指定。</p>\n<p>浏览器解释并显示 HTML 文件的方式是在 HTML 和 CSS 规范中指定的。这些规范由网络标准化组织 W3C（万维网联盟）进行维护</p>\n<h2 id=\"浏览器构成\"><a href=\"#浏览器构成\" class=\"headerlink\" title=\"浏览器构成\"></a>浏览器构成</h2><p><strong>七个部分构成：</strong></p>\n<p><img src=\"/images/browser.png\" alt></p>\n<ul>\n<li><p><strong>用户界面 （User Interface）</strong><br>包括地址栏、前进/后退按钮、书签菜单等。除了浏览器主窗口显示的您请求的页面外，其他显示的各个部分都属于用户界面<br>用户界面主要包括工具栏、地址栏、前进/后退按钮、书签菜单、可视化页面加载进度、智能下载处理、首选项、打印等。除了浏览器主窗口显示请求的页面之外，其他显示的部分都属于用户界面。<br>用户界面还可以与桌面环境集成，以提供浏览器会话管理或与其他桌面应用程序的通信。</p>\n</li>\n<li><p><strong>浏览器引擎 （Browser engine)</strong><br>在用户界面和呈现引擎之间传送指令<br>浏览器引擎是一个可嵌入的组件，其为渲染引擎提供高级接口。<br>浏览器引擎可以加载一个给定的 URI，并支持诸如：前进/后退/重新加载等浏览操作。<br>浏览器引擎提供查看浏览会话的各个方面的挂钩，例如：当前页面加载进度、JavaScript alert。<br>浏览器引擎还允许查询/修改渲染引擎设置。</p>\n</li>\n<li><p><strong>渲染引擎 （Rendering engine)</strong><br>负责显示请求的内容。如果请求的内容是 HTML，它就负责解析 HTML 和 CSS 内容，并将解析后的内容显示在屏幕上<br>渲染引擎为指定的 URI 生成可视化的表示。<br>渲染引擎能够显示 HTML 和 XML 文档，可选择 CSS 样式，以及嵌入式内容（如图片）。<br>渲染引擎能够准确计算页面布局，可使用“回流”算法逐步调整页面元素的位置。<br>渲染引擎内部包含 HTML 解析器。</p>\n</li>\n<li><p><strong>网络 （Networking）</strong><br>用于网络调用，比如 HTTP 请求。其接口与平台无关，并为所有平台提供底层实现。<br>网络系统实现 HTTP 和 FTP 等文件传输协议。 网络系统可以在不同的字符集之间进行转换，为文件解析 MIME 媒体类型。 网络系统可以实现最近检索资源的缓存功能。</p>\n</li>\n<li><p><strong>JavaScript 解释器 （Javascript interpreter)</strong><br>用于解析和执行 JavaScript 代码<br>JavaScript 解释器能够解释并执行嵌入在网页中的 JavaScript（又称 ECMAScript）代码。 为了安全起见，浏览器引擎或渲染引擎可能会禁用某些 JavaScript 功能，如弹出窗口的打开。</p>\n</li>\n<li><p><strong>用户界面后端（UI Backend)</strong><br>用于绘制基本的窗口小部件，比如组合框和窗口。其公开了与平台无关的通用接口，而在底层使用操作系统的用户界面方法。<br>显示后端提供绘图和窗口原语，包括：用户界面控件集合、字体集合。</p>\n</li>\n<li><p><strong>数据存储 （Data Persistence）</strong><br>这是持久层。浏览器需要在硬盘上保存各种数据，例如 Cookie。新的 HTML 规范 (HTML5) 定义了“网络数据库”，这是一个完整（但是轻便）的浏览器内数据库。</p>\n</li>\n</ul>\n<p>数据持久层将与浏览会话相关联的各种数据存储在硬盘上。 这些数据可能是诸如：书签、工具栏设置等这样的高级数据，也可能是诸如：Cookie，安全证书、缓存等这样的低级数据。</p>\n<h2 id=\"浏览器进程\"><a href=\"#浏览器进程\" class=\"headerlink\" title=\"浏览器进程\"></a>浏览器进程</h2><ul>\n<li>浏览器是多进程的</li>\n<li>浏览器之所以能够运行，是因为系统给它的进程分配了资源（cpu、内存）</li>\n<li>简单点理解，每打开一个 Tab 页，就相当于创建了一个独立的浏览器进程</li>\n</ul>\n<p><strong>浏览器包含四个进程：</strong></p>\n<ol>\n<li><p>Browser 进程：浏览器的主进程（负责协调、主控），只有一个。作用有</p>\n<ul>\n<li>负责浏览器界面显示，与用户交互。如前进，后退等</li>\n<li>负责各个页面的管理，创建和销毁其他进程</li>\n<li>将 Renderer 进程得到的内存中的 Bitmap，绘制到用户界面上</li>\n<li>网络资源的管理，下载等</li>\n</ul>\n</li>\n<li><p>第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建</p>\n</li>\n<li><p>GPU 进程：最多一个，用于 3D 绘制等</p>\n</li>\n<li><p>浏览器渲染进程（浏览器内核）（Renderer 进程，内部是多线程的）：默认每个 Tab 页面一个进程，互不影响。主要作用为：</p>\n<ul>\n<li>页面渲染，脚本执行，事件处理等</li>\n</ul>\n</li>\n</ol>\n<p><strong>在浏览器中打开一个网页相当于新起了一个进程（进程内有自己的多线程),打开多个空白标签页后，会发现多个空白标签页被合并成了一个进程</strong></p>\n<h2 id=\"浏览器内核\"><a href=\"#浏览器内核\" class=\"headerlink\" title=\"浏览器内核\"></a>浏览器内核</h2><p>浏览器的内核是分为两个部分的，一是渲染引擎，另一个是 JS 引擎。<br>现在 JS 引擎比较独立，内核更加倾向于说渲染引擎。</p>\n<p><strong>常见的浏览器内核五种：</strong></p>\n<ol>\n<li><p><strong>Trident 内核：</strong> 代表作品是 IE，因 IE 捆绑在 Windows 中，所以占有极高的份额，又称为 IE 内核或 MSHTML，此内核只能用于 Windows 平台，且不是开源的。<br>代表作品还有腾讯、Maxthon（遨游）、360 浏览器等。但由于市场份额比较大，曾经出现脱离了 W3C 标准的时候，同时 IE 版本比较多，存在很多的兼容性问题。</p>\n</li>\n<li><p><strong>Gecko 内核：</strong> 代表作品是 Firefox，即火狐浏览器。因火狐是最多的用户，故常被称为 firefox 内核它是开源的，最大优势是跨平台，在 Microsoft Windows、Linux、MacOs X 等主要操作系统中使用。Mozilla 是网景公司在第一次浏览器大战败给微软之后创建的。有兴趣的同学可以了解一下浏览器大战</p>\n</li>\n<li><p><strong>Webkit 内核：</strong> 代表作品是 Safari、曾经的 Chrome，是开源的项目。</p>\n</li>\n<li><p><strong>Presto 内核：</strong> 代表作品是 Opera，Presto 是由 Opera Software 开发的浏览器排版引擎，它是世界公认最快的渲染速度的引擎。在 13 年之后，Opera 宣布加入谷歌阵营，弃用了 Presto</p>\n</li>\n<li><p><strong>Blink 内核：</strong> 由 Google 和 Opera Software 开发的浏览器排版引擎，2013 年 4 月发布。现在 Chrome 内核是 Blink。谷歌还开发了自己的 JS 引擎，V8，使 JS 运行速度极大地提高了</p>\n</li>\n</ol>\n<!-- [原文链接](https://blog.csdn.net/u014753892/article/details/52713841) -->\n\n<p><strong>浏览器 JS 引擎：</strong></p>\n<ol>\n<li>Mozilla: SpiderMonkey、TraceMonkey、JagerMonkey、Rhino</li>\n<li>Google: V8</li>\n<li>Microsoft: chakra、JScript</li>\n<li>Opera: Carakan</li>\n<li>Apple: javaScriptCore</li>\n<li>其他: KJS、Narcissus、Tamarin、Nitro</li>\n</ol>\n<p>最近发布 QuickJS 与 Hermes 也是 JS 引擎，它们都超越了浏览器范畴.</p>\n<h2 id=\"渲染进程及其线程\"><a href=\"#渲染进程及其线程\" class=\"headerlink\" title=\"渲染进程及其线程\"></a>渲染进程及其线程</h2><p>可以这样理解，页面的渲染，JS 的执行，事件的循环，都在这个进程内进行。</p>\n<p><strong>渲染进程是多线程的，有五个线程构成：</strong></p>\n<ol>\n<li><p>GUI 渲染线程</p>\n<ul>\n<li>负责渲染浏览器界面，解析 HTML，CSS，构建 DOM 树和 RenderObject 树，布局和绘制等。</li>\n<li>当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行</li>\n<li>注意，GUI 渲染线程与 JS 引擎线程是互斥的，当 JS 引擎执行时 GUI 线程会被挂起（相当于被冻结了），GUI 更新会被保存在一个队列中等到 JS 引擎空闲时立即执行。</li>\n</ul>\n</li>\n<li><p>JS 引擎线程</p>\n<ul>\n<li>也称为 JS 内核，负责处理 Javascript 脚本程序。（例如 V8 引擎）</li>\n<li>JS 引擎线程负责解析 Javascript 脚本，运行代码。</li>\n<li>JS 引擎一直等待着任务队列中任务的到来，然后加以处理，一个 Tab 页（renderer 进程）中无论什么时候都只有一个 JS 线程在运行 JS 程序</li>\n<li>同样注意，GUI 渲染线程与 JS 引擎线程是互斥的，所以如果 JS 执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。</li>\n</ul>\n</li>\n<li><p>事件触发线程</p>\n<ul>\n<li>归属于浏览器而不是 JS 引擎，用来控制事件循环（可以理解，JS 引擎自己都忙不过来，需要浏览器另开线程协助）</li>\n<li>当 JS 引擎执行代码块如 setTimeOut 时（也可来自浏览器内核的其他线程,如鼠标点击、AJAX 异步请求等），会将对应任务添加到事件线程中</li>\n<li>当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待 JS 引擎的处理</li>\n<li>注意，由于 JS 的单线程关系，所以这些待处理队列中的事件都得排队等待 JS 引擎处理（当 JS 引擎空闲时才会去执行）</li>\n</ul>\n</li>\n<li><p>定时触发器线程</p>\n<ul>\n<li>传说中的 setInterval 与 setTimeout 所在线程</li>\n<li>浏览器定时计数器并不是由 JavaScript 引擎计数的,（因为 JavaScript 引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确）</li>\n<li>因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待 JS 引擎空闲后执行）</li>\n<li>注意，W3C 在 HTML 标准中规定，规定要求 setTimeout 中低于 4ms 的时间间隔算为 4ms。</li>\n</ul>\n</li>\n<li><p>异步 http 请求线程</p>\n<ul>\n<li>在 XMLHttpRequest 在连接后是通过浏览器新开一个线程请求</li>\n<li>将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由 JavaScript 引擎执行。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"相关阅读\"><a href=\"#相关阅读\" class=\"headerlink\" title=\"相关阅读\"></a>相关阅读</h2><p><a href=\"https://juejin.im/post/5a6547d0f265da3e283a1df7\" target=\"_blank\" rel=\"noopener\">浏览器进程</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"浏览器简介\"><a href=\"#浏览器简介\" class=\"headerlink\" title=\"浏览器简介\"></a>浏览器简介</h2><p>目前使用的主流浏览器有五个：Internet Explorer、Firefox、Safari、Chrome 浏览器和 Opera</p>\n<p>浏览器的主要功能就是向服务器发出请求，在浏览器窗口中展示您选择的网络资源。这里所说的资源一般是指 HTML 文档，也可以是 PDF、图片或其他的类型。资源的位置由用户使用 URI（统一资源标示符）指定。</p>\n<p>浏览器解释并显示 HTML 文件的方式是在 HTML 和 CSS 规范中指定的。这些规范由网络标准化组织 W3C（万维网联盟）进行维护</p>\n<h2 id=\"浏览器构成\"><a href=\"#浏览器构成\" class=\"headerlink\" title=\"浏览器构成\"></a>浏览器构成</h2><p><strong>七个部分构成：</strong></p>\n<p><img src=\"/images/browser.png\" alt></p>\n<ul>\n<li><p><strong>用户界面 （User Interface）</strong><br>包括地址栏、前进/后退按钮、书签菜单等。除了浏览器主窗口显示的您请求的页面外，其他显示的各个部分都属于用户界面<br>用户界面主要包括工具栏、地址栏、前进/后退按钮、书签菜单、可视化页面加载进度、智能下载处理、首选项、打印等。除了浏览器主窗口显示请求的页面之外，其他显示的部分都属于用户界面。<br>用户界面还可以与桌面环境集成，以提供浏览器会话管理或与其他桌面应用程序的通信。</p>\n</li>\n<li><p><strong>浏览器引擎 （Browser engine)</strong><br>在用户界面和呈现引擎之间传送指令<br>浏览器引擎是一个可嵌入的组件，其为渲染引擎提供高级接口。<br>浏览器引擎可以加载一个给定的 URI，并支持诸如：前进/后退/重新加载等浏览操作。<br>浏览器引擎提供查看浏览会话的各个方面的挂钩，例如：当前页面加载进度、JavaScript alert。<br>浏览器引擎还允许查询/修改渲染引擎设置。</p>\n</li>\n<li><p><strong>渲染引擎 （Rendering engine)</strong><br>负责显示请求的内容。如果请求的内容是 HTML，它就负责解析 HTML 和 CSS 内容，并将解析后的内容显示在屏幕上<br>渲染引擎为指定的 URI 生成可视化的表示。<br>渲染引擎能够显示 HTML 和 XML 文档，可选择 CSS 样式，以及嵌入式内容（如图片）。<br>渲染引擎能够准确计算页面布局，可使用“回流”算法逐步调整页面元素的位置。<br>渲染引擎内部包含 HTML 解析器。</p>\n</li>\n<li><p><strong>网络 （Networking）</strong><br>用于网络调用，比如 HTTP 请求。其接口与平台无关，并为所有平台提供底层实现。<br>网络系统实现 HTTP 和 FTP 等文件传输协议。 网络系统可以在不同的字符集之间进行转换，为文件解析 MIME 媒体类型。 网络系统可以实现最近检索资源的缓存功能。</p>\n</li>\n<li><p><strong>JavaScript 解释器 （Javascript interpreter)</strong><br>用于解析和执行 JavaScript 代码<br>JavaScript 解释器能够解释并执行嵌入在网页中的 JavaScript（又称 ECMAScript）代码。 为了安全起见，浏览器引擎或渲染引擎可能会禁用某些 JavaScript 功能，如弹出窗口的打开。</p>\n</li>\n<li><p><strong>用户界面后端（UI Backend)</strong><br>用于绘制基本的窗口小部件，比如组合框和窗口。其公开了与平台无关的通用接口，而在底层使用操作系统的用户界面方法。<br>显示后端提供绘图和窗口原语，包括：用户界面控件集合、字体集合。</p>\n</li>\n<li><p><strong>数据存储 （Data Persistence）</strong><br>这是持久层。浏览器需要在硬盘上保存各种数据，例如 Cookie。新的 HTML 规范 (HTML5) 定义了“网络数据库”，这是一个完整（但是轻便）的浏览器内数据库。</p>\n</li>\n</ul>\n<p>数据持久层将与浏览会话相关联的各种数据存储在硬盘上。 这些数据可能是诸如：书签、工具栏设置等这样的高级数据，也可能是诸如：Cookie，安全证书、缓存等这样的低级数据。</p>\n<h2 id=\"浏览器进程\"><a href=\"#浏览器进程\" class=\"headerlink\" title=\"浏览器进程\"></a>浏览器进程</h2><ul>\n<li>浏览器是多进程的</li>\n<li>浏览器之所以能够运行，是因为系统给它的进程分配了资源（cpu、内存）</li>\n<li>简单点理解，每打开一个 Tab 页，就相当于创建了一个独立的浏览器进程</li>\n</ul>\n<p><strong>浏览器包含四个进程：</strong></p>\n<ol>\n<li><p>Browser 进程：浏览器的主进程（负责协调、主控），只有一个。作用有</p>\n<ul>\n<li>负责浏览器界面显示，与用户交互。如前进，后退等</li>\n<li>负责各个页面的管理，创建和销毁其他进程</li>\n<li>将 Renderer 进程得到的内存中的 Bitmap，绘制到用户界面上</li>\n<li>网络资源的管理，下载等</li>\n</ul>\n</li>\n<li><p>第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建</p>\n</li>\n<li><p>GPU 进程：最多一个，用于 3D 绘制等</p>\n</li>\n<li><p>浏览器渲染进程（浏览器内核）（Renderer 进程，内部是多线程的）：默认每个 Tab 页面一个进程，互不影响。主要作用为：</p>\n<ul>\n<li>页面渲染，脚本执行，事件处理等</li>\n</ul>\n</li>\n</ol>\n<p><strong>在浏览器中打开一个网页相当于新起了一个进程（进程内有自己的多线程),打开多个空白标签页后，会发现多个空白标签页被合并成了一个进程</strong></p>\n<h2 id=\"浏览器内核\"><a href=\"#浏览器内核\" class=\"headerlink\" title=\"浏览器内核\"></a>浏览器内核</h2><p>浏览器的内核是分为两个部分的，一是渲染引擎，另一个是 JS 引擎。<br>现在 JS 引擎比较独立，内核更加倾向于说渲染引擎。</p>\n<p><strong>常见的浏览器内核五种：</strong></p>\n<ol>\n<li><p><strong>Trident 内核：</strong> 代表作品是 IE，因 IE 捆绑在 Windows 中，所以占有极高的份额，又称为 IE 内核或 MSHTML，此内核只能用于 Windows 平台，且不是开源的。<br>代表作品还有腾讯、Maxthon（遨游）、360 浏览器等。但由于市场份额比较大，曾经出现脱离了 W3C 标准的时候，同时 IE 版本比较多，存在很多的兼容性问题。</p>\n</li>\n<li><p><strong>Gecko 内核：</strong> 代表作品是 Firefox，即火狐浏览器。因火狐是最多的用户，故常被称为 firefox 内核它是开源的，最大优势是跨平台，在 Microsoft Windows、Linux、MacOs X 等主要操作系统中使用。Mozilla 是网景公司在第一次浏览器大战败给微软之后创建的。有兴趣的同学可以了解一下浏览器大战</p>\n</li>\n<li><p><strong>Webkit 内核：</strong> 代表作品是 Safari、曾经的 Chrome，是开源的项目。</p>\n</li>\n<li><p><strong>Presto 内核：</strong> 代表作品是 Opera，Presto 是由 Opera Software 开发的浏览器排版引擎，它是世界公认最快的渲染速度的引擎。在 13 年之后，Opera 宣布加入谷歌阵营，弃用了 Presto</p>\n</li>\n<li><p><strong>Blink 内核：</strong> 由 Google 和 Opera Software 开发的浏览器排版引擎，2013 年 4 月发布。现在 Chrome 内核是 Blink。谷歌还开发了自己的 JS 引擎，V8，使 JS 运行速度极大地提高了</p>\n</li>\n</ol>\n<!-- [原文链接](https://blog.csdn.net/u014753892/article/details/52713841) -->\n\n<p><strong>浏览器 JS 引擎：</strong></p>\n<ol>\n<li>Mozilla: SpiderMonkey、TraceMonkey、JagerMonkey、Rhino</li>\n<li>Google: V8</li>\n<li>Microsoft: chakra、JScript</li>\n<li>Opera: Carakan</li>\n<li>Apple: javaScriptCore</li>\n<li>其他: KJS、Narcissus、Tamarin、Nitro</li>\n</ol>\n<p>最近发布 QuickJS 与 Hermes 也是 JS 引擎，它们都超越了浏览器范畴.</p>\n<h2 id=\"渲染进程及其线程\"><a href=\"#渲染进程及其线程\" class=\"headerlink\" title=\"渲染进程及其线程\"></a>渲染进程及其线程</h2><p>可以这样理解，页面的渲染，JS 的执行，事件的循环，都在这个进程内进行。</p>\n<p><strong>渲染进程是多线程的，有五个线程构成：</strong></p>\n<ol>\n<li><p>GUI 渲染线程</p>\n<ul>\n<li>负责渲染浏览器界面，解析 HTML，CSS，构建 DOM 树和 RenderObject 树，布局和绘制等。</li>\n<li>当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行</li>\n<li>注意，GUI 渲染线程与 JS 引擎线程是互斥的，当 JS 引擎执行时 GUI 线程会被挂起（相当于被冻结了），GUI 更新会被保存在一个队列中等到 JS 引擎空闲时立即执行。</li>\n</ul>\n</li>\n<li><p>JS 引擎线程</p>\n<ul>\n<li>也称为 JS 内核，负责处理 Javascript 脚本程序。（例如 V8 引擎）</li>\n<li>JS 引擎线程负责解析 Javascript 脚本，运行代码。</li>\n<li>JS 引擎一直等待着任务队列中任务的到来，然后加以处理，一个 Tab 页（renderer 进程）中无论什么时候都只有一个 JS 线程在运行 JS 程序</li>\n<li>同样注意，GUI 渲染线程与 JS 引擎线程是互斥的，所以如果 JS 执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。</li>\n</ul>\n</li>\n<li><p>事件触发线程</p>\n<ul>\n<li>归属于浏览器而不是 JS 引擎，用来控制事件循环（可以理解，JS 引擎自己都忙不过来，需要浏览器另开线程协助）</li>\n<li>当 JS 引擎执行代码块如 setTimeOut 时（也可来自浏览器内核的其他线程,如鼠标点击、AJAX 异步请求等），会将对应任务添加到事件线程中</li>\n<li>当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待 JS 引擎的处理</li>\n<li>注意，由于 JS 的单线程关系，所以这些待处理队列中的事件都得排队等待 JS 引擎处理（当 JS 引擎空闲时才会去执行）</li>\n</ul>\n</li>\n<li><p>定时触发器线程</p>\n<ul>\n<li>传说中的 setInterval 与 setTimeout 所在线程</li>\n<li>浏览器定时计数器并不是由 JavaScript 引擎计数的,（因为 JavaScript 引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确）</li>\n<li>因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待 JS 引擎空闲后执行）</li>\n<li>注意，W3C 在 HTML 标准中规定，规定要求 setTimeout 中低于 4ms 的时间间隔算为 4ms。</li>\n</ul>\n</li>\n<li><p>异步 http 请求线程</p>\n<ul>\n<li>在 XMLHttpRequest 在连接后是通过浏览器新开一个线程请求</li>\n<li>将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由 JavaScript 引擎执行。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"相关阅读\"><a href=\"#相关阅读\" class=\"headerlink\" title=\"相关阅读\"></a>相关阅读</h2><p><a href=\"https://juejin.im/post/5a6547d0f265da3e283a1df7\" target=\"_blank\" rel=\"noopener\">浏览器进程</a></p>\n"},{"layout":"[layout]","title":"Markdown 的基本语法","date":"2020-05-21T06:34:16.000Z","_content":"\n\n## Markdown\n\nMarkdown 是一种标记语言，语法简单，易阅读易编写，可以让用户完全脱离鼠标写出样式丰富的文档，广受程序员喜爱，目前许多网站都已经支持通过 Markdown 语法来写文章或者发表评论。\n\n## 标题\n\n在想要设置为标题的文字前面加#来表示\n一个#是一级标题，二个#是二级标题，以此类推。支持六级标题。\n**注：标准语法：#后跟个空格再写文字**\n\n```\n# 这是一级标题  h1\n## 这是二级标题  h2\n### 这是三级标题  h3\n#### 这是四级标题  h4\n##### 这是五级标题  h5\n###### 这是六级标题  h6\n\n```\n\n## 段落\n\n一行文字就是一个段落，如果需要另起一段，在两个段落之间隔一个空行。\n\n渲染为：`<p>一行文字就是一个段落，如果需要另起一段，在两个段落之间隔一个空行。</p>`\n\n## 粗体、斜体、删除线\n\n斜体：文字两边加\\* 或者\\_\n粗体：文字两边加**\n斜体+粗体：文字两边加\\***\n删除线：文字两边加入~~\n\n```\n  *我是斜体*\n  **我是粗体**\n  ***我是斜体+粗体***\n  ~~我是删除线~~\n```\n\n_我是斜体_\n**我是粗体**\n**_我是斜体+粗体_**\n~~我是删除线~~\n\n## 超链接\n\n写法一：`[链接名](链接地址)`\n写法二：`[链接名][link]`，要定义 `[link]: http:google.com`\n\n```\n[linkName](http://example.com/) [链接命](链接路径)\n[linkName](http://example.com/ \"Title\")[链接名](链接地址 \"title属性\")\n```\n\n[我是 google](http://google.com/)\n[我是 google](http://google.com/ \"google\")\n\n## 图片\n\n```\n![alt 描述](图片地址 \"titles属性\")\n```\n\n## 有序列表、无序列表、子列表\n\n有序列表：用阿拉伯数字`1. 2. 3.`\n无序列表：使用+、-或\\*\n子列表：缩进四个空格\n\n**注意：文字与前面有一个空格**\n\n```\n1. 第一项\n2. 第二项\n3. 第三项\n```\n\n1. 第一项\n2. 第二项\n3. 第三项\n\n```\n- 第一项\n- 第二项\n- 第三项\n```\n\n- 第一项\n- 第二项\n- 第三项\n\n## 水平线\n\n使用至少 3 个\\*或-表示水平线\n\n```\n* * *\n***\n*****\n- - -\n---\n```\n\n---\n\n## 引用\n\n通过在行首加上大于号>来添加引用格式，多个>就是嵌套引用\n\n```\n> 我是引用示例1\n>> 我是引用示例2\n```\n\n> 我是引用示例 1\n\n> > 我是引用示例 2\n\n## 代码、代码块\n\n代码：两边加一个 `\n代码块：头尾加三个 ```\n","source":"_posts/2020/05/21/markdown.md","raw":"---\nlayout: '[layout]'\ntitle: Markdown 的基本语法\ntags:\n  - Markdown\ncategories:\n  - 前端\ndate: 2020-05-21 14:34:16\n---\n\n\n## Markdown\n\nMarkdown 是一种标记语言，语法简单，易阅读易编写，可以让用户完全脱离鼠标写出样式丰富的文档，广受程序员喜爱，目前许多网站都已经支持通过 Markdown 语法来写文章或者发表评论。\n\n## 标题\n\n在想要设置为标题的文字前面加#来表示\n一个#是一级标题，二个#是二级标题，以此类推。支持六级标题。\n**注：标准语法：#后跟个空格再写文字**\n\n```\n# 这是一级标题  h1\n## 这是二级标题  h2\n### 这是三级标题  h3\n#### 这是四级标题  h4\n##### 这是五级标题  h5\n###### 这是六级标题  h6\n\n```\n\n## 段落\n\n一行文字就是一个段落，如果需要另起一段，在两个段落之间隔一个空行。\n\n渲染为：`<p>一行文字就是一个段落，如果需要另起一段，在两个段落之间隔一个空行。</p>`\n\n## 粗体、斜体、删除线\n\n斜体：文字两边加\\* 或者\\_\n粗体：文字两边加**\n斜体+粗体：文字两边加\\***\n删除线：文字两边加入~~\n\n```\n  *我是斜体*\n  **我是粗体**\n  ***我是斜体+粗体***\n  ~~我是删除线~~\n```\n\n_我是斜体_\n**我是粗体**\n**_我是斜体+粗体_**\n~~我是删除线~~\n\n## 超链接\n\n写法一：`[链接名](链接地址)`\n写法二：`[链接名][link]`，要定义 `[link]: http:google.com`\n\n```\n[linkName](http://example.com/) [链接命](链接路径)\n[linkName](http://example.com/ \"Title\")[链接名](链接地址 \"title属性\")\n```\n\n[我是 google](http://google.com/)\n[我是 google](http://google.com/ \"google\")\n\n## 图片\n\n```\n![alt 描述](图片地址 \"titles属性\")\n```\n\n## 有序列表、无序列表、子列表\n\n有序列表：用阿拉伯数字`1. 2. 3.`\n无序列表：使用+、-或\\*\n子列表：缩进四个空格\n\n**注意：文字与前面有一个空格**\n\n```\n1. 第一项\n2. 第二项\n3. 第三项\n```\n\n1. 第一项\n2. 第二项\n3. 第三项\n\n```\n- 第一项\n- 第二项\n- 第三项\n```\n\n- 第一项\n- 第二项\n- 第三项\n\n## 水平线\n\n使用至少 3 个\\*或-表示水平线\n\n```\n* * *\n***\n*****\n- - -\n---\n```\n\n---\n\n## 引用\n\n通过在行首加上大于号>来添加引用格式，多个>就是嵌套引用\n\n```\n> 我是引用示例1\n>> 我是引用示例2\n```\n\n> 我是引用示例 1\n\n> > 我是引用示例 2\n\n## 代码、代码块\n\n代码：两边加一个 `\n代码块：头尾加三个 ```\n","slug":"markdown","published":1,"updated":"2020-05-21T06:34:16.305Z","comments":1,"photos":[],"link":"","_id":"ckb1z4djf00289n94ir0dl2nu","content":"<h2 id=\"Markdown\"><a href=\"#Markdown\" class=\"headerlink\" title=\"Markdown\"></a>Markdown</h2><p>Markdown 是一种标记语言，语法简单，易阅读易编写，可以让用户完全脱离鼠标写出样式丰富的文档，广受程序员喜爱，目前许多网站都已经支持通过 Markdown 语法来写文章或者发表评论。</p>\n<h2 id=\"标题\"><a href=\"#标题\" class=\"headerlink\" title=\"标题\"></a>标题</h2><p>在想要设置为标题的文字前面加#来表示<br>一个#是一级标题，二个#是二级标题，以此类推。支持六级标题。<br><strong>注：标准语法：#后跟个空格再写文字</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 这是一级标题  h1</span><br><span class=\"line\">## 这是二级标题  h2</span><br><span class=\"line\">### 这是三级标题  h3</span><br><span class=\"line\">#### 这是四级标题  h4</span><br><span class=\"line\">##### 这是五级标题  h5</span><br><span class=\"line\">###### 这是六级标题  h6</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"段落\"><a href=\"#段落\" class=\"headerlink\" title=\"段落\"></a>段落</h2><p>一行文字就是一个段落，如果需要另起一段，在两个段落之间隔一个空行。</p>\n<p>渲染为：<code>&lt;p&gt;一行文字就是一个段落，如果需要另起一段，在两个段落之间隔一个空行。&lt;/p&gt;</code></p>\n<h2 id=\"粗体、斜体、删除线\"><a href=\"#粗体、斜体、删除线\" class=\"headerlink\" title=\"粗体、斜体、删除线\"></a>粗体、斜体、删除线</h2><p>斜体：文字两边加* 或者_<br>粗体：文字两边加**<br>斜体+粗体：文字两边加***<br>删除线：文字两边加入~~</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*我是斜体*</span><br><span class=\"line\">**我是粗体**</span><br><span class=\"line\">***我是斜体+粗体***</span><br><span class=\"line\">~~我是删除线~~</span><br></pre></td></tr></table></figure>\n\n<p><em>我是斜体</em><br><strong>我是粗体</strong><br><strong><em>我是斜体+粗体</em></strong><br><del>我是删除线</del></p>\n<h2 id=\"超链接\"><a href=\"#超链接\" class=\"headerlink\" title=\"超链接\"></a>超链接</h2><p>写法一：<code>[链接名](链接地址)</code><br>写法二：<code>[链接名][link]</code>，要定义 <code>[link]: http:google.com</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[linkName](http://example.com/) [链接命](链接路径)</span><br><span class=\"line\">[linkName](http://example.com/ &quot;Title&quot;)[链接名](链接地址 &quot;title属性&quot;)</span><br></pre></td></tr></table></figure>\n\n<p><a href=\"http://google.com/\" target=\"_blank\" rel=\"noopener\">我是 google</a><br><a href=\"http://google.com/\" title=\"google\" target=\"_blank\" rel=\"noopener\">我是 google</a></p>\n<h2 id=\"图片\"><a href=\"#图片\" class=\"headerlink\" title=\"图片\"></a>图片</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">![alt 描述](图片地址 &quot;titles属性&quot;)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"有序列表、无序列表、子列表\"><a href=\"#有序列表、无序列表、子列表\" class=\"headerlink\" title=\"有序列表、无序列表、子列表\"></a>有序列表、无序列表、子列表</h2><p>有序列表：用阿拉伯数字<code>1. 2. 3.</code><br>无序列表：使用+、-或*<br>子列表：缩进四个空格</p>\n<p><strong>注意：文字与前面有一个空格</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 第一项</span><br><span class=\"line\">2. 第二项</span><br><span class=\"line\">3. 第三项</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>第一项</li>\n<li>第二项</li>\n<li>第三项</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- 第一项</span><br><span class=\"line\">- 第二项</span><br><span class=\"line\">- 第三项</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>第一项</li>\n<li>第二项</li>\n<li>第三项</li>\n</ul>\n<h2 id=\"水平线\"><a href=\"#水平线\" class=\"headerlink\" title=\"水平线\"></a>水平线</h2><p>使用至少 3 个*或-表示水平线</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* * *</span><br><span class=\"line\">***</span><br><span class=\"line\">*****</span><br><span class=\"line\">- - -</span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h2><p>通过在行首加上大于号&gt;来添加引用格式，多个&gt;就是嵌套引用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; 我是引用示例1</span><br><span class=\"line\">&gt;&gt; 我是引用示例2</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>我是引用示例 1</p>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>我是引用示例 2</p>\n</blockquote>\n</blockquote>\n<h2 id=\"代码、代码块\"><a href=\"#代码、代码块\" class=\"headerlink\" title=\"代码、代码块\"></a>代码、代码块</h2><p>代码：两边加一个 `<br>代码块：头尾加三个 ```</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Markdown\"><a href=\"#Markdown\" class=\"headerlink\" title=\"Markdown\"></a>Markdown</h2><p>Markdown 是一种标记语言，语法简单，易阅读易编写，可以让用户完全脱离鼠标写出样式丰富的文档，广受程序员喜爱，目前许多网站都已经支持通过 Markdown 语法来写文章或者发表评论。</p>\n<h2 id=\"标题\"><a href=\"#标题\" class=\"headerlink\" title=\"标题\"></a>标题</h2><p>在想要设置为标题的文字前面加#来表示<br>一个#是一级标题，二个#是二级标题，以此类推。支持六级标题。<br><strong>注：标准语法：#后跟个空格再写文字</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 这是一级标题  h1</span><br><span class=\"line\">## 这是二级标题  h2</span><br><span class=\"line\">### 这是三级标题  h3</span><br><span class=\"line\">#### 这是四级标题  h4</span><br><span class=\"line\">##### 这是五级标题  h5</span><br><span class=\"line\">###### 这是六级标题  h6</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"段落\"><a href=\"#段落\" class=\"headerlink\" title=\"段落\"></a>段落</h2><p>一行文字就是一个段落，如果需要另起一段，在两个段落之间隔一个空行。</p>\n<p>渲染为：<code>&lt;p&gt;一行文字就是一个段落，如果需要另起一段，在两个段落之间隔一个空行。&lt;/p&gt;</code></p>\n<h2 id=\"粗体、斜体、删除线\"><a href=\"#粗体、斜体、删除线\" class=\"headerlink\" title=\"粗体、斜体、删除线\"></a>粗体、斜体、删除线</h2><p>斜体：文字两边加* 或者_<br>粗体：文字两边加**<br>斜体+粗体：文字两边加***<br>删除线：文字两边加入~~</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*我是斜体*</span><br><span class=\"line\">**我是粗体**</span><br><span class=\"line\">***我是斜体+粗体***</span><br><span class=\"line\">~~我是删除线~~</span><br></pre></td></tr></table></figure>\n\n<p><em>我是斜体</em><br><strong>我是粗体</strong><br><strong><em>我是斜体+粗体</em></strong><br><del>我是删除线</del></p>\n<h2 id=\"超链接\"><a href=\"#超链接\" class=\"headerlink\" title=\"超链接\"></a>超链接</h2><p>写法一：<code>[链接名](链接地址)</code><br>写法二：<code>[链接名][link]</code>，要定义 <code>[link]: http:google.com</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[linkName](http://example.com/) [链接命](链接路径)</span><br><span class=\"line\">[linkName](http://example.com/ &quot;Title&quot;)[链接名](链接地址 &quot;title属性&quot;)</span><br></pre></td></tr></table></figure>\n\n<p><a href=\"http://google.com/\" target=\"_blank\" rel=\"noopener\">我是 google</a><br><a href=\"http://google.com/\" title=\"google\" target=\"_blank\" rel=\"noopener\">我是 google</a></p>\n<h2 id=\"图片\"><a href=\"#图片\" class=\"headerlink\" title=\"图片\"></a>图片</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">![alt 描述](图片地址 &quot;titles属性&quot;)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"有序列表、无序列表、子列表\"><a href=\"#有序列表、无序列表、子列表\" class=\"headerlink\" title=\"有序列表、无序列表、子列表\"></a>有序列表、无序列表、子列表</h2><p>有序列表：用阿拉伯数字<code>1. 2. 3.</code><br>无序列表：使用+、-或*<br>子列表：缩进四个空格</p>\n<p><strong>注意：文字与前面有一个空格</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 第一项</span><br><span class=\"line\">2. 第二项</span><br><span class=\"line\">3. 第三项</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>第一项</li>\n<li>第二项</li>\n<li>第三项</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- 第一项</span><br><span class=\"line\">- 第二项</span><br><span class=\"line\">- 第三项</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>第一项</li>\n<li>第二项</li>\n<li>第三项</li>\n</ul>\n<h2 id=\"水平线\"><a href=\"#水平线\" class=\"headerlink\" title=\"水平线\"></a>水平线</h2><p>使用至少 3 个*或-表示水平线</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* * *</span><br><span class=\"line\">***</span><br><span class=\"line\">*****</span><br><span class=\"line\">- - -</span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h2><p>通过在行首加上大于号&gt;来添加引用格式，多个&gt;就是嵌套引用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; 我是引用示例1</span><br><span class=\"line\">&gt;&gt; 我是引用示例2</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>我是引用示例 1</p>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>我是引用示例 2</p>\n</blockquote>\n</blockquote>\n<h2 id=\"代码、代码块\"><a href=\"#代码、代码块\" class=\"headerlink\" title=\"代码、代码块\"></a>代码、代码块</h2><p>代码：两边加一个 `<br>代码块：头尾加三个 ```</p>\n"},{"title":"执行上下文和执行栈","date":"2020-06-05T07:34:34.000Z","_content":"\n\n<!-- JavaScript 运行三部曲\n\n1. 语法分析\n2. 预编译\n3. 解释执行 -->\n\n## 相关概念\n\n1. EC: 执行上下文 // execution context\n2. ECS: 执行环境栈 // execution context stack\n3. VO： 变量对象 // variable object\n4. AO： 活动对象 // active object\n5. scope chain：作用域链\n\n## 执行上下文\n\n简而言之，执行上下文是评估和执行 JavaScript 代码的环境的抽象概念。\n\n每当 Javascript 代码在运行的时候，它都是在执行上下文中运行。\n\n创建执行上下文时与之关联的会有一个变量对象，该上下文中的所有变量和函数全都保存在这个对象中。\n\n### 三种类型\n\n1. 全局执行上下文： 这是默认或者说基础的上下文，任何不在函数内部的代码都在全局上下文中。它会执行两件事：创建一个全局的 window 对象（浏览器的情况下），并且设置 this 的值等于这个全局对象。一个程序中只会有一个全局执行上下文。\n\n2. 函数执行上下文： 每当一个函数被调用时, 都会为该函数创建一个新的上下文。每个函数都有它自己的执行上下文，不过是在函数被调用时创建的。函数上下文可以有任意多个。每当一个新的执行上下文被创建，它会按定义的顺序（将在后文讨论）执行一系列步骤。\n\n3. Eval 函数执行上下文： 执行在 eval 函数内部的代码也会有它属于自己的执行上下文，但由于 JavaScript 开发者并不经常使用 eval，所以在这里我不会讨论它。\n\n<!-- 不同执行上下文变量对象略有不同：\n\n全局上下文中的变量对象就是全局对象，允许通过变量对象的属性名来间接访问。\n函数上下文中用活动对象来表示变量对象，通过函数的 arguments 属性初始化。 -->\n\n### 生命周期的三个阶段\n\n**创建阶段:**\n\n执行上下文也可以抽象理解为一个对象，这个对象都有三个属性：\n变量对象(variable object)、作用域链(scope chain)、this 指针(this value)。\n\n```\nconst execContant = {\n    VO | AO: 全局上下文为 VO,函数上下文为 AO,\n    Scope: 作用域链,\n    this: this 指向\n}\n```\n\n创建阶段相当于 new 一个对象\n\n当函数被调用，但未执行任何其内部代码之前，会做以下三件事：\n\n1. 创建变量对象：首先初始化函数的参数 arguments，提升函数声明和变量声明。\n2. 创建作用域链（Scope Chain）：在执行期上下文的创建阶段，作用域链是在变量对象之后创建的。，作用域链本身包含变量对象。作用域链用于解析变量。当被要求解析变量时，JavaScript 始终从代码嵌套的最内层开始，如果最内层没有找到变量，就会跳转到上一层父作用域中查找，直到找到该变量。\n   函数的作用域在函数定义的时候就决定，这是因为函数有一个内部属性 [[scope]]，当函数创建的时候，就会保存所有父变量对象到其中，你可以理解 [[scope]] 就是所有父变量对象的层级链，但是注意：[[scope]] 并不代表完整的作用域链！\n3. 确定 this 指向：包括多种情况,后续文章讲解\n\n在一段 JS 脚本执行之前，要先解析代码（所以说 JS 是解释执行的脚本语言），解析的时候会先创建一个全局执行上下文环境，先把代码中即将执行的变量、函数声明都拿出来。变量先暂时赋值为 undefined，函数则先声明好可使用。这一步做完了，然后再开始正式执行程序。\n\n另外，一个函数在执行之前，也会创建一个函数执行上下文环境，跟全局上下文差不多，不过 函数执行上下文中会多出 this arguments 和函数的参数。\n\n**代码执行阶段** 执行上下文入栈，变量对象添加形参，变量声明，函数引用，执行其他代码\n**回收阶段**: 执行上下文出栈，等待虚拟机回收执行上下文，变量回收\n\n## 执行栈\n\n执行栈，也就是在其它编程语言中所说的“调用栈”，是一种拥有 LIFO（后进先出）数据结构的栈，被用来存储代码运行时创建的所有执行上下文。\n\n当 JavaScript 引擎第一次遇到你的脚本时，它会创建一个全局的执行上下文并且压入当前执行栈。每当引擎遇到一个函数调用，它会为该函数创建一个新的执行上下文并压入栈的顶部。\n\n引擎会执行那些执行上下文位于栈顶的函数。当该函数执行结束时，执行上下文从栈中弹出，控制流程到达当前栈中的下一个上下文。\n\n## 执行过程\n\n```\nvar scope = \"global scope\";\nfunction checkscope(){\n    var scope = \"local scope\";\n    function f(){\n        return scope;\n    }\n    return f();\n}\ncheckscope();\n```\n\n1. 执行全局代码，创建全局执行上下文，全局上下文被压入执行上下文栈\n\n```\n ECStack = [\n    globalContext\n];\n```\n\n2. 全局上下文初始化\n\n```\nglobalContext = {\n    VO: [global],\n    Scope: [globalContext.VO],\n    this: globalContext.VO\n}\n```\n\n初始化的同时，checkscope 函数被创建，保存作用域链到函数的内部属性[[scope]]\n\n```\ncheckscope.[[scope]] = [\n    globalContext.VO\n];\n```\n\n3. 执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 函数执行上下文被压入执行上下文栈\n\n```\nECStack = [\n    checkscopeContext,\n    globalContext\n];\n```\n\n4. checkscope 函数执行上下文初始化：\n\n   - 复制函数 [[scope]] 属性创建作用域链，\n   - 用 arguments 创建活动对象，\n   - 初始化活动对象，即加入形参、函数声明、变量声明，\n   - 将活动对象压入 checkscope 作用域链顶端。\n\n同时 f 函数被创建，保存作用域链到 f 函数的内部属性[[scope]]\n\n```\ncheckscopeContext = {\n    AO: {\n        arguments: {\n            length: 0\n        },\n        scope: undefined,\n        f: reference to function f(){}\n    },\n    Scope: [AO, globalContext.VO],\n    this: undefined\n}\n```\n\n5. 执行 f 函数，创建 f 函数执行上下文，f 函数执行上下文被压入执行上下文栈\n\n```\n ECStack = [\n    fContext,\n    checkscopeContext,\n    globalContext\n];\n```\n\n6. f 函数执行上下文初始化, 以下跟第 4 步相同：\n   - 复制函数 [[scope]] 属性创建作用域链\n   - 用 arguments 创建活动对象\n   - 初始化活动对象，即加入形参、函数声明、变量声明\n   - 将活动对象压入 f 作用域链顶端\n\n```\n fContext = {\n    AO: {\n        arguments: {\n            length: 0\n        }\n    },\n    Scope: [AO, checkscopeContext.AO, globalContext.VO],\n    this: undefined\n}\n```\n\n7. f 函数执行，沿着作用域链查找 scope 值，返回 scope 值\n8. f 函数执行完毕，f 函数上下文从执行上下文栈中弹出\n\n```\n ECStack = [\n    checkscopeContext,\n    globalContext\n];\n```\n\n9. checkscope 函数执行完毕，checkscope 执行上下文从执行上下文栈中弹出\n\n```\n ECStack = [\n    globalContext\n];\n```\n\n## 相关阅读\n\n[执行上下文](https://juejin.im/post/5ba32171f265da0ab719a6d7)\n[执行上下文之详细的执行过程](https://github.com/mqyqingfeng/Blog/issues/8)\n[作用域连](https://github.com/mqyqingfeng/Blog/issues/6)\n\n<!-- [预编译](https://segmentfault.com/a/1190000018001871) -->\n<!-- [执行上下文](https://juejin.im/post/5a9e5b9ef265da239235dc9f) -->\n","source":"_posts/2020/06/05/执行上下文.md","raw":"---\ntitle: 执行上下文和执行栈\ndate: 2020-06-05 15:34:34\ncategories:\ntags:\n---\n\n\n<!-- JavaScript 运行三部曲\n\n1. 语法分析\n2. 预编译\n3. 解释执行 -->\n\n## 相关概念\n\n1. EC: 执行上下文 // execution context\n2. ECS: 执行环境栈 // execution context stack\n3. VO： 变量对象 // variable object\n4. AO： 活动对象 // active object\n5. scope chain：作用域链\n\n## 执行上下文\n\n简而言之，执行上下文是评估和执行 JavaScript 代码的环境的抽象概念。\n\n每当 Javascript 代码在运行的时候，它都是在执行上下文中运行。\n\n创建执行上下文时与之关联的会有一个变量对象，该上下文中的所有变量和函数全都保存在这个对象中。\n\n### 三种类型\n\n1. 全局执行上下文： 这是默认或者说基础的上下文，任何不在函数内部的代码都在全局上下文中。它会执行两件事：创建一个全局的 window 对象（浏览器的情况下），并且设置 this 的值等于这个全局对象。一个程序中只会有一个全局执行上下文。\n\n2. 函数执行上下文： 每当一个函数被调用时, 都会为该函数创建一个新的上下文。每个函数都有它自己的执行上下文，不过是在函数被调用时创建的。函数上下文可以有任意多个。每当一个新的执行上下文被创建，它会按定义的顺序（将在后文讨论）执行一系列步骤。\n\n3. Eval 函数执行上下文： 执行在 eval 函数内部的代码也会有它属于自己的执行上下文，但由于 JavaScript 开发者并不经常使用 eval，所以在这里我不会讨论它。\n\n<!-- 不同执行上下文变量对象略有不同：\n\n全局上下文中的变量对象就是全局对象，允许通过变量对象的属性名来间接访问。\n函数上下文中用活动对象来表示变量对象，通过函数的 arguments 属性初始化。 -->\n\n### 生命周期的三个阶段\n\n**创建阶段:**\n\n执行上下文也可以抽象理解为一个对象，这个对象都有三个属性：\n变量对象(variable object)、作用域链(scope chain)、this 指针(this value)。\n\n```\nconst execContant = {\n    VO | AO: 全局上下文为 VO,函数上下文为 AO,\n    Scope: 作用域链,\n    this: this 指向\n}\n```\n\n创建阶段相当于 new 一个对象\n\n当函数被调用，但未执行任何其内部代码之前，会做以下三件事：\n\n1. 创建变量对象：首先初始化函数的参数 arguments，提升函数声明和变量声明。\n2. 创建作用域链（Scope Chain）：在执行期上下文的创建阶段，作用域链是在变量对象之后创建的。，作用域链本身包含变量对象。作用域链用于解析变量。当被要求解析变量时，JavaScript 始终从代码嵌套的最内层开始，如果最内层没有找到变量，就会跳转到上一层父作用域中查找，直到找到该变量。\n   函数的作用域在函数定义的时候就决定，这是因为函数有一个内部属性 [[scope]]，当函数创建的时候，就会保存所有父变量对象到其中，你可以理解 [[scope]] 就是所有父变量对象的层级链，但是注意：[[scope]] 并不代表完整的作用域链！\n3. 确定 this 指向：包括多种情况,后续文章讲解\n\n在一段 JS 脚本执行之前，要先解析代码（所以说 JS 是解释执行的脚本语言），解析的时候会先创建一个全局执行上下文环境，先把代码中即将执行的变量、函数声明都拿出来。变量先暂时赋值为 undefined，函数则先声明好可使用。这一步做完了，然后再开始正式执行程序。\n\n另外，一个函数在执行之前，也会创建一个函数执行上下文环境，跟全局上下文差不多，不过 函数执行上下文中会多出 this arguments 和函数的参数。\n\n**代码执行阶段** 执行上下文入栈，变量对象添加形参，变量声明，函数引用，执行其他代码\n**回收阶段**: 执行上下文出栈，等待虚拟机回收执行上下文，变量回收\n\n## 执行栈\n\n执行栈，也就是在其它编程语言中所说的“调用栈”，是一种拥有 LIFO（后进先出）数据结构的栈，被用来存储代码运行时创建的所有执行上下文。\n\n当 JavaScript 引擎第一次遇到你的脚本时，它会创建一个全局的执行上下文并且压入当前执行栈。每当引擎遇到一个函数调用，它会为该函数创建一个新的执行上下文并压入栈的顶部。\n\n引擎会执行那些执行上下文位于栈顶的函数。当该函数执行结束时，执行上下文从栈中弹出，控制流程到达当前栈中的下一个上下文。\n\n## 执行过程\n\n```\nvar scope = \"global scope\";\nfunction checkscope(){\n    var scope = \"local scope\";\n    function f(){\n        return scope;\n    }\n    return f();\n}\ncheckscope();\n```\n\n1. 执行全局代码，创建全局执行上下文，全局上下文被压入执行上下文栈\n\n```\n ECStack = [\n    globalContext\n];\n```\n\n2. 全局上下文初始化\n\n```\nglobalContext = {\n    VO: [global],\n    Scope: [globalContext.VO],\n    this: globalContext.VO\n}\n```\n\n初始化的同时，checkscope 函数被创建，保存作用域链到函数的内部属性[[scope]]\n\n```\ncheckscope.[[scope]] = [\n    globalContext.VO\n];\n```\n\n3. 执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 函数执行上下文被压入执行上下文栈\n\n```\nECStack = [\n    checkscopeContext,\n    globalContext\n];\n```\n\n4. checkscope 函数执行上下文初始化：\n\n   - 复制函数 [[scope]] 属性创建作用域链，\n   - 用 arguments 创建活动对象，\n   - 初始化活动对象，即加入形参、函数声明、变量声明，\n   - 将活动对象压入 checkscope 作用域链顶端。\n\n同时 f 函数被创建，保存作用域链到 f 函数的内部属性[[scope]]\n\n```\ncheckscopeContext = {\n    AO: {\n        arguments: {\n            length: 0\n        },\n        scope: undefined,\n        f: reference to function f(){}\n    },\n    Scope: [AO, globalContext.VO],\n    this: undefined\n}\n```\n\n5. 执行 f 函数，创建 f 函数执行上下文，f 函数执行上下文被压入执行上下文栈\n\n```\n ECStack = [\n    fContext,\n    checkscopeContext,\n    globalContext\n];\n```\n\n6. f 函数执行上下文初始化, 以下跟第 4 步相同：\n   - 复制函数 [[scope]] 属性创建作用域链\n   - 用 arguments 创建活动对象\n   - 初始化活动对象，即加入形参、函数声明、变量声明\n   - 将活动对象压入 f 作用域链顶端\n\n```\n fContext = {\n    AO: {\n        arguments: {\n            length: 0\n        }\n    },\n    Scope: [AO, checkscopeContext.AO, globalContext.VO],\n    this: undefined\n}\n```\n\n7. f 函数执行，沿着作用域链查找 scope 值，返回 scope 值\n8. f 函数执行完毕，f 函数上下文从执行上下文栈中弹出\n\n```\n ECStack = [\n    checkscopeContext,\n    globalContext\n];\n```\n\n9. checkscope 函数执行完毕，checkscope 执行上下文从执行上下文栈中弹出\n\n```\n ECStack = [\n    globalContext\n];\n```\n\n## 相关阅读\n\n[执行上下文](https://juejin.im/post/5ba32171f265da0ab719a6d7)\n[执行上下文之详细的执行过程](https://github.com/mqyqingfeng/Blog/issues/8)\n[作用域连](https://github.com/mqyqingfeng/Blog/issues/6)\n\n<!-- [预编译](https://segmentfault.com/a/1190000018001871) -->\n<!-- [执行上下文](https://juejin.im/post/5a9e5b9ef265da239235dc9f) -->\n","slug":"执行上下文","published":1,"updated":"2020-06-05T07:34:34.102Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckb1z4djg002a9n94t6sjt48u","content":"<!-- JavaScript 运行三部曲\n\n1. 语法分析\n2. 预编译\n3. 解释执行 -->\n\n<h2 id=\"相关概念\"><a href=\"#相关概念\" class=\"headerlink\" title=\"相关概念\"></a>相关概念</h2><ol>\n<li>EC: 执行上下文 // execution context</li>\n<li>ECS: 执行环境栈 // execution context stack</li>\n<li>VO： 变量对象 // variable object</li>\n<li>AO： 活动对象 // active object</li>\n<li>scope chain：作用域链</li>\n</ol>\n<h2 id=\"执行上下文\"><a href=\"#执行上下文\" class=\"headerlink\" title=\"执行上下文\"></a>执行上下文</h2><p>简而言之，执行上下文是评估和执行 JavaScript 代码的环境的抽象概念。</p>\n<p>每当 Javascript 代码在运行的时候，它都是在执行上下文中运行。</p>\n<p>创建执行上下文时与之关联的会有一个变量对象，该上下文中的所有变量和函数全都保存在这个对象中。</p>\n<h3 id=\"三种类型\"><a href=\"#三种类型\" class=\"headerlink\" title=\"三种类型\"></a>三种类型</h3><ol>\n<li><p>全局执行上下文： 这是默认或者说基础的上下文，任何不在函数内部的代码都在全局上下文中。它会执行两件事：创建一个全局的 window 对象（浏览器的情况下），并且设置 this 的值等于这个全局对象。一个程序中只会有一个全局执行上下文。</p>\n</li>\n<li><p>函数执行上下文： 每当一个函数被调用时, 都会为该函数创建一个新的上下文。每个函数都有它自己的执行上下文，不过是在函数被调用时创建的。函数上下文可以有任意多个。每当一个新的执行上下文被创建，它会按定义的顺序（将在后文讨论）执行一系列步骤。</p>\n</li>\n<li><p>Eval 函数执行上下文： 执行在 eval 函数内部的代码也会有它属于自己的执行上下文，但由于 JavaScript 开发者并不经常使用 eval，所以在这里我不会讨论它。</p>\n</li>\n</ol>\n<!-- 不同执行上下文变量对象略有不同：\n\n全局上下文中的变量对象就是全局对象，允许通过变量对象的属性名来间接访问。\n函数上下文中用活动对象来表示变量对象，通过函数的 arguments 属性初始化。 -->\n\n<h3 id=\"生命周期的三个阶段\"><a href=\"#生命周期的三个阶段\" class=\"headerlink\" title=\"生命周期的三个阶段\"></a>生命周期的三个阶段</h3><p><strong>创建阶段:</strong></p>\n<p>执行上下文也可以抽象理解为一个对象，这个对象都有三个属性：<br>变量对象(variable object)、作用域链(scope chain)、this 指针(this value)。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const execContant = &#123;</span><br><span class=\"line\">    VO | AO: 全局上下文为 VO,函数上下文为 AO,</span><br><span class=\"line\">    Scope: 作用域链,</span><br><span class=\"line\">    this: this 指向</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>创建阶段相当于 new 一个对象</p>\n<p>当函数被调用，但未执行任何其内部代码之前，会做以下三件事：</p>\n<ol>\n<li>创建变量对象：首先初始化函数的参数 arguments，提升函数声明和变量声明。</li>\n<li>创建作用域链（Scope Chain）：在执行期上下文的创建阶段，作用域链是在变量对象之后创建的。，作用域链本身包含变量对象。作用域链用于解析变量。当被要求解析变量时，JavaScript 始终从代码嵌套的最内层开始，如果最内层没有找到变量，就会跳转到上一层父作用域中查找，直到找到该变量。<br>函数的作用域在函数定义的时候就决定，这是因为函数有一个内部属性 [[scope]]，当函数创建的时候，就会保存所有父变量对象到其中，你可以理解 [[scope]] 就是所有父变量对象的层级链，但是注意：[[scope]] 并不代表完整的作用域链！</li>\n<li>确定 this 指向：包括多种情况,后续文章讲解</li>\n</ol>\n<p>在一段 JS 脚本执行之前，要先解析代码（所以说 JS 是解释执行的脚本语言），解析的时候会先创建一个全局执行上下文环境，先把代码中即将执行的变量、函数声明都拿出来。变量先暂时赋值为 undefined，函数则先声明好可使用。这一步做完了，然后再开始正式执行程序。</p>\n<p>另外，一个函数在执行之前，也会创建一个函数执行上下文环境，跟全局上下文差不多，不过 函数执行上下文中会多出 this arguments 和函数的参数。</p>\n<p><strong>代码执行阶段</strong> 执行上下文入栈，变量对象添加形参，变量声明，函数引用，执行其他代码<br><strong>回收阶段</strong>: 执行上下文出栈，等待虚拟机回收执行上下文，变量回收</p>\n<h2 id=\"执行栈\"><a href=\"#执行栈\" class=\"headerlink\" title=\"执行栈\"></a>执行栈</h2><p>执行栈，也就是在其它编程语言中所说的“调用栈”，是一种拥有 LIFO（后进先出）数据结构的栈，被用来存储代码运行时创建的所有执行上下文。</p>\n<p>当 JavaScript 引擎第一次遇到你的脚本时，它会创建一个全局的执行上下文并且压入当前执行栈。每当引擎遇到一个函数调用，它会为该函数创建一个新的执行上下文并压入栈的顶部。</p>\n<p>引擎会执行那些执行上下文位于栈顶的函数。当该函数执行结束时，执行上下文从栈中弹出，控制流程到达当前栈中的下一个上下文。</p>\n<h2 id=\"执行过程\"><a href=\"#执行过程\" class=\"headerlink\" title=\"执行过程\"></a>执行过程</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var scope = &quot;global scope&quot;;</span><br><span class=\"line\">function checkscope()&#123;</span><br><span class=\"line\">    var scope = &quot;local scope&quot;;</span><br><span class=\"line\">    function f()&#123;</span><br><span class=\"line\">        return scope;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return f();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">checkscope();</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>执行全局代码，创建全局执行上下文，全局上下文被压入执行上下文栈</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> ECStack = [</span><br><span class=\"line\">    globalContext</span><br><span class=\"line\">];</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>全局上下文初始化</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">globalContext = &#123;</span><br><span class=\"line\">    VO: [global],</span><br><span class=\"line\">    Scope: [globalContext.VO],</span><br><span class=\"line\">    this: globalContext.VO</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>初始化的同时，checkscope 函数被创建，保存作用域链到函数的内部属性[[scope]]</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">checkscope.[[scope]] = [</span><br><span class=\"line\">    globalContext.VO</span><br><span class=\"line\">];</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 函数执行上下文被压入执行上下文栈</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ECStack = [</span><br><span class=\"line\">    checkscopeContext,</span><br><span class=\"line\">    globalContext</span><br><span class=\"line\">];</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li><p>checkscope 函数执行上下文初始化：</p>\n<ul>\n<li>复制函数 [[scope]] 属性创建作用域链，</li>\n<li>用 arguments 创建活动对象，</li>\n<li>初始化活动对象，即加入形参、函数声明、变量声明，</li>\n<li>将活动对象压入 checkscope 作用域链顶端。</li>\n</ul>\n</li>\n</ol>\n<p>同时 f 函数被创建，保存作用域链到 f 函数的内部属性[[scope]]</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">checkscopeContext = &#123;</span><br><span class=\"line\">    AO: &#123;</span><br><span class=\"line\">        arguments: &#123;</span><br><span class=\"line\">            length: 0</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        scope: undefined,</span><br><span class=\"line\">        f: reference to function f()&#123;&#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    Scope: [AO, globalContext.VO],</span><br><span class=\"line\">    this: undefined</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"5\">\n<li>执行 f 函数，创建 f 函数执行上下文，f 函数执行上下文被压入执行上下文栈</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> ECStack = [</span><br><span class=\"line\">    fContext,</span><br><span class=\"line\">    checkscopeContext,</span><br><span class=\"line\">    globalContext</span><br><span class=\"line\">];</span><br></pre></td></tr></table></figure>\n\n<ol start=\"6\">\n<li>f 函数执行上下文初始化, 以下跟第 4 步相同：<ul>\n<li>复制函数 [[scope]] 属性创建作用域链</li>\n<li>用 arguments 创建活动对象</li>\n<li>初始化活动对象，即加入形参、函数声明、变量声明</li>\n<li>将活动对象压入 f 作用域链顶端</li>\n</ul>\n</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> fContext = &#123;</span><br><span class=\"line\">    AO: &#123;</span><br><span class=\"line\">        arguments: &#123;</span><br><span class=\"line\">            length: 0</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    Scope: [AO, checkscopeContext.AO, globalContext.VO],</span><br><span class=\"line\">    this: undefined</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"7\">\n<li>f 函数执行，沿着作用域链查找 scope 值，返回 scope 值</li>\n<li>f 函数执行完毕，f 函数上下文从执行上下文栈中弹出</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> ECStack = [</span><br><span class=\"line\">    checkscopeContext,</span><br><span class=\"line\">    globalContext</span><br><span class=\"line\">];</span><br></pre></td></tr></table></figure>\n\n<ol start=\"9\">\n<li>checkscope 函数执行完毕，checkscope 执行上下文从执行上下文栈中弹出</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> ECStack = [</span><br><span class=\"line\">    globalContext</span><br><span class=\"line\">];</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"相关阅读\"><a href=\"#相关阅读\" class=\"headerlink\" title=\"相关阅读\"></a>相关阅读</h2><p><a href=\"https://juejin.im/post/5ba32171f265da0ab719a6d7\" target=\"_blank\" rel=\"noopener\">执行上下文</a><br><a href=\"https://github.com/mqyqingfeng/Blog/issues/8\" target=\"_blank\" rel=\"noopener\">执行上下文之详细的执行过程</a><br><a href=\"https://github.com/mqyqingfeng/Blog/issues/6\" target=\"_blank\" rel=\"noopener\">作用域连</a></p>\n<!-- [预编译](https://segmentfault.com/a/1190000018001871) -->\n<!-- [执行上下文](https://juejin.im/post/5a9e5b9ef265da239235dc9f) -->\n","site":{"data":{}},"excerpt":"","more":"<!-- JavaScript 运行三部曲\n\n1. 语法分析\n2. 预编译\n3. 解释执行 -->\n\n<h2 id=\"相关概念\"><a href=\"#相关概念\" class=\"headerlink\" title=\"相关概念\"></a>相关概念</h2><ol>\n<li>EC: 执行上下文 // execution context</li>\n<li>ECS: 执行环境栈 // execution context stack</li>\n<li>VO： 变量对象 // variable object</li>\n<li>AO： 活动对象 // active object</li>\n<li>scope chain：作用域链</li>\n</ol>\n<h2 id=\"执行上下文\"><a href=\"#执行上下文\" class=\"headerlink\" title=\"执行上下文\"></a>执行上下文</h2><p>简而言之，执行上下文是评估和执行 JavaScript 代码的环境的抽象概念。</p>\n<p>每当 Javascript 代码在运行的时候，它都是在执行上下文中运行。</p>\n<p>创建执行上下文时与之关联的会有一个变量对象，该上下文中的所有变量和函数全都保存在这个对象中。</p>\n<h3 id=\"三种类型\"><a href=\"#三种类型\" class=\"headerlink\" title=\"三种类型\"></a>三种类型</h3><ol>\n<li><p>全局执行上下文： 这是默认或者说基础的上下文，任何不在函数内部的代码都在全局上下文中。它会执行两件事：创建一个全局的 window 对象（浏览器的情况下），并且设置 this 的值等于这个全局对象。一个程序中只会有一个全局执行上下文。</p>\n</li>\n<li><p>函数执行上下文： 每当一个函数被调用时, 都会为该函数创建一个新的上下文。每个函数都有它自己的执行上下文，不过是在函数被调用时创建的。函数上下文可以有任意多个。每当一个新的执行上下文被创建，它会按定义的顺序（将在后文讨论）执行一系列步骤。</p>\n</li>\n<li><p>Eval 函数执行上下文： 执行在 eval 函数内部的代码也会有它属于自己的执行上下文，但由于 JavaScript 开发者并不经常使用 eval，所以在这里我不会讨论它。</p>\n</li>\n</ol>\n<!-- 不同执行上下文变量对象略有不同：\n\n全局上下文中的变量对象就是全局对象，允许通过变量对象的属性名来间接访问。\n函数上下文中用活动对象来表示变量对象，通过函数的 arguments 属性初始化。 -->\n\n<h3 id=\"生命周期的三个阶段\"><a href=\"#生命周期的三个阶段\" class=\"headerlink\" title=\"生命周期的三个阶段\"></a>生命周期的三个阶段</h3><p><strong>创建阶段:</strong></p>\n<p>执行上下文也可以抽象理解为一个对象，这个对象都有三个属性：<br>变量对象(variable object)、作用域链(scope chain)、this 指针(this value)。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const execContant = &#123;</span><br><span class=\"line\">    VO | AO: 全局上下文为 VO,函数上下文为 AO,</span><br><span class=\"line\">    Scope: 作用域链,</span><br><span class=\"line\">    this: this 指向</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>创建阶段相当于 new 一个对象</p>\n<p>当函数被调用，但未执行任何其内部代码之前，会做以下三件事：</p>\n<ol>\n<li>创建变量对象：首先初始化函数的参数 arguments，提升函数声明和变量声明。</li>\n<li>创建作用域链（Scope Chain）：在执行期上下文的创建阶段，作用域链是在变量对象之后创建的。，作用域链本身包含变量对象。作用域链用于解析变量。当被要求解析变量时，JavaScript 始终从代码嵌套的最内层开始，如果最内层没有找到变量，就会跳转到上一层父作用域中查找，直到找到该变量。<br>函数的作用域在函数定义的时候就决定，这是因为函数有一个内部属性 [[scope]]，当函数创建的时候，就会保存所有父变量对象到其中，你可以理解 [[scope]] 就是所有父变量对象的层级链，但是注意：[[scope]] 并不代表完整的作用域链！</li>\n<li>确定 this 指向：包括多种情况,后续文章讲解</li>\n</ol>\n<p>在一段 JS 脚本执行之前，要先解析代码（所以说 JS 是解释执行的脚本语言），解析的时候会先创建一个全局执行上下文环境，先把代码中即将执行的变量、函数声明都拿出来。变量先暂时赋值为 undefined，函数则先声明好可使用。这一步做完了，然后再开始正式执行程序。</p>\n<p>另外，一个函数在执行之前，也会创建一个函数执行上下文环境，跟全局上下文差不多，不过 函数执行上下文中会多出 this arguments 和函数的参数。</p>\n<p><strong>代码执行阶段</strong> 执行上下文入栈，变量对象添加形参，变量声明，函数引用，执行其他代码<br><strong>回收阶段</strong>: 执行上下文出栈，等待虚拟机回收执行上下文，变量回收</p>\n<h2 id=\"执行栈\"><a href=\"#执行栈\" class=\"headerlink\" title=\"执行栈\"></a>执行栈</h2><p>执行栈，也就是在其它编程语言中所说的“调用栈”，是一种拥有 LIFO（后进先出）数据结构的栈，被用来存储代码运行时创建的所有执行上下文。</p>\n<p>当 JavaScript 引擎第一次遇到你的脚本时，它会创建一个全局的执行上下文并且压入当前执行栈。每当引擎遇到一个函数调用，它会为该函数创建一个新的执行上下文并压入栈的顶部。</p>\n<p>引擎会执行那些执行上下文位于栈顶的函数。当该函数执行结束时，执行上下文从栈中弹出，控制流程到达当前栈中的下一个上下文。</p>\n<h2 id=\"执行过程\"><a href=\"#执行过程\" class=\"headerlink\" title=\"执行过程\"></a>执行过程</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var scope = &quot;global scope&quot;;</span><br><span class=\"line\">function checkscope()&#123;</span><br><span class=\"line\">    var scope = &quot;local scope&quot;;</span><br><span class=\"line\">    function f()&#123;</span><br><span class=\"line\">        return scope;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return f();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">checkscope();</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>执行全局代码，创建全局执行上下文，全局上下文被压入执行上下文栈</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> ECStack = [</span><br><span class=\"line\">    globalContext</span><br><span class=\"line\">];</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>全局上下文初始化</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">globalContext = &#123;</span><br><span class=\"line\">    VO: [global],</span><br><span class=\"line\">    Scope: [globalContext.VO],</span><br><span class=\"line\">    this: globalContext.VO</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>初始化的同时，checkscope 函数被创建，保存作用域链到函数的内部属性[[scope]]</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">checkscope.[[scope]] = [</span><br><span class=\"line\">    globalContext.VO</span><br><span class=\"line\">];</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 函数执行上下文被压入执行上下文栈</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ECStack = [</span><br><span class=\"line\">    checkscopeContext,</span><br><span class=\"line\">    globalContext</span><br><span class=\"line\">];</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li><p>checkscope 函数执行上下文初始化：</p>\n<ul>\n<li>复制函数 [[scope]] 属性创建作用域链，</li>\n<li>用 arguments 创建活动对象，</li>\n<li>初始化活动对象，即加入形参、函数声明、变量声明，</li>\n<li>将活动对象压入 checkscope 作用域链顶端。</li>\n</ul>\n</li>\n</ol>\n<p>同时 f 函数被创建，保存作用域链到 f 函数的内部属性[[scope]]</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">checkscopeContext = &#123;</span><br><span class=\"line\">    AO: &#123;</span><br><span class=\"line\">        arguments: &#123;</span><br><span class=\"line\">            length: 0</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        scope: undefined,</span><br><span class=\"line\">        f: reference to function f()&#123;&#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    Scope: [AO, globalContext.VO],</span><br><span class=\"line\">    this: undefined</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"5\">\n<li>执行 f 函数，创建 f 函数执行上下文，f 函数执行上下文被压入执行上下文栈</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> ECStack = [</span><br><span class=\"line\">    fContext,</span><br><span class=\"line\">    checkscopeContext,</span><br><span class=\"line\">    globalContext</span><br><span class=\"line\">];</span><br></pre></td></tr></table></figure>\n\n<ol start=\"6\">\n<li>f 函数执行上下文初始化, 以下跟第 4 步相同：<ul>\n<li>复制函数 [[scope]] 属性创建作用域链</li>\n<li>用 arguments 创建活动对象</li>\n<li>初始化活动对象，即加入形参、函数声明、变量声明</li>\n<li>将活动对象压入 f 作用域链顶端</li>\n</ul>\n</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> fContext = &#123;</span><br><span class=\"line\">    AO: &#123;</span><br><span class=\"line\">        arguments: &#123;</span><br><span class=\"line\">            length: 0</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    Scope: [AO, checkscopeContext.AO, globalContext.VO],</span><br><span class=\"line\">    this: undefined</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"7\">\n<li>f 函数执行，沿着作用域链查找 scope 值，返回 scope 值</li>\n<li>f 函数执行完毕，f 函数上下文从执行上下文栈中弹出</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> ECStack = [</span><br><span class=\"line\">    checkscopeContext,</span><br><span class=\"line\">    globalContext</span><br><span class=\"line\">];</span><br></pre></td></tr></table></figure>\n\n<ol start=\"9\">\n<li>checkscope 函数执行完毕，checkscope 执行上下文从执行上下文栈中弹出</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> ECStack = [</span><br><span class=\"line\">    globalContext</span><br><span class=\"line\">];</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"相关阅读\"><a href=\"#相关阅读\" class=\"headerlink\" title=\"相关阅读\"></a>相关阅读</h2><p><a href=\"https://juejin.im/post/5ba32171f265da0ab719a6d7\" target=\"_blank\" rel=\"noopener\">执行上下文</a><br><a href=\"https://github.com/mqyqingfeng/Blog/issues/8\" target=\"_blank\" rel=\"noopener\">执行上下文之详细的执行过程</a><br><a href=\"https://github.com/mqyqingfeng/Blog/issues/6\" target=\"_blank\" rel=\"noopener\">作用域连</a></p>\n<!-- [预编译](https://segmentfault.com/a/1190000018001871) -->\n<!-- [执行上下文](https://juejin.im/post/5a9e5b9ef265da239235dc9f) -->\n"},{"title":"hls技术和m3u8格式视频播放问题","date":"2020-05-21T09:04:55.000Z","_content":"\n\n## 什么是 HLS\n\nHTTP Live Streaming（缩写是 HLS）是由苹果公司提出基于 HTTP 的流媒体网络传输协议。是苹果公司 QuickTime X 和 iPhone 软件系统的一部分。它的工作原理是`把整个流分成一个个小的基于 HTTP 的文件来下载`，`每次只下载一些`。当媒体流正在播放时，客户端可以选择从许多不同的备用源中以不同的速率下载同样的资源，允许流媒体会话适应不同的数据速率。在开始一个流媒体会话时，客户端会下载一个包含元数据的 extended M3U (m3u8) playlist 文件，用于寻找可用的媒体流。\n\nHLS 只请求基本的 HTTP 报文，与实时传输协议（RTP）不同，HLS 可以穿过任何允许 HTTP 数据通过的防火墙或者代理服务器。它也很容易使用内容分发网络来传输媒体流。 FROM：维基百科\n\n## 什么是 m3u8\n\n首先提一下`M3U`,M3U 是一种播放多媒体列表的文件格式(M3U 文件是一种纯文本文件，可以指定一个或多个多媒体文件的位置，其文件扩展名是“M3U”或者“m3u”)，它的设计初衷是为了播放音频文件，比如 MP3，但是越来越多的软件现在用来播放视频文件列表，M3U 也可以指定在线流媒体音频源。很多播放器和软件都支持 M3U 文件格式。\n\nM3U8 是 Unicode 版本的 M3U，用 UTF-8 编码。\"M3U\"和\"M3U8\"文件都是苹果公司使用的 HTTP Live Streaming 格式的基础，这种格式可以在 iPhone 和 Macbook 等设备播放。\n\n## m3u8 兼容性\n\n[https://caniuse.com/#search=m3u8](https://caniuse.com/#search=m3u8)\n\n移动端浏览器大部分支持，PC 端几乎不支持（2020-02-24）\n\n## m3u8 格式文件\n\nm3u8 区分未加密和加密两种，加密的 m3u8 在格式上多了#EXT-X-KEY，通过#EXT-X-KEY 的值去获取加密密钥，密钥文件由客户端从服务器请求认证获得(#EXT-X-KEY = url)\n\n**未加密的 mu38**\n\n```\n#EXTM3U // 开始必须是这个 表示其为m3u8格式\n#EXT-X-VERSION:3 // 版本\n#EXT-X-MEDIA-SEQUENCE:0 // 序号，从哪个开始播放，对应ts文件的序号\n#EXT-X-ALLOW-CACHE:YES\n#EXT-X-TARGETDURATION:22\n\n#EXTINF:9.009, // 时长，单位(秒)\nhttp://m3u8.example.com/0.ts\n#EXTINF:9.009, // 时长，单位(秒)\nhttp://m3u8.example.com/1.ts\n#EXTINF:3.003, // 时长，单位(秒)\nhttp://m3u8.example.com/2.ts\n#EXTINF:3.003, // 时长，单位(秒)\n/2.ts                        // 默认是以链接名为域名\n#EXT-X-ENDLIST // 时长，单位(秒)\n\n```\n\n**加密的 mu38**\n\n一种是对 TS 切片文件直接加密；另一种是对 H.264 编码文件中类型为 1 和 5 的 NAL 单元进行加密，其它类型的 NAL 单元不加密[2]。\nURI 直接返回文本格式的密钥，而不是 json 格式的对象。\n\n**划重点：加密的 m3u8 视频播放，播放器会主动调用 URI 中的链接，获取密钥，项目部署和 URI 在不同域下，这可能存在跨域问题！这可能存在跨域问题！这可能存在跨域问题！你细品！**\n**https 的问题也需要注意**\n\n```\n\n#EXTM3U\n#EXT-X-VERSION:3  // 版本\n#EXT-X-MEDIA-SEQUENCE:0 //  队列\n#EXT-X-ALLOW-CACHE:YES // 是否允许缓存\n#EXT-X-TARGETDURATION:22\n#EXT-X-KEY:METHOD=AES-128,URI=\"https://cdn.xxx.com/static/js/key.text\",IV=0x6f827308c0b2cf37bd8f22f457a852d2 // METHOD 加密方式  URI 加密密钥的链接 IV\n#EXTINF:21.200000, // 时长，单位(秒)\nhttp://m3u8.example.com/0.ts\n#EXT-X-KEY:METHOD=AES-128,URI=\"https://cdn.xxx.com/static/js/key.text\",IV=0x27fa8d760c73864ca85a43a0b2d833ac\n#EXTINF:18.000000, // 时长，单位(秒)\nhttp://m3u8.example.com/1.ts\n#EXT-X-KEY:METHOD=AES-128,URI=\"https://cdn.xxx.com/static/js/key.text\",IV=0x27fa8d760c73864ca85a43a0b2d833ac\n#EXTINF:18.000000, // 时长，单位(秒)\nhttp://m3u8.example.com/1.ts\n#EXT-X-ENDLIST\n\n```\n\n## 播放问题\n\n前面提到了 m3u8 格式，在移动端大部分是兼容的，在 PC 端不兼容\n\n1. 原生 video 播放\n2. videojs + videojs-contrib-hls\n   直接在网页中生效\n   vue 中暂时没有自己实践\n3. hls.js\n4. 奇舞：**移动端**：chimee-mobile-player **PC 端**：chimee-player\n   ** 注意需要手动引入 css**\n\n```\n// PC\nimport ChimeePlayer from \"chimee-player\";\nimport \"chimee-player/lib/chimee-player.min.css\";\n\n// 移动端\nimport ChimeeMobilePlayer from \"chimee-mobile-player\";\nimport \"chimee-mobile-player/lib/chimee-mobile-player.browser.css\";\n```\n\n## 总结\n\n需要了解基本概念, m3u8 的播放和 mp4 等别的播放，最大问题就是兼容问题，然后就是加密的 m3u8 注意获取 key 的过程，浏览器访问 URI，不会显示在浏览器的 xhr 请求里面（在浏览器 ALL 里面可以查看的，在 webview 页面中调试，请抓包，\n未加密的 m3u8 肯定会比 mp4 加载速度快很快，毕竟切片了\n\n## 相关阅读\n\n[知乎大神回答](https://www.zhihu.com/question/21087379)\n[掘金大神文章](https://juejin.im/post/5be1629ce51d4514d5607357#heading-2)\n","source":"_posts/2020/05/21/hls技术和m3u8格式视频播放.md","raw":"---\ntitle: hls技术和m3u8格式视频播放问题\ncategories:\n  - 前端\ntags:\n  - video\ndate: 2020-05-21 17:04:55\n---\n\n\n## 什么是 HLS\n\nHTTP Live Streaming（缩写是 HLS）是由苹果公司提出基于 HTTP 的流媒体网络传输协议。是苹果公司 QuickTime X 和 iPhone 软件系统的一部分。它的工作原理是`把整个流分成一个个小的基于 HTTP 的文件来下载`，`每次只下载一些`。当媒体流正在播放时，客户端可以选择从许多不同的备用源中以不同的速率下载同样的资源，允许流媒体会话适应不同的数据速率。在开始一个流媒体会话时，客户端会下载一个包含元数据的 extended M3U (m3u8) playlist 文件，用于寻找可用的媒体流。\n\nHLS 只请求基本的 HTTP 报文，与实时传输协议（RTP）不同，HLS 可以穿过任何允许 HTTP 数据通过的防火墙或者代理服务器。它也很容易使用内容分发网络来传输媒体流。 FROM：维基百科\n\n## 什么是 m3u8\n\n首先提一下`M3U`,M3U 是一种播放多媒体列表的文件格式(M3U 文件是一种纯文本文件，可以指定一个或多个多媒体文件的位置，其文件扩展名是“M3U”或者“m3u”)，它的设计初衷是为了播放音频文件，比如 MP3，但是越来越多的软件现在用来播放视频文件列表，M3U 也可以指定在线流媒体音频源。很多播放器和软件都支持 M3U 文件格式。\n\nM3U8 是 Unicode 版本的 M3U，用 UTF-8 编码。\"M3U\"和\"M3U8\"文件都是苹果公司使用的 HTTP Live Streaming 格式的基础，这种格式可以在 iPhone 和 Macbook 等设备播放。\n\n## m3u8 兼容性\n\n[https://caniuse.com/#search=m3u8](https://caniuse.com/#search=m3u8)\n\n移动端浏览器大部分支持，PC 端几乎不支持（2020-02-24）\n\n## m3u8 格式文件\n\nm3u8 区分未加密和加密两种，加密的 m3u8 在格式上多了#EXT-X-KEY，通过#EXT-X-KEY 的值去获取加密密钥，密钥文件由客户端从服务器请求认证获得(#EXT-X-KEY = url)\n\n**未加密的 mu38**\n\n```\n#EXTM3U // 开始必须是这个 表示其为m3u8格式\n#EXT-X-VERSION:3 // 版本\n#EXT-X-MEDIA-SEQUENCE:0 // 序号，从哪个开始播放，对应ts文件的序号\n#EXT-X-ALLOW-CACHE:YES\n#EXT-X-TARGETDURATION:22\n\n#EXTINF:9.009, // 时长，单位(秒)\nhttp://m3u8.example.com/0.ts\n#EXTINF:9.009, // 时长，单位(秒)\nhttp://m3u8.example.com/1.ts\n#EXTINF:3.003, // 时长，单位(秒)\nhttp://m3u8.example.com/2.ts\n#EXTINF:3.003, // 时长，单位(秒)\n/2.ts                        // 默认是以链接名为域名\n#EXT-X-ENDLIST // 时长，单位(秒)\n\n```\n\n**加密的 mu38**\n\n一种是对 TS 切片文件直接加密；另一种是对 H.264 编码文件中类型为 1 和 5 的 NAL 单元进行加密，其它类型的 NAL 单元不加密[2]。\nURI 直接返回文本格式的密钥，而不是 json 格式的对象。\n\n**划重点：加密的 m3u8 视频播放，播放器会主动调用 URI 中的链接，获取密钥，项目部署和 URI 在不同域下，这可能存在跨域问题！这可能存在跨域问题！这可能存在跨域问题！你细品！**\n**https 的问题也需要注意**\n\n```\n\n#EXTM3U\n#EXT-X-VERSION:3  // 版本\n#EXT-X-MEDIA-SEQUENCE:0 //  队列\n#EXT-X-ALLOW-CACHE:YES // 是否允许缓存\n#EXT-X-TARGETDURATION:22\n#EXT-X-KEY:METHOD=AES-128,URI=\"https://cdn.xxx.com/static/js/key.text\",IV=0x6f827308c0b2cf37bd8f22f457a852d2 // METHOD 加密方式  URI 加密密钥的链接 IV\n#EXTINF:21.200000, // 时长，单位(秒)\nhttp://m3u8.example.com/0.ts\n#EXT-X-KEY:METHOD=AES-128,URI=\"https://cdn.xxx.com/static/js/key.text\",IV=0x27fa8d760c73864ca85a43a0b2d833ac\n#EXTINF:18.000000, // 时长，单位(秒)\nhttp://m3u8.example.com/1.ts\n#EXT-X-KEY:METHOD=AES-128,URI=\"https://cdn.xxx.com/static/js/key.text\",IV=0x27fa8d760c73864ca85a43a0b2d833ac\n#EXTINF:18.000000, // 时长，单位(秒)\nhttp://m3u8.example.com/1.ts\n#EXT-X-ENDLIST\n\n```\n\n## 播放问题\n\n前面提到了 m3u8 格式，在移动端大部分是兼容的，在 PC 端不兼容\n\n1. 原生 video 播放\n2. videojs + videojs-contrib-hls\n   直接在网页中生效\n   vue 中暂时没有自己实践\n3. hls.js\n4. 奇舞：**移动端**：chimee-mobile-player **PC 端**：chimee-player\n   ** 注意需要手动引入 css**\n\n```\n// PC\nimport ChimeePlayer from \"chimee-player\";\nimport \"chimee-player/lib/chimee-player.min.css\";\n\n// 移动端\nimport ChimeeMobilePlayer from \"chimee-mobile-player\";\nimport \"chimee-mobile-player/lib/chimee-mobile-player.browser.css\";\n```\n\n## 总结\n\n需要了解基本概念, m3u8 的播放和 mp4 等别的播放，最大问题就是兼容问题，然后就是加密的 m3u8 注意获取 key 的过程，浏览器访问 URI，不会显示在浏览器的 xhr 请求里面（在浏览器 ALL 里面可以查看的，在 webview 页面中调试，请抓包，\n未加密的 m3u8 肯定会比 mp4 加载速度快很快，毕竟切片了\n\n## 相关阅读\n\n[知乎大神回答](https://www.zhihu.com/question/21087379)\n[掘金大神文章](https://juejin.im/post/5be1629ce51d4514d5607357#heading-2)\n","slug":"hls技术和m3u8格式视频播放","published":1,"updated":"2020-05-21T09:04:55.296Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckb1z4djh002b9n9476xy3wd5","content":"<h2 id=\"什么是-HLS\"><a href=\"#什么是-HLS\" class=\"headerlink\" title=\"什么是 HLS\"></a>什么是 HLS</h2><p>HTTP Live Streaming（缩写是 HLS）是由苹果公司提出基于 HTTP 的流媒体网络传输协议。是苹果公司 QuickTime X 和 iPhone 软件系统的一部分。它的工作原理是<code>把整个流分成一个个小的基于 HTTP 的文件来下载</code>，<code>每次只下载一些</code>。当媒体流正在播放时，客户端可以选择从许多不同的备用源中以不同的速率下载同样的资源，允许流媒体会话适应不同的数据速率。在开始一个流媒体会话时，客户端会下载一个包含元数据的 extended M3U (m3u8) playlist 文件，用于寻找可用的媒体流。</p>\n<p>HLS 只请求基本的 HTTP 报文，与实时传输协议（RTP）不同，HLS 可以穿过任何允许 HTTP 数据通过的防火墙或者代理服务器。它也很容易使用内容分发网络来传输媒体流。 FROM：维基百科</p>\n<h2 id=\"什么是-m3u8\"><a href=\"#什么是-m3u8\" class=\"headerlink\" title=\"什么是 m3u8\"></a>什么是 m3u8</h2><p>首先提一下<code>M3U</code>,M3U 是一种播放多媒体列表的文件格式(M3U 文件是一种纯文本文件，可以指定一个或多个多媒体文件的位置，其文件扩展名是“M3U”或者“m3u”)，它的设计初衷是为了播放音频文件，比如 MP3，但是越来越多的软件现在用来播放视频文件列表，M3U 也可以指定在线流媒体音频源。很多播放器和软件都支持 M3U 文件格式。</p>\n<p>M3U8 是 Unicode 版本的 M3U，用 UTF-8 编码。”M3U”和”M3U8”文件都是苹果公司使用的 HTTP Live Streaming 格式的基础，这种格式可以在 iPhone 和 Macbook 等设备播放。</p>\n<h2 id=\"m3u8-兼容性\"><a href=\"#m3u8-兼容性\" class=\"headerlink\" title=\"m3u8 兼容性\"></a>m3u8 兼容性</h2><p><a href=\"https://caniuse.com/#search=m3u8\" target=\"_blank\" rel=\"noopener\">https://caniuse.com/#search=m3u8</a></p>\n<p>移动端浏览器大部分支持，PC 端几乎不支持（2020-02-24）</p>\n<h2 id=\"m3u8-格式文件\"><a href=\"#m3u8-格式文件\" class=\"headerlink\" title=\"m3u8 格式文件\"></a>m3u8 格式文件</h2><p>m3u8 区分未加密和加密两种，加密的 m3u8 在格式上多了#EXT-X-KEY，通过#EXT-X-KEY 的值去获取加密密钥，密钥文件由客户端从服务器请求认证获得(#EXT-X-KEY = url)</p>\n<p><strong>未加密的 mu38</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#EXTM3U // 开始必须是这个 表示其为m3u8格式</span><br><span class=\"line\">#EXT-X-VERSION:3 // 版本</span><br><span class=\"line\">#EXT-X-MEDIA-SEQUENCE:0 // 序号，从哪个开始播放，对应ts文件的序号</span><br><span class=\"line\">#EXT-X-ALLOW-CACHE:YES</span><br><span class=\"line\">#EXT-X-TARGETDURATION:22</span><br><span class=\"line\"></span><br><span class=\"line\">#EXTINF:9.009, // 时长，单位(秒)</span><br><span class=\"line\">http://m3u8.example.com/0.ts</span><br><span class=\"line\">#EXTINF:9.009, // 时长，单位(秒)</span><br><span class=\"line\">http://m3u8.example.com/1.ts</span><br><span class=\"line\">#EXTINF:3.003, // 时长，单位(秒)</span><br><span class=\"line\">http://m3u8.example.com/2.ts</span><br><span class=\"line\">#EXTINF:3.003, // 时长，单位(秒)</span><br><span class=\"line\">/2.ts                        // 默认是以链接名为域名</span><br><span class=\"line\">#EXT-X-ENDLIST // 时长，单位(秒)</span><br></pre></td></tr></table></figure>\n\n<p><strong>加密的 mu38</strong></p>\n<p>一种是对 TS 切片文件直接加密；另一种是对 H.264 编码文件中类型为 1 和 5 的 NAL 单元进行加密，其它类型的 NAL 单元不加密[2]。<br>URI 直接返回文本格式的密钥，而不是 json 格式的对象。</p>\n<p><strong>划重点：加密的 m3u8 视频播放，播放器会主动调用 URI 中的链接，获取密钥，项目部署和 URI 在不同域下，这可能存在跨域问题！这可能存在跨域问题！这可能存在跨域问题！你细品！</strong><br><strong>https 的问题也需要注意</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">#EXTM3U</span><br><span class=\"line\">#EXT-X-VERSION:3  // 版本</span><br><span class=\"line\">#EXT-X-MEDIA-SEQUENCE:0 //  队列</span><br><span class=\"line\">#EXT-X-ALLOW-CACHE:YES // 是否允许缓存</span><br><span class=\"line\">#EXT-X-TARGETDURATION:22</span><br><span class=\"line\">#EXT-X-KEY:METHOD=AES-128,URI=&quot;https://cdn.xxx.com/static/js/key.text&quot;,IV=0x6f827308c0b2cf37bd8f22f457a852d2 // METHOD 加密方式  URI 加密密钥的链接 IV</span><br><span class=\"line\">#EXTINF:21.200000, // 时长，单位(秒)</span><br><span class=\"line\">http://m3u8.example.com/0.ts</span><br><span class=\"line\">#EXT-X-KEY:METHOD=AES-128,URI=&quot;https://cdn.xxx.com/static/js/key.text&quot;,IV=0x27fa8d760c73864ca85a43a0b2d833ac</span><br><span class=\"line\">#EXTINF:18.000000, // 时长，单位(秒)</span><br><span class=\"line\">http://m3u8.example.com/1.ts</span><br><span class=\"line\">#EXT-X-KEY:METHOD=AES-128,URI=&quot;https://cdn.xxx.com/static/js/key.text&quot;,IV=0x27fa8d760c73864ca85a43a0b2d833ac</span><br><span class=\"line\">#EXTINF:18.000000, // 时长，单位(秒)</span><br><span class=\"line\">http://m3u8.example.com/1.ts</span><br><span class=\"line\">#EXT-X-ENDLIST</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"播放问题\"><a href=\"#播放问题\" class=\"headerlink\" title=\"播放问题\"></a>播放问题</h2><p>前面提到了 m3u8 格式，在移动端大部分是兼容的，在 PC 端不兼容</p>\n<ol>\n<li>原生 video 播放</li>\n<li>videojs + videojs-contrib-hls<br>直接在网页中生效<br>vue 中暂时没有自己实践</li>\n<li>hls.js</li>\n<li>奇舞：<strong>移动端</strong>：chimee-mobile-player <strong>PC 端</strong>：chimee-player<br>** 注意需要手动引入 css**</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// PC</span><br><span class=\"line\">import ChimeePlayer from &quot;chimee-player&quot;;</span><br><span class=\"line\">import &quot;chimee-player/lib/chimee-player.min.css&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">// 移动端</span><br><span class=\"line\">import ChimeeMobilePlayer from &quot;chimee-mobile-player&quot;;</span><br><span class=\"line\">import &quot;chimee-mobile-player/lib/chimee-mobile-player.browser.css&quot;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>需要了解基本概念, m3u8 的播放和 mp4 等别的播放，最大问题就是兼容问题，然后就是加密的 m3u8 注意获取 key 的过程，浏览器访问 URI，不会显示在浏览器的 xhr 请求里面（在浏览器 ALL 里面可以查看的，在 webview 页面中调试，请抓包，<br>未加密的 m3u8 肯定会比 mp4 加载速度快很快，毕竟切片了</p>\n<h2 id=\"相关阅读\"><a href=\"#相关阅读\" class=\"headerlink\" title=\"相关阅读\"></a>相关阅读</h2><p><a href=\"https://www.zhihu.com/question/21087379\" target=\"_blank\" rel=\"noopener\">知乎大神回答</a><br><a href=\"https://juejin.im/post/5be1629ce51d4514d5607357#heading-2\" target=\"_blank\" rel=\"noopener\">掘金大神文章</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"什么是-HLS\"><a href=\"#什么是-HLS\" class=\"headerlink\" title=\"什么是 HLS\"></a>什么是 HLS</h2><p>HTTP Live Streaming（缩写是 HLS）是由苹果公司提出基于 HTTP 的流媒体网络传输协议。是苹果公司 QuickTime X 和 iPhone 软件系统的一部分。它的工作原理是<code>把整个流分成一个个小的基于 HTTP 的文件来下载</code>，<code>每次只下载一些</code>。当媒体流正在播放时，客户端可以选择从许多不同的备用源中以不同的速率下载同样的资源，允许流媒体会话适应不同的数据速率。在开始一个流媒体会话时，客户端会下载一个包含元数据的 extended M3U (m3u8) playlist 文件，用于寻找可用的媒体流。</p>\n<p>HLS 只请求基本的 HTTP 报文，与实时传输协议（RTP）不同，HLS 可以穿过任何允许 HTTP 数据通过的防火墙或者代理服务器。它也很容易使用内容分发网络来传输媒体流。 FROM：维基百科</p>\n<h2 id=\"什么是-m3u8\"><a href=\"#什么是-m3u8\" class=\"headerlink\" title=\"什么是 m3u8\"></a>什么是 m3u8</h2><p>首先提一下<code>M3U</code>,M3U 是一种播放多媒体列表的文件格式(M3U 文件是一种纯文本文件，可以指定一个或多个多媒体文件的位置，其文件扩展名是“M3U”或者“m3u”)，它的设计初衷是为了播放音频文件，比如 MP3，但是越来越多的软件现在用来播放视频文件列表，M3U 也可以指定在线流媒体音频源。很多播放器和软件都支持 M3U 文件格式。</p>\n<p>M3U8 是 Unicode 版本的 M3U，用 UTF-8 编码。”M3U”和”M3U8”文件都是苹果公司使用的 HTTP Live Streaming 格式的基础，这种格式可以在 iPhone 和 Macbook 等设备播放。</p>\n<h2 id=\"m3u8-兼容性\"><a href=\"#m3u8-兼容性\" class=\"headerlink\" title=\"m3u8 兼容性\"></a>m3u8 兼容性</h2><p><a href=\"https://caniuse.com/#search=m3u8\" target=\"_blank\" rel=\"noopener\">https://caniuse.com/#search=m3u8</a></p>\n<p>移动端浏览器大部分支持，PC 端几乎不支持（2020-02-24）</p>\n<h2 id=\"m3u8-格式文件\"><a href=\"#m3u8-格式文件\" class=\"headerlink\" title=\"m3u8 格式文件\"></a>m3u8 格式文件</h2><p>m3u8 区分未加密和加密两种，加密的 m3u8 在格式上多了#EXT-X-KEY，通过#EXT-X-KEY 的值去获取加密密钥，密钥文件由客户端从服务器请求认证获得(#EXT-X-KEY = url)</p>\n<p><strong>未加密的 mu38</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#EXTM3U // 开始必须是这个 表示其为m3u8格式</span><br><span class=\"line\">#EXT-X-VERSION:3 // 版本</span><br><span class=\"line\">#EXT-X-MEDIA-SEQUENCE:0 // 序号，从哪个开始播放，对应ts文件的序号</span><br><span class=\"line\">#EXT-X-ALLOW-CACHE:YES</span><br><span class=\"line\">#EXT-X-TARGETDURATION:22</span><br><span class=\"line\"></span><br><span class=\"line\">#EXTINF:9.009, // 时长，单位(秒)</span><br><span class=\"line\">http://m3u8.example.com/0.ts</span><br><span class=\"line\">#EXTINF:9.009, // 时长，单位(秒)</span><br><span class=\"line\">http://m3u8.example.com/1.ts</span><br><span class=\"line\">#EXTINF:3.003, // 时长，单位(秒)</span><br><span class=\"line\">http://m3u8.example.com/2.ts</span><br><span class=\"line\">#EXTINF:3.003, // 时长，单位(秒)</span><br><span class=\"line\">/2.ts                        // 默认是以链接名为域名</span><br><span class=\"line\">#EXT-X-ENDLIST // 时长，单位(秒)</span><br></pre></td></tr></table></figure>\n\n<p><strong>加密的 mu38</strong></p>\n<p>一种是对 TS 切片文件直接加密；另一种是对 H.264 编码文件中类型为 1 和 5 的 NAL 单元进行加密，其它类型的 NAL 单元不加密[2]。<br>URI 直接返回文本格式的密钥，而不是 json 格式的对象。</p>\n<p><strong>划重点：加密的 m3u8 视频播放，播放器会主动调用 URI 中的链接，获取密钥，项目部署和 URI 在不同域下，这可能存在跨域问题！这可能存在跨域问题！这可能存在跨域问题！你细品！</strong><br><strong>https 的问题也需要注意</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">#EXTM3U</span><br><span class=\"line\">#EXT-X-VERSION:3  // 版本</span><br><span class=\"line\">#EXT-X-MEDIA-SEQUENCE:0 //  队列</span><br><span class=\"line\">#EXT-X-ALLOW-CACHE:YES // 是否允许缓存</span><br><span class=\"line\">#EXT-X-TARGETDURATION:22</span><br><span class=\"line\">#EXT-X-KEY:METHOD=AES-128,URI=&quot;https://cdn.xxx.com/static/js/key.text&quot;,IV=0x6f827308c0b2cf37bd8f22f457a852d2 // METHOD 加密方式  URI 加密密钥的链接 IV</span><br><span class=\"line\">#EXTINF:21.200000, // 时长，单位(秒)</span><br><span class=\"line\">http://m3u8.example.com/0.ts</span><br><span class=\"line\">#EXT-X-KEY:METHOD=AES-128,URI=&quot;https://cdn.xxx.com/static/js/key.text&quot;,IV=0x27fa8d760c73864ca85a43a0b2d833ac</span><br><span class=\"line\">#EXTINF:18.000000, // 时长，单位(秒)</span><br><span class=\"line\">http://m3u8.example.com/1.ts</span><br><span class=\"line\">#EXT-X-KEY:METHOD=AES-128,URI=&quot;https://cdn.xxx.com/static/js/key.text&quot;,IV=0x27fa8d760c73864ca85a43a0b2d833ac</span><br><span class=\"line\">#EXTINF:18.000000, // 时长，单位(秒)</span><br><span class=\"line\">http://m3u8.example.com/1.ts</span><br><span class=\"line\">#EXT-X-ENDLIST</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"播放问题\"><a href=\"#播放问题\" class=\"headerlink\" title=\"播放问题\"></a>播放问题</h2><p>前面提到了 m3u8 格式，在移动端大部分是兼容的，在 PC 端不兼容</p>\n<ol>\n<li>原生 video 播放</li>\n<li>videojs + videojs-contrib-hls<br>直接在网页中生效<br>vue 中暂时没有自己实践</li>\n<li>hls.js</li>\n<li>奇舞：<strong>移动端</strong>：chimee-mobile-player <strong>PC 端</strong>：chimee-player<br>** 注意需要手动引入 css**</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// PC</span><br><span class=\"line\">import ChimeePlayer from &quot;chimee-player&quot;;</span><br><span class=\"line\">import &quot;chimee-player/lib/chimee-player.min.css&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">// 移动端</span><br><span class=\"line\">import ChimeeMobilePlayer from &quot;chimee-mobile-player&quot;;</span><br><span class=\"line\">import &quot;chimee-mobile-player/lib/chimee-mobile-player.browser.css&quot;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>需要了解基本概念, m3u8 的播放和 mp4 等别的播放，最大问题就是兼容问题，然后就是加密的 m3u8 注意获取 key 的过程，浏览器访问 URI，不会显示在浏览器的 xhr 请求里面（在浏览器 ALL 里面可以查看的，在 webview 页面中调试，请抓包，<br>未加密的 m3u8 肯定会比 mp4 加载速度快很快，毕竟切片了</p>\n<h2 id=\"相关阅读\"><a href=\"#相关阅读\" class=\"headerlink\" title=\"相关阅读\"></a>相关阅读</h2><p><a href=\"https://www.zhihu.com/question/21087379\" target=\"_blank\" rel=\"noopener\">知乎大神回答</a><br><a href=\"https://juejin.im/post/5be1629ce51d4514d5607357#heading-2\" target=\"_blank\" rel=\"noopener\">掘金大神文章</a></p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"ckb1z4dfc000h9n94iykooz9e","category_id":"ckb1z4dff000k9n94ff4gs7r3","_id":"ckb1z4dfk000u9n945kjk9vzj"},{"post_id":"ckb1z4dfp00129n94gqv4ge4a","category_id":"ckb1z4dff000k9n94ff4gs7r3","_id":"ckb1z4dft00199n947jm8c2at"},{"post_id":"ckb1z4dfw001f9n94if1nac2j","category_id":"ckb1z4dff000k9n94ff4gs7r3","_id":"ckb1z4dg0001n9n94odtlau48"},{"post_id":"ckb1z4dg5001z9n94bmiaayzz","category_id":"ckb1z4dff000k9n94ff4gs7r3","_id":"ckb1z4dg900259n94vjmc36l4"},{"post_id":"ckb1z4djc00279n94smdrxyr1","category_id":"ckb1z4dff000k9n94ff4gs7r3","_id":"ckb1z4dji002c9n941bz3gifg"},{"post_id":"ckb1z4djf00289n94ir0dl2nu","category_id":"ckb1z4dff000k9n94ff4gs7r3","_id":"ckb1z4dji002d9n941dqrud6n"},{"post_id":"ckb1z4djh002b9n9476xy3wd5","category_id":"ckb1z4dff000k9n94ff4gs7r3","_id":"ckb1z4dji002g9n94qv2o4zgi"}],"PostTag":[{"post_id":"ckb1z4df8000d9n94y971h3q4","tag_id":"ckb1z4dfa000f9n94lnufje7d","_id":"ckb1z4dff000l9n940zrwue8d"},{"post_id":"ckb1z4dfb000g9n9429d6hw6f","tag_id":"ckb1z4dfe000j9n9410un1jew","_id":"ckb1z4dfi000q9n948c2uobgp"},{"post_id":"ckb1z4dfh000n9n94pgbh8gdk","tag_id":"ckb1z4dfa000f9n94lnufje7d","_id":"ckb1z4dfj000s9n94pdvrdrnk"},{"post_id":"ckb1z4dfc000h9n94iykooz9e","tag_id":"ckb1z4dfh000o9n94d108m541","_id":"ckb1z4dfk000v9n94mdod97o2"},{"post_id":"ckb1z4dfn00119n945tvjpcqj","tag_id":"ckb1z4dfa000f9n94lnufje7d","_id":"ckb1z4dfp00149n94fymkvqv7"},{"post_id":"ckb1z4dfl000x9n94t65twyap","tag_id":"ckb1z4dfn000z9n94und0k5hh","_id":"ckb1z4dft001a9n9471hwxh4d"},{"post_id":"ckb1z4dfl000x9n94t65twyap","tag_id":"ckb1z4dfp00139n94kl7xq53a","_id":"ckb1z4dfu001c9n946lrmjpo7"},{"post_id":"ckb1z4dfn00109n94te4bxos2","tag_id":"ckb1z4dfn000z9n94und0k5hh","_id":"ckb1z4dfy001i9n94arib2d4y"},{"post_id":"ckb1z4dfn00109n94te4bxos2","tag_id":"ckb1z4dfu001d9n945cij0kyq","_id":"ckb1z4dfz001k9n94833lvyeq"},{"post_id":"ckb1z4dfw001f9n94if1nac2j","tag_id":"ckb1z4dfa000f9n94lnufje7d","_id":"ckb1z4dg0001o9n94ewy8oyns"},{"post_id":"ckb1z4dfp00129n94gqv4ge4a","tag_id":"ckb1z4dfx001g9n94pdzz32uy","_id":"ckb1z4dg1001q9n94hoc5hr3p"},{"post_id":"ckb1z4dfu001b9n94fbrfxjdt","tag_id":"ckb1z4dfz001l9n947x1xgm2t","_id":"ckb1z4dg2001s9n94ky6ktqrn"},{"post_id":"ckb1z4dg1001r9n94b68il3om","tag_id":"ckb1z4dfa000f9n94lnufje7d","_id":"ckb1z4dg2001u9n9460skm4yk"},{"post_id":"ckb1z4dg2001t9n949z99pmz1","tag_id":"ckb1z4dg3001w9n941bj4luci","_id":"ckb1z4dg600209n94udawg0kx"},{"post_id":"ckb1z4dg5001z9n94bmiaayzz","tag_id":"ckb1z4dfa000f9n94lnufje7d","_id":"ckb1z4dg700229n94f9c8foek"},{"post_id":"ckb1z4dg800249n94jfj86104","tag_id":"ckb1z4dfa000f9n94lnufje7d","_id":"ckb1z4dga00269n943oehmog9"},{"post_id":"ckb1z4djc00279n94smdrxyr1","tag_id":"ckb1z4djg00299n9433xy1nn2","_id":"ckb1z4dji002f9n94686trnbp"},{"post_id":"ckb1z4djf00289n94ir0dl2nu","tag_id":"ckb1z4dji002e9n94n8e4d35w","_id":"ckb1z4dji002i9n94lsi1rt88"},{"post_id":"ckb1z4djh002b9n9476xy3wd5","tag_id":"ckb1z4dji002h9n94n0j7jerw","_id":"ckb1z4djj002j9n947qa3v2aq"}],"Tag":[{"name":"javascript","_id":"ckb1z4dfa000f9n94lnufje7d"},{"name":"eslint","_id":"ckb1z4dfe000j9n9410un1jew"},{"name":"git","_id":"ckb1z4dfh000o9n94d108m541"},{"name":"vue","_id":"ckb1z4dfn000z9n94und0k5hh"},{"name":"typescript","_id":"ckb1z4dfp00139n94kl7xq53a"},{"name":"性能优化","_id":"ckb1z4dfu001d9n945cij0kyq"},{"name":"debug","_id":"ckb1z4dfx001g9n94pdzz32uy"},{"name":"前端","_id":"ckb1z4dfz001l9n947x1xgm2t"},{"name":"移动端","_id":"ckb1z4dg3001w9n941bj4luci"},{"name":"浏览器","_id":"ckb1z4djg00299n9433xy1nn2"},{"name":"Markdown","_id":"ckb1z4dji002e9n94n8e4d35w"},{"name":"video","_id":"ckb1z4dji002h9n94n0j7jerw"}]}}